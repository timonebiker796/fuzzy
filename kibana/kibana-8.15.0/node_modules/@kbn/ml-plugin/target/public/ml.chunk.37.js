/*! Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one or more contributor license agreements.
 * Licensed under the Elastic License 2.0; you may not use this file except in compliance with the Elastic License 2.0. */
(window.ml_bundle_jsonpfunction=window.ml_bundle_jsonpfunction||[]).push([[37],{85:function(t,e,i){"use strict";i.r(e),i.d(e,"fieldFormatServiceFactory",(function(){return n}));var o=i(4),r=i.n(o),s=i(123),a=i(73);class field_format_service_FieldFormatService{constructor(t,e){r()(this,"indexPatternIdsByJob",{}),r()(this,"formatsByJob",{}),this.mlApiServices=t,this.mlIndexUtils=e}async populateFormats(t){(await Promise.all(t.map((async t=>{let e;if(this.mlApiServices){const{jobs:i}=await this.mlApiServices.getJobs({jobId:t});e=i[0]}else e=a.mlJobService.getJob(t);return{jobId:t,dataViewId:await this.mlIndexUtils.getDataViewIdFromName(e.datafeed_config.indices.join(","))}})))).forEach((({jobId:t,dataViewId:e})=>{null!==e&&(this.indexPatternIdsByJob[t]=e)}));const e=t.map((t=>Promise.all([this.getFormatsForJob(t)])));try{return(await Promise.all(e)).forEach(((e,i)=>{this.formatsByJob[t[i]]=e[0]})),this.formatsByJob}catch(t){return console.log("Error populating field formats:",t),{formats:{},error:t}}}getFieldFormat(t,e){if(this.formatsByJob.hasOwnProperty(t))return this.formatsByJob[t][e]}async getFormatsForJob(t){let e;if(this.mlApiServices){const{jobs:i}=await this.mlApiServices.getJobs({jobId:t});e=i[0]}else e=a.mlJobService.getJob(t);const i=e.analysis_config.detectors||[],o=[],r=this.indexPatternIdsByJob[t];if(void 0!==r){const t=await this.mlIndexUtils.getDataViewById(r),e=t.fields;i.forEach((i=>{const r=Object(s.s)(i.function);if(void 0!==i.field_name&&"cardinality"!==r){const r=e.getByName(i.field_name);void 0!==r&&(o[i.detector_index]=t.getFormatterForField(r))}}))}return o}}function n(t,e){return new field_format_service_FieldFormatService(t,e)}}}]);