"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useExplorerData = exports.isLoadExplorerDataConfig = void 0;
var _memoizeOne = _interopRequireDefault(require("memoize-one"));
var _lodash = require("lodash");
var _useObservable = _interopRequireDefault(require("react-use/lib/useObservable"));
var _rxjs = require("rxjs");
var _react = require("react");
var _mlDatePicker = require("@kbn/ml-date-picker");
var _explorer_utils = require("../explorer_utils");
var _kibana = require("../../contexts/kibana");
var _results_service = require("../../services/results_service");
var _anomaly_explorer_context = require("../anomaly_explorer_context");
/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0; you may not use this file except in compliance with the Elastic License
 * 2.0.
 */

// Memoize the data fetching methods.
// wrapWithLastRefreshArg() wraps any given function and preprends a `lastRefresh` argument
// which will be considered by memoizeOne. This way we can add the `lastRefresh` argument as a
// caching parameter without having to change all the original functions which shouldn't care
// about this parameter. The generic type T retains and returns the type information of
// the original function.
const memoizeIsEqual = (newArgs, lastArgs) => (0, _lodash.isEqual)(newArgs, lastArgs);
const wrapWithLastRefreshArg = (func, context = null) => {
  return function (lastRefresh, ...args) {
    return func.apply(context, args);
  };
};
const memoize = (func, context) => {
  return (0, _memoizeOne.default)(wrapWithLastRefreshArg(func, context), memoizeIsEqual);
};
const memoizedLoadOverallAnnotations = memoize(_explorer_utils.loadOverallAnnotations);
const memoizedLoadAnnotationsTableData = memoize(_explorer_utils.loadAnnotationsTableData);
const memoizedLoadFilteredTopInfluencers = memoize(_explorer_utils.loadFilteredTopInfluencers);
const memoizedLoadTopInfluencers = memoize(_explorer_utils.loadTopInfluencers);
const memoizedLoadAnomaliesTableData = memoize(_explorer_utils.loadAnomaliesTableData);
const isLoadExplorerDataConfig = arg => {
  return arg !== undefined && arg.selectedJobs !== undefined && arg.selectedJobs !== null && arg.viewBySwimlaneFieldName !== undefined;
};

/**
 * Fetches the data necessary for the Anomaly Explorer using observables.
 */
exports.isLoadExplorerDataConfig = isLoadExplorerDataConfig;
const loadExplorerDataProvider = (mlResultsService, anomalyExplorerChartsService, timefilter) => {
  return config => {
    if (!isLoadExplorerDataConfig(config)) {
      return (0, _rxjs.of)({});
    }
    const {
      lastRefresh,
      influencersFilterQuery,
      noInfluencersConfigured,
      selectedCells,
      selectedJobs,
      tableInterval,
      tableSeverity,
      viewBySwimlaneFieldName
    } = config;
    const selectionInfluencers = (0, _explorer_utils.getSelectionInfluencers)(selectedCells, viewBySwimlaneFieldName);
    const jobIds = (0, _explorer_utils.getSelectionJobIds)(selectedCells, selectedJobs);
    const bounds = timefilter.getBounds();
    const timerange = (0, _explorer_utils.getSelectionTimeRange)(selectedCells, bounds);
    const dateFormatTz = (0, _explorer_utils.getDateFormatTz)();

    // First get the data where we have all necessary args at hand using forkJoin:
    // annotationsData, anomalyChartRecords, influencers, overallState, tableData
    return (0, _rxjs.forkJoin)({
      overallAnnotations: memoizedLoadOverallAnnotations(lastRefresh, selectedJobs, bounds),
      annotationsData: memoizedLoadAnnotationsTableData(lastRefresh, selectedCells, selectedJobs, bounds),
      anomalyChartRecords: anomalyExplorerChartsService.loadDataForCharts$(jobIds, timerange.earliestMs, timerange.latestMs, selectionInfluencers, selectedCells, influencersFilterQuery),
      influencers: selectionInfluencers.length === 0 ? memoizedLoadTopInfluencers(lastRefresh, mlResultsService, jobIds, timerange.earliestMs, timerange.latestMs, [], noInfluencersConfigured, influencersFilterQuery) : Promise.resolve({}),
      tableData: memoizedLoadAnomaliesTableData(lastRefresh, selectedCells, selectedJobs, dateFormatTz, bounds, viewBySwimlaneFieldName, tableInterval, tableSeverity, influencersFilterQuery)
    }).pipe((0, _rxjs.switchMap)(({
      overallAnnotations,
      anomalyChartRecords,
      influencers,
      annotationsData,
      tableData
    }) => (0, _rxjs.forkJoin)({
      filteredTopInfluencers: (selectionInfluencers.length > 0 || influencersFilterQuery !== undefined) && anomalyChartRecords !== undefined && anomalyChartRecords.length > 0 ? memoizedLoadFilteredTopInfluencers(lastRefresh, mlResultsService, jobIds, timerange.earliestMs, timerange.latestMs, anomalyChartRecords, selectionInfluencers, noInfluencersConfigured, influencersFilterQuery) : Promise.resolve(influencers)
    }).pipe((0, _rxjs.map)(({
      filteredTopInfluencers
    }) => {
      return {
        overallAnnotations,
        annotations: annotationsData,
        influencers: filteredTopInfluencers,
        loading: false,
        anomalyChartsDataLoading: false,
        tableData
      };
    }))));
  };
};
const useExplorerData = () => {
  const timefilter = (0, _mlDatePicker.useTimefilter)();
  const {
    services: {
      mlServices: {
        mlApiServices
      }
    }
  } = (0, _kibana.useMlKibana)();
  const {
    anomalyExplorerChartsService
  } = (0, _anomaly_explorer_context.useAnomalyExplorerContext)();
  const loadExplorerData = (0, _react.useMemo)(() => {
    const mlResultsService = (0, _results_service.mlResultsServiceProvider)(mlApiServices);
    return loadExplorerDataProvider(mlResultsService, anomalyExplorerChartsService, timefilter);
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);
  const loadExplorerData$ = (0, _react.useMemo)(() => new _rxjs.Subject(), []);
  // eslint-disable-next-line react-hooks/exhaustive-deps
  const explorerData$ = (0, _react.useMemo)(() => loadExplorerData$.pipe((0, _rxjs.switchMap)(loadExplorerData)), []);
  const explorerData = (0, _useObservable.default)(explorerData$);
  const update = (0, _react.useCallback)(c => {
    loadExplorerData$.next(c);
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);
  return [explorerData, update];
};
exports.useExplorerData = useExplorerData;