"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.streamFactory = streamFactory;
var _stream = require("stream");
var _lodash = require("lodash");
/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0; you may not use this file except in compliance with the Elastic License
 * 2.0.
 */

// adapted from @kbn/ml-response-stream with the following changes:
// - removed gzip compression
// - removed support for ndjson
// - improved the cloud proxy buffer to work for our use case (works for newline string chunks vs ndjson only)

const DELIMITER = `
`;
function streamFactory(logger, flushFix = true) {
  const cloudProxyBufferSize = 4096;
  const flushPayload = flushFix ? DELIMITER + '10: "' + (0, _lodash.repeat)('0', cloudProxyBufferSize * 2) + '"' + DELIMITER : undefined;
  let currentBufferSize = 0;
  const stream = new _stream.PassThrough();
  const backPressureBuffer = [];
  let tryToEnd = false;
  const flushBufferIfNeeded = () => {
    if (currentBufferSize && currentBufferSize <= cloudProxyBufferSize) {
      push(flushPayload);
      currentBufferSize = 0;
    }
  };
  const flushIntervalId = setInterval(flushBufferIfNeeded, 250);
  function end() {
    tryToEnd = true;
    clearInterval(flushIntervalId);
    if (backPressureBuffer.length > 0) {
      const el = backPressureBuffer.shift();
      if (el !== undefined) {
        push(el);
      }
      return;
    }
    stream.end();
  }
  function push(d) {
    if (d === undefined) {
      logger.error('Stream chunk must not be undefined.');
      return;
    }
    if (backPressureBuffer.length > 0) {
      backPressureBuffer.push(d);
      return;
    }
    if (tryToEnd) {
      return;
    }
    try {
      const line = d;
      const writeOk = stream.write(line);
      currentBufferSize = currentBufferSize <= cloudProxyBufferSize ? JSON.stringify(line).length + currentBufferSize : cloudProxyBufferSize;
      if (!writeOk) {
        backPressureBuffer.push(d);
      }
    } catch (e) {
      logger.error(`Could not serialize or stream data chunk: ${e.toString()}`);
    }
  }
  const responseWithHeaders = {
    body: stream,
    headers: {
      'X-Accel-Buffering': 'no',
      'X-Content-Type-Options': 'nosniff',
      'Cache-Control': 'no-cache',
      Connection: 'keep-alive',
      'Transfer-Encoding': 'chunked'
    }
  };
  return {
    DELIMITER,
    end,
    push,
    responseWithHeaders
  };
}