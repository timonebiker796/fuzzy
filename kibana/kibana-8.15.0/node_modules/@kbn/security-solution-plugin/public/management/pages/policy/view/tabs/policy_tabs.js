"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PolicyTabs = void 0;
var _eui = require("@elastic/eui");
var _i18n = require("@kbn/i18n");
var _i18nReact = require("@kbn/i18n-react");
var _react = _interopRequireWildcard(require("react"));
var _reactRouterDom = require("react-router-dom");
var _event_filters_process_descendant_indicator = require("../../../../components/artifact_entry_card/components/card_decorators/event_filters_process_descendant_indicator");
var _unsaved_changes_confirm_modal = require("./unsaved_changes_confirm_modal");
var _use_license = require("../../../../../common/hooks/use_license");
var _use_experimental_features = require("../../../../../common/hooks/use_experimental_features");
var _protection_updates_layout = require("../protection_updates/protection_updates_layout");
var _policy_settings_layout = require("../policy_settings_layout");
var _user_privileges = require("../../../../../common/components/user_privileges");
var _routing = require("../../../../common/routing");
var _kibana = require("../../../../../common/lib/kibana");
var _management_page_loader = require("../../../../components/management_page_loader");
var _selectors = require("../../store/policy_details/selectors");
var _policy_artifacts_layout = require("../artifacts/layout/policy_artifacts_layout");
var _policy_hooks = require("../policy_hooks");
var _event_filters_translations = require("./event_filters_translations");
var _trusted_apps_translations = require("./trusted_apps_translations");
var _host_isolation_exceptions_translations = require("./host_isolation_exceptions_translations");
var _blocklists_translations = require("./blocklists_translations");
var _api_client = require("../../../trusted_apps/service/api_client");
var _api_client2 = require("../../../event_filters/service/api_client");
var _blocklists_api_client = require("../../../blocklist/services/blocklists_api_client");
var _host_isolation_exceptions_api_client = require("../../../host_isolation_exceptions/host_isolation_exceptions_api_client");
var _constants = require("../../../trusted_apps/constants");
var _constants2 = require("../../../event_filters/constants");
var _constants3 = require("../../../host_isolation_exceptions/constants");
var _constants4 = require("../../../blocklist/constants");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0; you may not use this file except in compliance with the Elastic License
 * 2.0.
 */
var PolicyTabKeys = /*#__PURE__*/function (PolicyTabKeys) {
  PolicyTabKeys["SETTINGS"] = "settings";
  PolicyTabKeys["TRUSTED_APPS"] = "trustedApps";
  PolicyTabKeys["EVENT_FILTERS"] = "eventFilters";
  PolicyTabKeys["HOST_ISOLATION_EXCEPTIONS"] = "hostIsolationExceptions";
  PolicyTabKeys["BLOCKLISTS"] = "blocklists";
  PolicyTabKeys["PROTECTION_UPDATES"] = "protectionUpdates";
  return PolicyTabKeys;
}(PolicyTabKeys || {});
const PolicyTabs = exports.PolicyTabs = /*#__PURE__*/_react.default.memo(() => {
  const history = (0, _reactRouterDom.useHistory)();
  const http = (0, _kibana.useHttp)();
  const toasts = (0, _kibana.useToasts)();
  const isInSettingsTab = (0, _policy_hooks.usePolicyDetailsSelector)(_selectors.isOnPolicyFormView);
  const isInTrustedAppsTab = (0, _policy_hooks.usePolicyDetailsSelector)(_selectors.isOnPolicyTrustedAppsView);
  const isInEventFiltersTab = (0, _policy_hooks.usePolicyDetailsSelector)(_selectors.isOnPolicyEventFiltersView);
  const isInHostIsolationExceptionsTab = (0, _policy_hooks.usePolicyDetailsSelector)(_selectors.isOnHostIsolationExceptionsView);
  const isInBlocklistsTab = (0, _policy_hooks.usePolicyDetailsSelector)(_selectors.isOnBlocklistsView);
  const isInProtectionUpdatesTab = (0, _policy_hooks.usePolicyDetailsSelector)(_selectors.isOnProtectionUpdatesView);
  const policyId = (0, _policy_hooks.usePolicyDetailsSelector)(_selectors.policyIdFromParams);
  const [unsavedChangesModal, setUnsavedChangesModal] = (0, _react.useState)({
    showModal: false,
    nextTab: null
  });
  const [unsavedChanges, setUnsavedChanges] = (0, _react.useState)({
    [PolicyTabKeys.SETTINGS]: false,
    [PolicyTabKeys.PROTECTION_UPDATES]: false
  });
  const setTabUnsavedChanges = (0, _react.useCallback)(tab => hasUnsavedChanges => {
    if (unsavedChanges[tab] !== hasUnsavedChanges) {
      setUnsavedChanges(prev => ({
        ...prev,
        [tab]: hasUnsavedChanges
      }));
    }
  }, [unsavedChanges]);

  // By the time the tabs load, we know that we already have a `policyItem` since a conditional
  // check is done at the `PageDetails` component level. So asserting to non-null/undefined here.
  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
  const policyItem = (0, _policy_hooks.usePolicyDetailsSelector)(_selectors.policyDetails);
  const {
    canReadTrustedApplications,
    canWriteTrustedApplications,
    canReadEventFilters,
    canWriteEventFilters,
    canReadHostIsolationExceptions,
    canWriteHostIsolationExceptions,
    canReadBlocklist,
    canWriteBlocklist,
    loading: privilegesLoading
  } = (0, _user_privileges.useUserPrivileges)().endpointPrivileges;
  const {
    state: routeState = {}
  } = (0, _reactRouterDom.useLocation)();
  const isProtectionUpdatesFeatureEnabled = (0, _use_experimental_features.useIsExperimentalFeatureEnabled)('protectionUpdatesEnabled');
  const isEnterprise = (0, _use_license.useLicense)().isEnterprise();
  const isProtectionUpdatesEnabled = isEnterprise && isProtectionUpdatesFeatureEnabled;
  // move the user out of this route if they can't access it
  (0, _react.useEffect)(() => {
    if (isInTrustedAppsTab && !canReadTrustedApplications || isInEventFiltersTab && !canReadEventFilters || isInHostIsolationExceptionsTab && !canReadHostIsolationExceptions || isInBlocklistsTab && !canReadBlocklist) {
      history.replace((0, _routing.getPolicyDetailPath)(policyId));
      toasts.addDanger(_i18n.i18n.translate('xpack.securitySolution.policyDetails.missingArtifactAccess', {
        defaultMessage: 'You do not have the required Kibana permissions to use the given artifact.'
      }));
    }
  }, [canReadBlocklist, canReadEventFilters, canReadHostIsolationExceptions, canReadTrustedApplications, history, isInBlocklistsTab, isInEventFiltersTab, isInHostIsolationExceptionsTab, isInProtectionUpdatesTab, isInTrustedAppsTab, policyId, toasts]);
  const getTrustedAppsApiClientInstance = (0, _react.useCallback)(() => _api_client.TrustedAppsApiClient.getInstance(http), [http]);
  const getEventFiltersApiClientInstance = (0, _react.useCallback)(() => _api_client2.EventFiltersApiClient.getInstance(http), [http]);
  const getHostIsolationExceptionsApiClientInstance = (0, _react.useCallback)(() => _host_isolation_exceptions_api_client.HostIsolationExceptionsApiClient.getInstance(http), [http]);
  const getBlocklistsApiClientInstance = (0, _react.useCallback)(() => _blocklists_api_client.BlocklistsApiClient.getInstance(http), [http]);
  const tabs = (0, _react.useMemo)(() => {
    const trustedAppsLabels = {
      ..._trusted_apps_translations.POLICY_ARTIFACT_TRUSTED_APPS_LABELS,
      layoutAboutMessage: (count, link) => /*#__PURE__*/_react.default.createElement(_i18nReact.FormattedMessage, {
        id: "xpack.securitySolution.endpoint.policy.trustedApps.list.about",
        defaultMessage: "There {count, plural, one {is} other {are}} {count} trusted {count, plural, =1 {application} other {applications}} associated with this policy. Click here to {link}",
        values: {
          count,
          link
        }
      })
    };
    const eventFiltersLabels = {
      ..._event_filters_translations.POLICY_ARTIFACT_EVENT_FILTERS_LABELS,
      layoutAboutMessage: (count, link) => /*#__PURE__*/_react.default.createElement(_i18nReact.FormattedMessage, {
        id: "xpack.securitySolution.endpoint.policy.eventFilters.list.about",
        defaultMessage: "There {count, plural, one {is} other {are}} {count} event {count, plural, =1 {filter} other {filters}} associated with this policy. Click here to {link}",
        values: {
          count,
          link
        }
      })
    };
    const hostIsolationExceptionsLabels = {
      ..._host_isolation_exceptions_translations.POLICY_ARTIFACT_HOST_ISOLATION_EXCEPTIONS_LABELS,
      layoutAboutMessage: (count, link) => /*#__PURE__*/_react.default.createElement(_i18nReact.FormattedMessage, {
        id: "xpack.securitySolution.endpoint.policy.hostIsolationExceptions.list.about",
        defaultMessage: "There {count, plural, one {is} other {are}} {count} host isolation {count, plural, =1 {exception} other {exceptions}} associated with this policy. Click here to {link}",
        values: {
          count,
          link
        }
      })
    };
    const blocklistsLabels = {
      ..._blocklists_translations.POLICY_ARTIFACT_BLOCKLISTS_LABELS,
      layoutAboutMessage: (count, link) => /*#__PURE__*/_react.default.createElement(_i18nReact.FormattedMessage, {
        id: "xpack.securitySolution.endpoint.policy.blocklist.list.about",
        defaultMessage: "There {count, plural, one {is} other {are}} {count} {count, plural, =1 {blocklist} other {blocklist entries}} associated with this policy. Click here to {link}",
        values: {
          count,
          link
        }
      })
    };
    return {
      [PolicyTabKeys.SETTINGS]: {
        id: PolicyTabKeys.SETTINGS,
        name: _i18n.i18n.translate('xpack.securitySolution.endpoint.policy.details.tabs.policyForm', {
          defaultMessage: 'Policy settings'
        }),
        content: /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, /*#__PURE__*/_react.default.createElement(_eui.EuiSpacer, null), /*#__PURE__*/_react.default.createElement(_policy_settings_layout.PolicySettingsLayout, {
          policy: policyItem,
          setUnsavedChanges: setTabUnsavedChanges(PolicyTabKeys.SETTINGS)
        })),
        'data-test-subj': 'policySettingsTab'
      },
      [PolicyTabKeys.TRUSTED_APPS]: canReadTrustedApplications ? {
        id: PolicyTabKeys.TRUSTED_APPS,
        name: _i18n.i18n.translate('xpack.securitySolution.endpoint.policy.details.tabs.trustedApps', {
          defaultMessage: 'Trusted applications'
        }),
        content: /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, /*#__PURE__*/_react.default.createElement(_eui.EuiSpacer, null), /*#__PURE__*/_react.default.createElement(_policy_artifacts_layout.PolicyArtifactsLayout, {
          policyItem: policyItem,
          labels: trustedAppsLabels,
          getExceptionsListApiClient: getTrustedAppsApiClientInstance,
          searchableFields: _constants.SEARCHABLE_FIELDS,
          getArtifactPath: _routing.getTrustedAppsListPath,
          getPolicyArtifactsPath: _routing.getPolicyDetailsArtifactsListPath,
          canWriteArtifact: canWriteTrustedApplications
        })),
        'data-test-subj': 'policyTrustedAppsTab'
      } : undefined,
      [PolicyTabKeys.EVENT_FILTERS]: canReadEventFilters ? {
        id: PolicyTabKeys.EVENT_FILTERS,
        name: _i18n.i18n.translate('xpack.securitySolution.endpoint.policy.details.tabs.eventFilters', {
          defaultMessage: 'Event filters'
        }),
        content: /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, /*#__PURE__*/_react.default.createElement(_eui.EuiSpacer, null), /*#__PURE__*/_react.default.createElement(_policy_artifacts_layout.PolicyArtifactsLayout, {
          policyItem: policyItem,
          labels: eventFiltersLabels,
          getExceptionsListApiClient: getEventFiltersApiClientInstance,
          searchableFields: _constants2.SEARCHABLE_FIELDS,
          getArtifactPath: _routing.getEventFiltersListPath,
          getPolicyArtifactsPath: _routing.getPolicyEventFiltersPath,
          canWriteArtifact: canWriteEventFilters,
          CardDecorator: _event_filters_process_descendant_indicator.EventFiltersProcessDescendantIndicator
        })),
        'data-test-subj': 'policyEventFiltersTab'
      } : undefined,
      [PolicyTabKeys.HOST_ISOLATION_EXCEPTIONS]: canReadHostIsolationExceptions ? {
        id: PolicyTabKeys.HOST_ISOLATION_EXCEPTIONS,
        name: _i18n.i18n.translate('xpack.securitySolution.endpoint.policy.details.tabs.isInHostIsolationExceptions', {
          defaultMessage: 'Host isolation exceptions'
        }),
        content: /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, /*#__PURE__*/_react.default.createElement(_eui.EuiSpacer, null), /*#__PURE__*/_react.default.createElement(_policy_artifacts_layout.PolicyArtifactsLayout, {
          policyItem: policyItem,
          labels: hostIsolationExceptionsLabels,
          getExceptionsListApiClient: getHostIsolationExceptionsApiClientInstance,
          searchableFields: _constants3.SEARCHABLE_FIELDS,
          getArtifactPath: _routing.getHostIsolationExceptionsListPath,
          getPolicyArtifactsPath: _routing.getPolicyHostIsolationExceptionsPath,
          canWriteArtifact: canWriteHostIsolationExceptions
        })),
        'data-test-subj': 'policyHostIsolationExceptionsTab'
      } : undefined,
      [PolicyTabKeys.BLOCKLISTS]: canReadBlocklist ? {
        id: PolicyTabKeys.BLOCKLISTS,
        name: _i18n.i18n.translate('xpack.securitySolution.endpoint.policy.details.tabs.blocklists', {
          defaultMessage: 'Blocklist'
        }),
        content: /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, /*#__PURE__*/_react.default.createElement(_eui.EuiSpacer, null), /*#__PURE__*/_react.default.createElement(_policy_artifacts_layout.PolicyArtifactsLayout, {
          policyItem: policyItem,
          labels: blocklistsLabels,
          getExceptionsListApiClient: getBlocklistsApiClientInstance,
          searchableFields: _constants4.SEARCHABLE_FIELDS,
          getArtifactPath: _routing.getBlocklistsListPath,
          getPolicyArtifactsPath: _routing.getPolicyBlocklistsPath,
          canWriteArtifact: canWriteBlocklist
        })),
        'data-test-subj': 'policyBlocklistTab'
      } : undefined,
      [PolicyTabKeys.PROTECTION_UPDATES]: isProtectionUpdatesEnabled ? {
        id: PolicyTabKeys.PROTECTION_UPDATES,
        name: _i18n.i18n.translate('xpack.securitySolution.endpoint.policy.details.tabs.protectionUpdates', {
          defaultMessage: 'Protection updates'
        }),
        content: /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, /*#__PURE__*/_react.default.createElement(_eui.EuiSpacer, null), /*#__PURE__*/_react.default.createElement(_protection_updates_layout.ProtectionUpdatesLayout, {
          policy: policyItem,
          setUnsavedChanges: setTabUnsavedChanges(PolicyTabKeys.PROTECTION_UPDATES)
        })),
        'data-test-subj': 'policyProtectionUpdatesTab'
      } : undefined
    };
  }, [policyItem, setTabUnsavedChanges, canReadTrustedApplications, getTrustedAppsApiClientInstance, canWriteTrustedApplications, canReadEventFilters, getEventFiltersApiClientInstance, canWriteEventFilters, canReadHostIsolationExceptions, getHostIsolationExceptionsApiClientInstance, canWriteHostIsolationExceptions, canReadBlocklist, getBlocklistsApiClientInstance, canWriteBlocklist, isProtectionUpdatesEnabled]);

  // convert tabs object into an array EuiTabbedContent can understand
  const tabsList = (0, _react.useMemo)(() => Object.values(tabs).filter(tab => tab !== undefined), [tabs]);
  const currentSelectedTab = (0, _react.useMemo)(() => {
    const defaultTab = tabs[PolicyTabKeys.SETTINGS];
    let selectedTab;
    if (isInSettingsTab) {
      selectedTab = tabs[PolicyTabKeys.SETTINGS];
    } else if (isInTrustedAppsTab) {
      selectedTab = tabs[PolicyTabKeys.TRUSTED_APPS];
    } else if (isInEventFiltersTab) {
      selectedTab = tabs[PolicyTabKeys.EVENT_FILTERS];
    } else if (isInHostIsolationExceptionsTab) {
      selectedTab = tabs[PolicyTabKeys.HOST_ISOLATION_EXCEPTIONS];
    } else if (isInBlocklistsTab) {
      selectedTab = tabs[PolicyTabKeys.BLOCKLISTS];
    } else if (isInProtectionUpdatesTab) {
      selectedTab = tabs[PolicyTabKeys.PROTECTION_UPDATES];
    }
    return selectedTab || defaultTab;
  }, [tabs, isInSettingsTab, isInTrustedAppsTab, isInEventFiltersTab, isInHostIsolationExceptionsTab, isInBlocklistsTab, isInProtectionUpdatesTab]);
  const cancelUnsavedChangesModal = (0, _react.useCallback)(() => {
    setUnsavedChangesModal({
      showModal: false,
      nextTab: null
    });
  }, [setUnsavedChangesModal]);
  const changeTab = (0, _react.useCallback)(selectedTab => {
    if (unsavedChangesModal.showModal) {
      cancelUnsavedChangesModal();
    }
    let path = '';
    switch (selectedTab.id) {
      case PolicyTabKeys.SETTINGS:
        path = (0, _routing.getPolicyDetailPath)(policyId);
        break;
      case PolicyTabKeys.TRUSTED_APPS:
        path = (0, _routing.getPolicyTrustedAppsPath)(policyId);
        break;
      case PolicyTabKeys.EVENT_FILTERS:
        path = (0, _routing.getPolicyEventFiltersPath)(policyId);
        break;
      case PolicyTabKeys.HOST_ISOLATION_EXCEPTIONS:
        path = (0, _routing.getPolicyHostIsolationExceptionsPath)(policyId);
        break;
      case PolicyTabKeys.BLOCKLISTS:
        path = (0, _routing.getPolicyBlocklistsPath)(policyId);
        break;
      case PolicyTabKeys.PROTECTION_UPDATES:
        path = (0, _routing.getPolicyProtectionUpdatesPath)(policyId);
        break;
    }
    history.push(path, routeState !== null && routeState !== void 0 && routeState.backLink ? {
      backLink: routeState.backLink
    } : null);
  }, [cancelUnsavedChangesModal, history, policyId, routeState === null || routeState === void 0 ? void 0 : routeState.backLink, unsavedChangesModal.showModal]);
  const onTabClickHandler = (0, _react.useCallback)(selectedTab => {
    if (isInSettingsTab && unsavedChanges[PolicyTabKeys.SETTINGS] || isInProtectionUpdatesTab && unsavedChanges[PolicyTabKeys.PROTECTION_UPDATES]) {
      setUnsavedChangesModal({
        showModal: true,
        nextTab: selectedTab
      });
    } else {
      changeTab(selectedTab);
    }
  }, [changeTab, isInProtectionUpdatesTab, isInSettingsTab, unsavedChanges]);
  const confirmUnsavedChangesModal = (0, _react.useCallback)(() => {
    if (unsavedChangesModal.nextTab) {
      changeTab(unsavedChangesModal.nextTab);
    }
  }, [changeTab, unsavedChangesModal.nextTab]);

  // show loader for privileges validation
  if (privilegesLoading) {
    return /*#__PURE__*/_react.default.createElement(_management_page_loader.ManagementPageLoader, {
      "data-test-subj": "privilegesLoading"
    });
  }
  return /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, unsavedChangesModal.showModal && /*#__PURE__*/_react.default.createElement(_unsaved_changes_confirm_modal.UnsavedChangesConfirmModal, {
    onCancel: cancelUnsavedChangesModal,
    onConfirm: confirmUnsavedChangesModal
  }), /*#__PURE__*/_react.default.createElement(_eui.EuiTabbedContent, {
    "data-test-subj": "policyTabs",
    tabs: tabsList,
    selectedTab: currentSelectedTab,
    size: "l",
    onTabClick: onTabClickHandler
  }));
});
PolicyTabs.displayName = 'PolicyTabs';