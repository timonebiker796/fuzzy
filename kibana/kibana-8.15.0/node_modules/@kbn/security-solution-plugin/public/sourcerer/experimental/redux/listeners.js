"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.startAppListening = exports.listenerMiddleware = exports.createInitDataviewListener = exports.createChangeDataviewListener = void 0;
var _toolkit = require("@reduxjs/toolkit");
var _sourcerer = require("../../../../common/utils/sourcerer");
var _is_enabled = require("../is_enabled");
var _actions = require("./actions");
/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0; you may not use this file except in compliance with the Elastic License
 * 2.0.
 */

// NOTE: types below exist because we are using redux-toolkit version lower than 2.x
// in v2, there are TS helpers that make it easy to setup overrides that are necessary here.

/**
 * This is the proposed way of handling side effects within sourcerer code. We will no longer rely on useEffect for doing things like
 * enriching the store with data fetched asynchronously in response to user doing something.
 * Thunks are also considered for simpler flows but this has the advantage of cancellation support through `listnerApi` below.
 */

// NOTE: this should only be executed once in the application lifecycle, to LAZILY setup the component data
const createInitDataviewListener = () => {
  return {
    actionCreator: _actions.init,
    effect: async (action, listenerApi) => {
      // WARN:  Skip the init call if the experimental implementation is disabled
      if (!(0, _is_enabled.isExperimentalSourcererEnabled)()) {
        return;
      }
      // NOTE: We should only run this once, when particular sourcerer instance is in pristine state (not touched by the user)
      if (listenerApi.getState().dataViewPicker.state !== 'pristine') {
        return;
      }

      // NOTE: dispatch the regular change listener
      listenerApi.dispatch((0, _actions.selectDataView)(action.payload));
    }
  };
};

// NOTE: this listener is executed whenever user decides to select dataview from the picker
exports.createInitDataviewListener = createInitDataviewListener;
const createChangeDataviewListener = ({
  dataViewsService
}) => {
  return {
    actionCreator: _actions.selectDataView,
    effect: async (action, listenerApi) => {
      const dataViewId = action.payload;
      const refreshFields = false;
      const dataView = await dataViewsService.get(dataViewId, true, refreshFields);
      const dataViewData = dataView.toSpec();
      listenerApi.dispatch((0, _actions.setDataViewData)(dataViewData));
      const defaultPatternsList = (0, _sourcerer.ensurePatternFormat)(dataView.getIndexPattern().split(','));
      const patternList = await dataViewsService.getExistingIndices(defaultPatternsList);
      listenerApi.dispatch((0, _actions.setPatternList)(patternList));
    }
  };
};
exports.createChangeDataviewListener = createChangeDataviewListener;
const listenerMiddleware = exports.listenerMiddleware = (0, _toolkit.createListenerMiddleware)();

// NOTE: register side effect listeners
const startAppListening = exports.startAppListening = listenerMiddleware.startListening;