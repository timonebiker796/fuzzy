"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DataViewPicker = void 0;
var _public = require("@kbn/unified-search-plugin/public");
var _react = _interopRequireWildcard(require("react"));
var _reactRedux = require("react-redux");
var _kibana_react = require("../../../../common/lib/kibana/kibana_react");
var _constants = require("../../constants");
var _actions = require("../../redux/actions");
var _selectors = require("../../redux/selectors");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0; you may not use this file except in compliance with the Elastic License
 * 2.0.
 */

const TRIGGER_CONFIG = {
  label: 'Dataview',
  color: 'danger',
  title: 'Experimental data view picker',
  iconType: 'beaker'
};
const DataViewPicker = exports.DataViewPicker = /*#__PURE__*/(0, _react.memo)(() => {
  const dispatch = (0, _reactRedux.useDispatch)();
  const {
    services: {
      dataViewEditor,
      data,
      dataViewFieldEditor
    }
  } = (0, _kibana_react.useKibana)();
  const closeDataViewEditor = (0, _react.useRef)();
  const closeFieldEditor = (0, _react.useRef)();

  // TODO: should this be implemented like that? If yes, we need to source dataView somehow or implement the same thing based on the existing state value.
  // const canEditDataView =
  // Boolean(dataViewEditor?.userPermissions.editDataView()) || !dataView.isPersisted();
  const canEditDataView = true;
  const {
    dataViewId
  } = (0, _reactRedux.useSelector)(_selectors.sourcererAdapterSelector);
  const createNewDataView = (0, _react.useCallback)(async () => {
    closeDataViewEditor.current = await dataViewEditor.openEditor({
      // eslint-disable-next-line no-console
      onSave: () => console.log('new data view saved'),
      allowAdHocDataView: true
    });
  }, [dataViewEditor]);
  const onFieldEdited = (0, _react.useCallback)(() => {}, []);
  const editField = (0, _react.useMemo)(() => {
    if (!canEditDataView) {
      return;
    }
    return async (fieldName, _uiAction = 'edit') => {
      if (!dataViewId) {
        return;
      }
      const dataViewInstance = await data.dataViews.get(dataViewId);
      closeFieldEditor.current = await dataViewFieldEditor.openEditor({
        ctx: {
          dataView: dataViewInstance
        },
        fieldName,
        onSave: async () => {
          onFieldEdited();
        }
      });
    };
  }, [canEditDataView, dataViewId, data.dataViews, dataViewFieldEditor, onFieldEdited]);
  const addField = (0, _react.useMemo)(() => canEditDataView && editField ? () => editField(undefined, 'add') : undefined, [editField, canEditDataView]);
  const handleChangeDataView = (0, _react.useCallback)(id => {
    dispatch((0, _actions.selectDataView)(id));
  }, [dispatch]);
  const handleEditDataView = (0, _react.useCallback)(() => {}, []);
  return /*#__PURE__*/_react.default.createElement(_public.DataViewPicker, {
    currentDataViewId: dataViewId || _constants.DEFAULT_SECURITY_SOLUTION_DATA_VIEW_ID,
    trigger: TRIGGER_CONFIG,
    onChangeDataView: handleChangeDataView,
    onEditDataView: handleEditDataView,
    onAddField: addField,
    onDataViewCreated: createNewDataView
  });
});
DataViewPicker.displayName = 'DataviewPicker';