"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.HoverPopover = void 0;
var _eui = require("@elastic/eui");
var _securitysolutionTGrid = require("@kbn/securitysolution-t-grid");
var _react = _interopRequireWildcard(require("react"));
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0; you may not use this file except in compliance with the Elastic License
 * 2.0.
 */

/**
 * To avoid expensive changes to the DOM, delay showing the popover menu
 */
const HOVER_INTENT_DELAY = 100; // ms

/**
 * Decorates it's children with actions that are visible on hover.
 * This component does not enforce an opinion on the styling and
 * positioning of the hover content, but see the documentation for
 * the `hoverContent` for tips on (not) effecting layout on-hover.
 *
 * In addition to rendering the `hoverContent` prop on hover, this
 * component also passes `showHoverContent` as a render prop, which
 * provides a signal to the content that the user is in a hover state.
 *
 * IMPORTANT: This hover menu delegates focus management to the
 * `hoverContent` and does NOT own focus, because it should not
 * automatically "steal" focus. You must manage focus ownership,
 * otherwise it will be difficult for keyboard-only and screen
 * reader users to navigate to and from your popover.
 */
const HoverPopover = exports.HoverPopover = /*#__PURE__*/_react.default.memo(({
  hoverContent,
  anchorPosition = 'downCenter',
  children
}) => {
  const [isOpen, setIsOpen] = (0, _react.useState)(hoverContent != null);
  const [showHoverContent, setShowHoverContent] = (0, _react.useState)(false);
  const [, setHoverTimeout] = (0, _react.useState)(undefined);
  const popoverRef = (0, _react.useRef)(null);
  const tryClosePopover = (0, _react.useCallback)(() => {
    setHoverTimeout(prevHoverTimeout => {
      clearTimeout(prevHoverTimeout);
      return undefined;
    });
    setShowHoverContent(false);
  }, []);
  const onMouseEnter = (0, _react.useCallback)(() => {
    setHoverTimeout(Number(setTimeout(() => {
      // NOTE: the following read from the DOM is expensive, but not as
      // expensive as the default behavior, which adds a div to the body,
      // which-in turn performs a more expensive change to the layout
      if (!document.body.classList.contains(_securitysolutionTGrid.IS_DRAGGING_CLASS_NAME)) {
        setShowHoverContent(true);
      }
    }, HOVER_INTENT_DELAY)));
  }, [setHoverTimeout, setShowHoverContent]);
  const onMouseLeave = (0, _react.useCallback)(() => {
    tryClosePopover();
  }, [tryClosePopover]);
  const onKeyDown = (0, _react.useCallback)(keyboardEvent => {
    if (isOpen && keyboardEvent.key === 'Escape') {
      onMouseLeave();
    }
  }, [isOpen, onMouseLeave]);
  (0, _react.useEffect)(() => {
    setIsOpen(hoverContent != null && showHoverContent);
  }, [hoverContent, showHoverContent]);
  (0, _react.useEffect)(() => {
    var _popoverRef$current;
    // in case of dynamic content i.e when the value of hoverContent changes,
    // we will try to reposition the popover so that the content does not collide with screen edge.
    if (isOpen) popoverRef === null || popoverRef === void 0 ? void 0 : (_popoverRef$current = popoverRef.current) === null || _popoverRef$current === void 0 ? void 0 : _popoverRef$current.positionPopoverFluid();
  }, [hoverContent, isOpen]);
  return /*#__PURE__*/_react.default.createElement("div", {
    onMouseLeave: onMouseLeave
  }, /*#__PURE__*/_react.default.createElement(_eui.EuiPopover, {
    ref: popoverRef,
    anchorPosition: anchorPosition,
    button: /*#__PURE__*/_react.default.createElement("div", {
      "data-test-subj": "HoverPopoverButton",
      onMouseEnter: onMouseEnter
    }, children),
    closePopover: tryClosePopover,
    hasArrow: false,
    isOpen: isOpen,
    ownFocus: false,
    panelPaddingSize: "none",
    panelStyle: {
      minInlineSize: 'fit-content'
    },
    panelClassName: "HoverPopover__popover",
    repositionOnScroll: true
  }, isOpen ? /*#__PURE__*/_react.default.createElement("div", {
    onKeyDown: onKeyDown
  }, hoverContent) : null));
});
HoverPopover.displayName = 'HoverPopover';