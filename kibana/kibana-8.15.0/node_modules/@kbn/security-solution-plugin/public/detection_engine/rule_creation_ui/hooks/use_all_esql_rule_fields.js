"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useEsqlFields = exports.useAllEsqlRuleFields = void 0;
var _react = require("react");
var _useDebounce = _interopRequireDefault(require("react-use/lib/useDebounce"));
var _reactQuery = require("@tanstack/react-query");
var _public = require("@kbn/kibana-react-plugin/public");
var _esql_validator = require("../../rule_creation/logic/esql_validator");
var _get_esql_query_config = require("../../rule_creation/logic/get_esql_query_config");
/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0; you may not use this file except in compliance with the Elastic License
 * 2.0.
 */

const esqlToFields = columns => {
  if (columns && 'error' in columns) {
    return [];
  }
  const fields = (columns !== null && columns !== void 0 ? columns : []).map(({
    id,
    meta
  }) => {
    return {
      name: id,
      type: meta.type
    };
  });
  return fields;
};
/**
 * fetches ES|QL fields and convert them to DataViewBase fields
 */
const useEsqlFields = esqlQuery => {
  var _dataService$search;
  const kibana = (0, _public.useKibana)();
  const {
    data: dataService
  } = kibana.services;
  const queryConfig = (0, _get_esql_query_config.getEsqlQueryConfig)({
    esqlQuery,
    search: dataService === null || dataService === void 0 ? void 0 : (_dataService$search = dataService.search) === null || _dataService$search === void 0 ? void 0 : _dataService$search.search
  });
  const {
    data,
    isLoading
  } = (0, _reactQuery.useQuery)(queryConfig);
  const fields = (0, _react.useMemo)(() => {
    return esqlToFields(data);
  }, [data]);
  return {
    fields,
    isLoading
  };
};

/**
 * if ES|QL fields and index pattern fields have same name, duplicates will be removed and the rest of fields merged
 * ES|QL fields are first in order, since these are the fields that returned in ES|QL response
 * */
exports.useEsqlFields = useEsqlFields;
const deduplicateAndMergeFields = (esqlFields, indexPatternsFields) => {
  const esqlFieldsSet = new Set(esqlFields.map(field => field.name));
  return [...esqlFields, ...indexPatternsFields.filter(field => !esqlFieldsSet.has(field.name))];
};
/**
 * returns all fields available for ES|QL rule:
 * - fields returned from ES|QL query for aggregating queries
 * - fields returned from ES|QL query + index fields for non-aggregating queries
 */
const useAllEsqlRuleFields = ({
  esqlQuery,
  indexPatternsFields
}) => {
  const [debouncedEsqlQuery, setDebouncedEsqlQuery] = (0, _react.useState)(undefined);
  const {
    fields: esqlFields,
    isLoading
  } = useEsqlFields(debouncedEsqlQuery);
  const {
    isEsqlQueryAggregating
  } = (0, _react.useMemo)(() => (0, _esql_validator.parseEsqlQuery)(debouncedEsqlQuery !== null && debouncedEsqlQuery !== void 0 ? debouncedEsqlQuery : ''), [debouncedEsqlQuery]);
  (0, _useDebounce.default)(() => {
    setDebouncedEsqlQuery(esqlQuery);
  }, 300, [esqlQuery]);
  const fields = (0, _react.useMemo)(() => {
    if (!debouncedEsqlQuery) {
      return indexPatternsFields;
    }
    return isEsqlQueryAggregating ? esqlFields : deduplicateAndMergeFields(esqlFields, indexPatternsFields);
  }, [esqlFields, debouncedEsqlQuery, indexPatternsFields, isEsqlQueryAggregating]);
  return {
    fields,
    isLoading
  };
};
exports.useAllEsqlRuleFields = useAllEsqlRuleFields;