"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.dataReducer = void 0;
var _typescriptFsaReducers = require("typescript-fsa-reducers");
var treeFetcherParameters = _interopRequireWildcard(require("../../models/tree_fetcher_parameters"));
var selectors = _interopRequireWildcard(require("./selectors"));
var nodeEventsInCategoryModel = _interopRequireWildcard(require("./node_events_in_category_model"));
var nodeDataModel = _interopRequireWildcard(require("../../models/node_data"));
var _normalize_time_range = require("../../../common/utils/normalize_time_range");
var _helpers = require("../helpers");
var _actions = require("../actions");
var _action = require("./action");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0; you may not use this file except in compliance with the Elastic License
 * 2.0.
 */

const dataReducer = exports.dataReducer = (0, _typescriptFsaReducers.reducerWithInitialState)(_helpers.initialAnalyzerState).withHandling((0, _helpers.immerCase)(_actions.appReceivedNewExternalProperties, (draft, {
  id,
  resolverComponentInstanceID,
  locationSearch,
  databaseDocumentID,
  indices,
  filters
}) => {
  var _draft$id, _state$tree, _state$tree$lastRespo, _state$tree$lastRespo2;
  const state = (_draft$id = draft[id]) === null || _draft$id === void 0 ? void 0 : _draft$id.data;
  state.tree = {
    ...state.tree,
    currentParameters: {
      databaseDocumentID,
      indices,
      filters,
      agentId: ((_state$tree = state.tree) === null || _state$tree === void 0 ? void 0 : (_state$tree$lastRespo = _state$tree.lastResponse) === null || _state$tree$lastRespo === void 0 ? void 0 : (_state$tree$lastRespo2 = _state$tree$lastRespo.parameters) === null || _state$tree$lastRespo2 === void 0 ? void 0 : _state$tree$lastRespo2.agentId) || ''
    }
  };
  state.resolverComponentInstanceID = resolverComponentInstanceID;
  state.locationSearch = locationSearch;
  state.indices = indices;
  const panelViewAndParameters = selectors.panelViewAndParameters(state);
  if (!state.nodeEventsInCategory || !nodeEventsInCategoryModel.isRelevantToPanelViewAndParameters(state.nodeEventsInCategory, panelViewAndParameters)) {
    state.nodeEventsInCategory = undefined;
  }
  return draft;
})).withHandling((0, _helpers.immerCase)(_action.appRequestedResolverData, (draft, {
  id,
  parameters
}) => {
  const state = draft[id].data;
  // keep track of what we're requesting, this way we know when to request and when not to.
  state.tree = {
    ...state.tree,
    pendingRequestParameters: {
      databaseDocumentID: parameters.databaseDocumentID,
      indices: parameters.indices,
      filters: parameters.filters,
      agentId: parameters.agentId
    }
  };
  return draft;
})).withHandling((0, _helpers.immerCase)(_action.appAbortedResolverDataRequest, (draft, {
  id,
  parameters
}) => {
  var _state$tree2;
  const state = draft[id].data;
  if (treeFetcherParameters.equal(parameters, (_state$tree2 = state.tree) === null || _state$tree2 === void 0 ? void 0 : _state$tree2.pendingRequestParameters)) {
    // the request we were awaiting was aborted
    state.tree = {
      ...state.tree,
      pendingRequestParameters: undefined
    };
  }
  return draft;
})).withHandling((0, _helpers.immerCase)(_action.serverReturnedResolverData, (draft, {
  id,
  result,
  dataSource,
  schema,
  parameters,
  detectedBounds
}) => {
  var _state$tree3;
  const state = draft[id].data;
  /** Only handle this if we are expecting a response */
  state.tree = {
    ...state.tree,
    ...((_state$tree3 = state.tree) !== null && _state$tree3 !== void 0 && _state$tree3.currentParameters ? {
      currentParameters: {
        ...state.tree.currentParameters,
        agentId: parameters.agentId
      }
    } : {}),
    /**
     * Store the last received data, as well as the databaseDocumentID it relates to.
     */
    lastResponse: {
      result,
      dataSource,
      schema,
      parameters,
      successful: true
    },
    // This assumes that if we just received something, there is no longer a pending request.
    // This cannot model multiple in-flight requests
    pendingRequestParameters: undefined
  };
  state.detectedBounds = detectedBounds;
  return draft;
})).withHandling((0, _helpers.immerCase)(_action.serverFailedToReturnResolverData, (draft, {
  id
}) => {
  var _state$tree4;
  /** Only handle this if we are expecting a response */
  const state = draft[id].data;
  if (((_state$tree4 = state.tree) === null || _state$tree4 === void 0 ? void 0 : _state$tree4.pendingRequestParameters) !== undefined) {
    var _state$tree5;
    state.tree = {
      ...state.tree,
      pendingRequestParameters: undefined,
      lastResponse: {
        parameters: (_state$tree5 = state.tree) === null || _state$tree5 === void 0 ? void 0 : _state$tree5.pendingRequestParameters,
        successful: false
      }
    };
  }
  return draft;
})).withHandling((0, _helpers.immerCase)(_action.serverReturnedNodeEventsInCategory, (draft, {
  id,
  events,
  cursor,
  nodeID,
  eventCategory,
  agentId
}) => {
  // The data in the action could be irrelevant if the panel view or parameters have changed since the corresponding request was made. In that case, ignore this action.
  const state = draft[id].data;
  if (nodeEventsInCategoryModel.isRelevantToPanelViewAndParameters({
    events,
    cursor,
    nodeID,
    eventCategory,
    agentId
  }, selectors.panelViewAndParameters(state))) {
    if (state.nodeEventsInCategory) {
      // If there are already `nodeEventsInCategory` in state then combine those with the new data in the payload.
      const updated = nodeEventsInCategoryModel.updatedWith(state.nodeEventsInCategory, {
        events,
        cursor,
        nodeID,
        eventCategory,
        agentId
      });
      // The 'updatedWith' method will fail if the old and new data don't represent events from the same node and event category
      if (updated) {
        state.nodeEventsInCategory = {
          ...updated
        };
      } else {
        // this should never happen. This reducer ensures that any `nodeEventsInCategory` that are in state: DataState are relevant to the `panelViewAndParameters`.
        throw new Error('Could not handle related event data because of an internal error.');
      }
    } else {
      // There is no existing data, use the new data.
      state.nodeEventsInCategory = {
        events,
        cursor,
        nodeID,
        eventCategory,
        agentId
      };
    }
    // else the action is stale, ignore it
  }
  return draft;
})).withHandling((0, _helpers.immerCase)(_action.userRequestedAdditionalRelatedEvents, (draft, {
  id
}) => {
  const state = draft[id].data;
  if (state.nodeEventsInCategory) {
    var _state$nodeEventsInCa;
    state.nodeEventsInCategory.lastCursorRequested = (_state$nodeEventsInCa = state.nodeEventsInCategory) === null || _state$nodeEventsInCa === void 0 ? void 0 : _state$nodeEventsInCa.cursor;
  }
  return draft;
})).withHandling((0, _helpers.immerCase)(_action.serverFailedToReturnNodeEventsInCategory, (draft, {
  id
}) => {
  const state = draft[id].data;
  if (state.nodeEventsInCategory) {
    state.nodeEventsInCategory = {
      ...state.nodeEventsInCategory,
      error: true
    };
  }
  return draft;
})).withHandling((0, _helpers.immerCase)(_action.serverReturnedNodeData, (draft, {
  id,
  nodeData,
  requestedIDs,
  numberOfRequestedEvents
}) => {
  const state = draft[id].data;
  const updatedNodeData = nodeDataModel.updateWithReceivedNodes({
    storedNodeInfo: state.nodeData,
    receivedEvents: nodeData,
    requestedNodes: requestedIDs,
    numberOfRequestedEvents
  });
  state.nodeData = updatedNodeData;
  return draft;
})).withHandling((0, _helpers.immerCase)(_action.userReloadedResolverNode, (draft, {
  id,
  nodeID
}) => {
  const state = draft[id].data;
  const updatedNodeData = nodeDataModel.setReloadedNodes(state.nodeData, nodeID);
  state.nodeData = updatedNodeData;
  return draft;
})).withHandling((0, _helpers.immerCase)(_action.appRequestingNodeData, (draft, {
  id,
  requestedIDs
}) => {
  const state = draft[id].data;
  const updatedNodeData = nodeDataModel.setRequestedNodes(state.nodeData, requestedIDs);
  state.nodeData = updatedNodeData;
  return draft;
})).withHandling((0, _helpers.immerCase)(_action.serverFailedToReturnNodeData, (draft, {
  id,
  requestedIDs
}) => {
  const state = draft[id].data;
  const updatedData = nodeDataModel.setErrorNodes(state.nodeData, requestedIDs);
  state.nodeData = updatedData;
  return draft;
})).withHandling((0, _helpers.immerCase)(_action.appRequestedCurrentRelatedEventData, (draft, {
  id
}) => {
  draft[id].data.currentRelatedEvent = {
    loading: true,
    data: null
  };
  return draft;
})).withHandling((0, _helpers.immerCase)(_action.userOverrodeDateRange, (draft, {
  id,
  timeRange: {
    from,
    to
  }
}) => {
  if (from && to) {
    var _state$tree6;
    const state = draft[id].data;
    if (((_state$tree6 = state.tree) === null || _state$tree6 === void 0 ? void 0 : _state$tree6.currentParameters) !== undefined) {
      state.tree = {
        ...state.tree,
        currentParameters: {
          ...state.tree.currentParameters,
          filters: {
            from,
            to
          }
        }
      };
    }
    const normalizedTimeRange = (0, _normalize_time_range.normalizeTimeRange)({
      from,
      to
    });
    draft[id].data.overriddenTimeBounds = normalizedTimeRange;
  }
  return draft;
})).withHandling((0, _helpers.immerCase)(_action.serverReturnedCurrentRelatedEventData, (draft, {
  id,
  relatedEvent
}) => {
  draft[id].data.currentRelatedEvent = {
    loading: false,
    data: {
      ...relatedEvent
    }
  };
  return draft;
})).withHandling((0, _helpers.immerCase)(_action.serverFailedToReturnCurrentRelatedEventData, (draft, {
  id
}) => {
  draft[id].data.currentRelatedEvent = {
    loading: false,
    data: null
  };
  return draft;
})).build();