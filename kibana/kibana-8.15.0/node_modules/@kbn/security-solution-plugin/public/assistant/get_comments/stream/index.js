"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.StreamComment = void 0;
var _react = _interopRequireWildcard(require("react"));
var _eui = require("@elastic/eui");
var _use_stream = require("./use_stream");
var _stop_generating_button = require("./buttons/stop_generating_button");
var _regenerate_response_button = require("./buttons/regenerate_response_button");
var _message_panel = require("./message_panel");
var _message_text = require("./message_text");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0; you may not use this file except in compliance with the Elastic License
 * 2.0.
 */

const StreamComment = ({
  abortStream,
  content,
  index,
  isControlsEnabled = false,
  isError = false,
  isFetching = false,
  reader,
  refetchCurrentConversation,
  regenerateMessage,
  setIsStreaming,
  transformMessage
}) => {
  const {
    error,
    isLoading,
    isStreaming,
    pendingMessage,
    setComplete
  } = (0, _use_stream.useStream)({
    refetchCurrentConversation,
    content,
    reader,
    isError
  });
  (0, _react.useEffect)(() => {
    setIsStreaming(isStreaming);
  }, [isStreaming, setIsStreaming]);
  const stopStream = (0, _react.useCallback)(() => {
    setComplete({
      complete: true,
      didAbort: true
    });
    abortStream();
  }, [abortStream, setComplete]);
  const currentState = (0, _react.useRef)({
    isStreaming,
    stopStream
  });
  (0, _react.useEffect)(() => {
    currentState.current = {
      isStreaming,
      stopStream
    };
  }, [stopStream, isStreaming]);
  (0, _react.useEffect)(() => () => {
    // if the component is unmounted while streaming, stop the stream
    if (currentState.current.isStreaming) {
      currentState.current.stopStream();
    }
  },
  // store values in currentState to detect true unmount
  []);
  const message = (0, _react.useMemo)(
  // only transform streaming message, transform happens upstream for content message
  () => content !== null && content !== void 0 ? content : transformMessage(pendingMessage).content, [content, transformMessage, pendingMessage]);
  const isAnythingLoading = (0, _react.useMemo)(() => isFetching || isLoading || isStreaming, [isFetching, isLoading, isStreaming]);
  const controls = (0, _react.useMemo)(() => {
    if (!isControlsEnabled) {
      return;
    }
    if (isAnythingLoading && reader) {
      return /*#__PURE__*/_react.default.createElement(_stop_generating_button.StopGeneratingButton, {
        onClick: stopStream
      });
    }
    return /*#__PURE__*/_react.default.createElement(_eui.EuiFlexGroup, {
      direction: "row",
      justifyContent: "flexEnd"
    }, /*#__PURE__*/_react.default.createElement(_eui.EuiFlexItem, {
      grow: false
    }, /*#__PURE__*/_react.default.createElement(_regenerate_response_button.RegenerateResponseButton, {
      onClick: regenerateMessage
    })));
  }, [isAnythingLoading, isControlsEnabled, reader, regenerateMessage, stopStream]);
  return /*#__PURE__*/_react.default.createElement(_message_panel.MessagePanel, {
    body: /*#__PURE__*/_react.default.createElement(_message_text.MessageText, {
      content: message,
      index: index,
      loading: isAnythingLoading
    }),
    error: error ? new Error(error) : undefined,
    controls: controls
  });
};
exports.StreamComment = StreamComment;