"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseAlertsGroupingData = exports.getIsAlertsProgressBarData = exports.getIsAlertsByGroupingAgg = exports.getGroupByLabel = exports.getAggregateData = exports.formatPercentage = void 0;
var _lodash = require("lodash");
var i18n = _interopRequireWildcard(require("./translations"));
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0; you may not use this file except in compliance with the Elastic License
 * 2.0.
 */

const formatPercentage = percent => {
  return percent > 0 && percent < 0.01 ? '<1%' : `${(Math.round(percent * 1000) / 10).toString()}%`;
};
exports.formatPercentage = formatPercentage;
const parseAlertsGroupingData = response => {
  var _response$aggregation, _response$aggregation2, _response$aggregation3, _response$aggregation4, _response$aggregation5, _response$aggregation6, _response$aggregation7, _response$aggregation8, _response$aggregation9;
  const buckets = (_response$aggregation = response === null || response === void 0 ? void 0 : (_response$aggregation2 = response.aggregations) === null || _response$aggregation2 === void 0 ? void 0 : (_response$aggregation3 = _response$aggregation2.alertsByGrouping) === null || _response$aggregation3 === void 0 ? void 0 : _response$aggregation3.buckets) !== null && _response$aggregation !== void 0 ? _response$aggregation : [];
  const emptyFieldCount = (_response$aggregation4 = response === null || response === void 0 ? void 0 : (_response$aggregation5 = response.aggregations) === null || _response$aggregation5 === void 0 ? void 0 : (_response$aggregation6 = _response$aggregation5.missingFields) === null || _response$aggregation6 === void 0 ? void 0 : _response$aggregation6.doc_count) !== null && _response$aggregation4 !== void 0 ? _response$aggregation4 : 0;
  if (buckets.length === 0 && emptyFieldCount === 0) {
    return [];
  }
  const other = (_response$aggregation7 = response === null || response === void 0 ? void 0 : (_response$aggregation8 = response.aggregations) === null || _response$aggregation8 === void 0 ? void 0 : (_response$aggregation9 = _response$aggregation8.alertsByGrouping) === null || _response$aggregation9 === void 0 ? void 0 : _response$aggregation9.sum_other_doc_count) !== null && _response$aggregation7 !== void 0 ? _response$aggregation7 : 0;
  const total = buckets.reduce((acc, group) => acc + group.doc_count, 0) + other + emptyFieldCount;
  const topAlerts = buckets.map(group => {
    return {
      key: group.key,
      value: group.doc_count,
      percentage: group.doc_count / total,
      percentageLabel: formatPercentage(group.doc_count / total),
      label: group.key
    };
  });
  if (other > 0) {
    topAlerts.push({
      key: 'Other',
      value: other,
      percentage: other / total,
      percentageLabel: formatPercentage(other / total),
      label: i18n.OTHER
    });
  }
  if (emptyFieldCount > 0) {
    topAlerts.push({
      key: '-',
      value: emptyFieldCount,
      percentage: emptyFieldCount / total,
      percentageLabel: formatPercentage(emptyFieldCount / total),
      label: '-'
    });
  }
  return topAlerts;
};
exports.parseAlertsGroupingData = parseAlertsGroupingData;
const getAggregateData = topAlerts => {
  const {
    total,
    nonEmpty
  } = topAlerts.reduce((ret, cur) => {
    ret.total += cur.value;
    if (cur.key !== '-') {
      ret.nonEmpty += cur.value;
    }
    return ret;
  }, {
    total: 0,
    nonEmpty: 0
  });
  return [nonEmpty, formatPercentage(total === 0 ? 0 : nonEmpty / total)];
};
exports.getAggregateData = getAggregateData;
const getIsAlertsProgressBarData = data => {
  return data === null || data === void 0 ? void 0 : data.every(x => (0, _lodash.has)(x, 'percentage'));
};
exports.getIsAlertsProgressBarData = getIsAlertsProgressBarData;
const getIsAlertsByGroupingAgg = data => {
  return (0, _lodash.has)(data, 'aggregations.alertsByGrouping');
};
exports.getIsAlertsByGroupingAgg = getIsAlertsByGroupingAgg;
const labels = {
  'host.name': i18n.HOST_NAME_LABEL,
  'user.name': i18n.USER_NAME_LABEL,
  'source.ip': i18n.SOURCE_LABEL,
  'destination.ip': i18n.DESTINATION_LABEL
};
const getGroupByLabel = option => {
  return labels[option];
};
exports.getGroupByLabel = getGroupByLabel;