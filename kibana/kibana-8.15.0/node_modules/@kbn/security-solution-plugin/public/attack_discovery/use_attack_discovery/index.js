"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useAttackDiscovery = void 0;
var _elasticAssistant = require("@kbn/elastic-assistant");
var _elasticAssistantCommon = require("@kbn/elastic-assistant-common");
var _react = _interopRequireWildcard(require("react"));
var _use_fetch_anonymization_fields = require("@kbn/elastic-assistant/impl/assistant/api/anonymization_fields/use_fetch_anonymization_fields");
var _use_poll_api = require("../hooks/use_poll_api");
var _kibana = require("../../common/lib/kibana");
var _helpers = require("../pages/helpers");
var _translations = require("../pages/translations");
var _helpers2 = require("./helpers");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0; you may not use this file except in compliance with the Elastic License
 * 2.0.
 */

const useAttackDiscovery = ({
  connectorId,
  setLoadingConnectorId
}) => {
  // get Kibana services and connectors
  const {
    http,
    notifications: {
      toasts
    }
  } = (0, _kibana.useKibana)().services;
  const {
    data: aiConnectors
  } = (0, _elasticAssistant.useLoadConnectors)({
    http
  });

  // generation can take a long time, so we calculate an approximate future time:
  const [approximateFutureTime, setApproximateFutureTime] = (0, _react.useState)(null);
  // whether post request is loading (dont show actions)
  const [isLoadingPost, setIsLoadingPost] = (0, _react.useState)(false);
  const {
    cancelAttackDiscovery,
    data: pollData,
    pollApi,
    status: pollStatus,
    setStatus: setPollStatus,
    didInitialFetch,
    stats
  } = (0, _use_poll_api.usePollApi)({
    http,
    setApproximateFutureTime,
    toasts,
    connectorId
  });

  // loading boilerplate:
  const [isLoading, setIsLoading] = (0, _react.useState)(false);

  // get alerts index pattern and allow lists from the assistant context:
  const {
    alertsIndexPattern,
    knowledgeBase,
    traceOptions
  } = (0, _elasticAssistant.useAssistantContext)();
  const {
    data: anonymizationFields
  } = (0, _use_fetch_anonymization_fields.useFetchAnonymizationFields)();
  const [generationIntervals, setGenerationIntervals] = _react.default.useState([]);
  const [attackDiscoveries, setAttackDiscoveries] = (0, _react.useState)([]);
  const [replacements, setReplacements] = (0, _react.useState)({});
  const [lastUpdated, setLastUpdated] = (0, _react.useState)(null);
  const [failureReason, setFailureReason] = (0, _react.useState)(null);

  // number of alerts sent as context to the LLM:
  const [alertsContextCount, setAlertsContextCount] = (0, _react.useState)(null);
  const requestBody = (0, _react.useMemo)(() => {
    const selectedConnector = aiConnectors === null || aiConnectors === void 0 ? void 0 : aiConnectors.find(connector => connector.id === connectorId);
    const genAiConfig = (0, _helpers2.getGenAiConfig)(selectedConnector);
    return (0, _helpers2.getRequestBody)({
      alertsIndexPattern,
      anonymizationFields,
      genAiConfig,
      knowledgeBase,
      selectedConnector,
      traceOptions
    });
  }, [aiConnectors, alertsIndexPattern, anonymizationFields, connectorId, knowledgeBase, traceOptions]);
  (0, _react.useEffect)(() => {
    if (connectorId != null && connectorId !== '') {
      pollApi();
      setLoadingConnectorId === null || setLoadingConnectorId === void 0 ? void 0 : setLoadingConnectorId(connectorId);
      setAlertsContextCount(null);
      setFailureReason(null);
      setLastUpdated(null);
      setReplacements({});
      setAttackDiscoveries([]);
      setGenerationIntervals([]);
      setPollStatus(null);
    }
  }, [pollApi, connectorId, setLoadingConnectorId, setPollStatus]);
  (0, _react.useEffect)(() => {
    if (pollStatus === 'running') {
      setIsLoading(true);
      setLoadingConnectorId === null || setLoadingConnectorId === void 0 ? void 0 : setLoadingConnectorId(connectorId !== null && connectorId !== void 0 ? connectorId : null);
    } else {
      setIsLoading(false);
      setLoadingConnectorId === null || setLoadingConnectorId === void 0 ? void 0 : setLoadingConnectorId(null);
    }
  }, [pollStatus, connectorId, setLoadingConnectorId]);
  (0, _react.useEffect)(() => {
    if (pollData !== null && pollData.connectorId === connectorId) {
      if (pollData.alertsContextCount != null) setAlertsContextCount(pollData.alertsContextCount);
      if (pollData.attackDiscoveries.length) {
        // get last updated from timestamp, not from updatedAt since this can indicate the last time the status was updated
        setLastUpdated(new Date(pollData.attackDiscoveries[0].timestamp));
      }
      if (pollData.replacements) setReplacements(pollData.replacements);
      if (pollData.status === 'failed' && pollData.failureReason) {
        setFailureReason(pollData.failureReason);
      } else {
        setFailureReason(null);
      }
      setAttackDiscoveries(pollData.attackDiscoveries);
      setGenerationIntervals(pollData.generationIntervals);
    }
  }, [connectorId, pollData]);

  /** The callback when users click the Generate button */
  const fetchAttackDiscoveries = (0, _react.useCallback)(async () => {
    try {
      if (requestBody.apiConfig.connectorId === '' || requestBody.apiConfig.actionTypeId === '') {
        throw new Error(_translations.CONNECTOR_ERROR);
      }
      setLoadingConnectorId === null || setLoadingConnectorId === void 0 ? void 0 : setLoadingConnectorId(connectorId !== null && connectorId !== void 0 ? connectorId : null);
      // sets isLoading to true
      setPollStatus('running');
      setIsLoadingPost(true);
      setApproximateFutureTime(null);
      // call the internal API to generate attack discoveries:
      const rawResponse = await http.fetch('/internal/elastic_assistant/attack_discovery', {
        body: JSON.stringify(requestBody),
        method: 'POST',
        version: _elasticAssistantCommon.ELASTIC_AI_ASSISTANT_INTERNAL_API_VERSION
      });
      setIsLoadingPost(false);
      const parsedResponse = _elasticAssistantCommon.AttackDiscoveryPostResponse.safeParse(rawResponse);
      if (!parsedResponse.success) {
        throw new Error('Failed to parse the response');
      }
    } catch (error) {
      setIsLoadingPost(false);
      setIsLoading(false);
      toasts === null || toasts === void 0 ? void 0 : toasts.addDanger(error, {
        title: _translations.ERROR_GENERATING_ATTACK_DISCOVERIES,
        text: (0, _helpers.getErrorToastText)(error)
      });
    }
  }, [connectorId, http, requestBody, setLoadingConnectorId, setPollStatus, toasts]);
  return {
    alertsContextCount,
    approximateFutureTime,
    attackDiscoveries,
    didInitialFetch,
    failureReason,
    fetchAttackDiscoveries,
    generationIntervals,
    isLoading,
    isLoadingPost,
    lastUpdated,
    onCancel: cancelAttackDiscovery,
    replacements,
    stats
  };
};
exports.useAttackDiscovery = useAttackDiscovery;