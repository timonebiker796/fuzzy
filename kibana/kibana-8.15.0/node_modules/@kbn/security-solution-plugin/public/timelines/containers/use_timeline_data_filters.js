"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useTimelineDataFilters = useTimelineDataFilters;
var _react = require("react");
var _reactRedux = require("react-redux");
var _reactRouterDom = require("react-router-dom");
var _use_selector = require("../../common/hooks/use_selector");
var _selectors = require("../../common/components/super_date_picker/selectors");
var _use_experimental_features = require("../../common/hooks/use_experimental_features");
var _model = require("../../sourcerer/store/model");
var _containers = require("../../sourcerer/containers");
var _sourcerer_paths = require("../../sourcerer/containers/sourcerer_paths");
var _store = require("../../common/store");
/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0; you may not use this file except in compliance with the Elastic License
 * 2.0.
 */

function useTimelineDataFilters(isActiveTimelines) {
  const getStartSelector = (0, _react.useMemo)(() => (0, _selectors.startSelector)(), []);
  const getEndSelector = (0, _react.useMemo)(() => (0, _selectors.endSelector)(), []);
  const getIsLoadingSelector = (0, _react.useMemo)(() => (0, _selectors.isLoadingSelector)(), []);
  const isDatePickerAndSourcererDisabled = (0, _use_experimental_features.useIsExperimentalFeatureEnabled)('analyzerDatePickersAndSourcererDisabled');
  const shouldUpdate = (0, _use_selector.useDeepEqualSelector)(state => {
    if (isActiveTimelines) {
      return getIsLoadingSelector(state.inputs.timeline);
    } else {
      return getIsLoadingSelector(state.inputs.global);
    }
  });
  const from = (0, _use_selector.useDeepEqualSelector)(state => {
    if (isActiveTimelines) {
      return getStartSelector(state.inputs.timeline);
    } else {
      return getStartSelector(state.inputs.global);
    }
  });
  const to = (0, _use_selector.useDeepEqualSelector)(state => {
    if (isActiveTimelines) {
      return getEndSelector(state.inputs.timeline);
    } else {
      return getEndSelector(state.inputs.global);
    }
  });
  const defaultDataView = (0, _reactRedux.useSelector)(_store.sourcererSelectors.defaultDataView);
  const {
    pathname
  } = (0, _reactRouterDom.useLocation)();
  const {
    selectedPatterns: nonTimelinePatterns
  } = (0, _containers.useSourcererDataView)((0, _sourcerer_paths.getScopeFromPath)(pathname));
  const {
    selectedPatterns: timelinePatterns
  } = (0, _containers.useSourcererDataView)(_model.SourcererScopeName.timeline);
  const selectedPatterns = (0, _react.useMemo)(() => {
    return isActiveTimelines ? [...new Set([...timelinePatterns, ...defaultDataView.patternList])] : [...new Set([...nonTimelinePatterns, ...defaultDataView.patternList])];
  }, [isActiveTimelines, timelinePatterns, nonTimelinePatterns, defaultDataView.patternList]);
  const {
    selectedPatterns: analyzerPatterns
  } = (0, _containers.useSourcererDataView)(_model.SourcererScopeName.analyzer);
  return (0, _react.useMemo)(() => {
    return {
      selectedPatterns: isDatePickerAndSourcererDisabled ? selectedPatterns : analyzerPatterns,
      from,
      to,
      shouldUpdate
    };
  }, [selectedPatterns, from, to, shouldUpdate, isDatePickerAndSourcererDisabled, analyzerPatterns]);
}