"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.userSortedNotes = exports.userSelectedRowForDeletion = exports.userSelectedRow = exports.userSelectedPerPage = exports.userSelectedPage = exports.userSelectedBulkDelete = exports.userSearchedNotes = exports.userFilteredNotes = exports.userClosedDeleteModal = exports.selectSortedNotesByDocumentId = exports.selectNotesTableSort = exports.selectNotesTableSelectedIds = exports.selectNotesTableSearch = exports.selectNotesTablePendingDeleteIds = exports.selectNotesPagination = exports.selectNotesByDocumentId = exports.selectNoteIds = exports.selectNoteById = exports.selectFetchNotesStatus = exports.selectFetchNotesError = exports.selectFetchNotesByDocumentIdsStatus = exports.selectFetchNotesByDocumentIdsError = exports.selectDeleteNotesStatus = exports.selectDeleteNotesError = exports.selectCreateNoteStatus = exports.selectCreateNoteError = exports.selectAllNotes = exports.notesReducer = exports.initialNotesState = exports.fetchNotesByDocumentIds = exports.fetchNotes = exports.deleteNotes = exports.createNote = exports.ReqStatus = void 0;
var _toolkit = require("@reduxjs/toolkit");
var _reselect = require("reselect");
var _api = require("../api/api");
var _normalize = require("./normalize");
/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0; you may not use this file except in compliance with the Elastic License
 * 2.0.
 */
let ReqStatus = exports.ReqStatus = /*#__PURE__*/function (ReqStatus) {
  ReqStatus["Idle"] = "idle";
  ReqStatus["Loading"] = "loading";
  ReqStatus["Succeeded"] = "succeeded";
  ReqStatus["Failed"] = "failed";
  return ReqStatus;
}({});
const notesAdapter = (0, _toolkit.createEntityAdapter)({
  selectId: note => note.noteId
});
const initialNotesState = exports.initialNotesState = notesAdapter.getInitialState({
  status: {
    fetchNotesByDocumentIds: ReqStatus.Idle,
    createNote: ReqStatus.Idle,
    deleteNotes: ReqStatus.Idle,
    fetchNotes: ReqStatus.Idle
  },
  error: {
    fetchNotesByDocumentIds: null,
    createNote: null,
    deleteNotes: null,
    fetchNotes: null
  },
  pagination: {
    page: 1,
    perPage: 10,
    total: 0
  },
  sort: {
    field: 'created',
    direction: 'desc'
  },
  filter: '',
  search: '',
  selectedIds: [],
  pendingDeleteIds: []
});
const fetchNotesByDocumentIds = exports.fetchNotesByDocumentIds = (0, _toolkit.createAsyncThunk)('notes/fetchNotesByDocumentIds', async args => {
  const {
    documentIds
  } = args;
  const res = await (0, _api.fetchNotesByDocumentIds)(documentIds);
  return (0, _normalize.normalizeEntities)(res.notes);
});
const fetchNotes = exports.fetchNotes = (0, _toolkit.createAsyncThunk)('notes/fetchNotes', async args => {
  const {
    page,
    perPage,
    sortField,
    sortOrder,
    filter,
    search
  } = args;
  const res = await (0, _api.fetchNotes)({
    page,
    perPage,
    sortField,
    sortOrder,
    filter,
    search
  });
  return {
    ...(0, _normalize.normalizeEntities)(res.notes),
    totalCount: res.totalCount
  };
});
const createNote = exports.createNote = (0, _toolkit.createAsyncThunk)('notes/createNote', async args => {
  const {
    note
  } = args;
  const res = await (0, _api.createNote)({
    note
  });
  return (0, _normalize.normalizeEntity)(res);
});
const deleteNotes = exports.deleteNotes = (0, _toolkit.createAsyncThunk)('notes/deleteNotes', async (args, {
  dispatch,
  getState
}) => {
  const {
    ids,
    refetch
  } = args;
  await (0, _api.deleteNotes)(ids);
  if (refetch) {
    const state = getState();
    const {
      search,
      pagination,
      sort
    } = state.notes;
    dispatch(fetchNotes({
      page: pagination.page,
      perPage: pagination.perPage,
      sortField: sort.field,
      sortOrder: sort.direction,
      filter: '',
      search
    }));
  }
  return ids;
});
const notesSlice = (0, _toolkit.createSlice)({
  name: 'notes',
  initialState: initialNotesState,
  reducers: {
    userSelectedPage: (state, action) => {
      state.pagination.page = action.payload;
    },
    userSelectedPerPage: (state, action) => {
      state.pagination.perPage = action.payload;
    },
    userSortedNotes: (state, action) => {
      state.sort = action.payload;
    },
    userFilteredNotes: (state, action) => {
      state.filter = action.payload;
    },
    userSearchedNotes: (state, action) => {
      state.search = action.payload;
    },
    userSelectedRow: (state, action) => {
      state.selectedIds = action.payload;
    },
    userClosedDeleteModal: state => {
      state.pendingDeleteIds = [];
    },
    userSelectedRowForDeletion: (state, action) => {
      state.pendingDeleteIds = [action.payload];
    },
    userSelectedBulkDelete: state => {
      state.pendingDeleteIds = state.selectedIds;
    }
  },
  extraReducers(builder) {
    builder.addCase(fetchNotesByDocumentIds.pending, state => {
      state.status.fetchNotesByDocumentIds = ReqStatus.Loading;
    }).addCase(fetchNotesByDocumentIds.fulfilled, (state, action) => {
      notesAdapter.upsertMany(state, action.payload.entities.notes);
      state.status.fetchNotesByDocumentIds = ReqStatus.Succeeded;
    }).addCase(fetchNotesByDocumentIds.rejected, (state, action) => {
      var _action$payload;
      state.status.fetchNotesByDocumentIds = ReqStatus.Failed;
      state.error.fetchNotesByDocumentIds = (_action$payload = action.payload) !== null && _action$payload !== void 0 ? _action$payload : action.error;
    }).addCase(createNote.pending, state => {
      state.status.createNote = ReqStatus.Loading;
    }).addCase(createNote.fulfilled, (state, action) => {
      notesAdapter.addMany(state, action.payload.entities.notes);
      state.status.createNote = ReqStatus.Succeeded;
    }).addCase(createNote.rejected, (state, action) => {
      var _action$payload2;
      state.status.createNote = ReqStatus.Failed;
      state.error.createNote = (_action$payload2 = action.payload) !== null && _action$payload2 !== void 0 ? _action$payload2 : action.error;
    }).addCase(deleteNotes.pending, state => {
      state.status.deleteNotes = ReqStatus.Loading;
    }).addCase(deleteNotes.fulfilled, (state, action) => {
      notesAdapter.removeMany(state, action.payload);
      state.status.deleteNotes = ReqStatus.Succeeded;
      state.pendingDeleteIds = state.pendingDeleteIds.filter(value => !action.payload.includes(value));
    }).addCase(deleteNotes.rejected, (state, action) => {
      var _action$payload3;
      state.status.deleteNotes = ReqStatus.Failed;
      state.error.deleteNotes = (_action$payload3 = action.payload) !== null && _action$payload3 !== void 0 ? _action$payload3 : action.error;
    }).addCase(fetchNotes.pending, state => {
      state.status.fetchNotes = ReqStatus.Loading;
    }).addCase(fetchNotes.fulfilled, (state, action) => {
      notesAdapter.setAll(state, action.payload.entities.notes);
      state.pagination.total = action.payload.totalCount;
      state.status.fetchNotes = ReqStatus.Succeeded;
      state.selectedIds = [];
    }).addCase(fetchNotes.rejected, (state, action) => {
      var _action$payload4;
      state.status.fetchNotes = ReqStatus.Failed;
      state.error.fetchNotes = (_action$payload4 = action.payload) !== null && _action$payload4 !== void 0 ? _action$payload4 : action.error;
    });
  }
});
const notesReducer = exports.notesReducer = notesSlice.reducer;
const {
  selectAll: selectAllNotes,
  selectById: selectNoteById,
  selectIds: selectNoteIds
} = notesAdapter.getSelectors(state => state.notes);
exports.selectNoteIds = selectNoteIds;
exports.selectNoteById = selectNoteById;
exports.selectAllNotes = selectAllNotes;
const selectFetchNotesByDocumentIdsStatus = state => state.notes.status.fetchNotesByDocumentIds;
exports.selectFetchNotesByDocumentIdsStatus = selectFetchNotesByDocumentIdsStatus;
const selectFetchNotesByDocumentIdsError = state => state.notes.error.fetchNotesByDocumentIds;
exports.selectFetchNotesByDocumentIdsError = selectFetchNotesByDocumentIdsError;
const selectCreateNoteStatus = state => state.notes.status.createNote;
exports.selectCreateNoteStatus = selectCreateNoteStatus;
const selectCreateNoteError = state => state.notes.error.createNote;
exports.selectCreateNoteError = selectCreateNoteError;
const selectDeleteNotesStatus = state => state.notes.status.deleteNotes;
exports.selectDeleteNotesStatus = selectDeleteNotesStatus;
const selectDeleteNotesError = state => state.notes.error.deleteNotes;
exports.selectDeleteNotesError = selectDeleteNotesError;
const selectNotesPagination = state => state.notes.pagination;
exports.selectNotesPagination = selectNotesPagination;
const selectNotesTableSort = state => state.notes.sort;
exports.selectNotesTableSort = selectNotesTableSort;
const selectNotesTableSelectedIds = state => state.notes.selectedIds;
exports.selectNotesTableSelectedIds = selectNotesTableSelectedIds;
const selectNotesTableSearch = state => state.notes.search;
exports.selectNotesTableSearch = selectNotesTableSearch;
const selectNotesTablePendingDeleteIds = state => state.notes.pendingDeleteIds;
exports.selectNotesTablePendingDeleteIds = selectNotesTablePendingDeleteIds;
const selectFetchNotesError = state => state.notes.error.fetchNotes;
exports.selectFetchNotesError = selectFetchNotesError;
const selectFetchNotesStatus = state => state.notes.status.fetchNotes;
exports.selectFetchNotesStatus = selectFetchNotesStatus;
const selectNotesByDocumentId = exports.selectNotesByDocumentId = (0, _reselect.createSelector)([selectAllNotes, (state, documentId) => documentId], (notes, documentId) => notes.filter(note => note.eventId === documentId));
const selectSortedNotesByDocumentId = exports.selectSortedNotesByDocumentId = (0, _reselect.createSelector)([selectAllNotes, (state, {
  documentId,
  sort
}) => ({
  documentId,
  sort
})], (notes, {
  documentId,
  sort
}) => {
  const {
    field,
    direction
  } = sort;
  return notes.filter(note => note.eventId === documentId).sort((first, second) => {
    const a = first[field];
    const b = second[field];
    if (a == null) return 1;
    if (b == null) return -1;
    return direction === 'asc' ? a > b ? 1 : -1 : a > b ? -1 : 1;
  });
});
const {
  userSelectedPage,
  userSelectedPerPage,
  userSortedNotes,
  userFilteredNotes,
  userSearchedNotes,
  userSelectedRow,
  userClosedDeleteModal,
  userSelectedRowForDeletion,
  userSelectedBulkDelete
} = notesSlice.actions;
exports.userSelectedBulkDelete = userSelectedBulkDelete;
exports.userSelectedRowForDeletion = userSelectedRowForDeletion;
exports.userClosedDeleteModal = userClosedDeleteModal;
exports.userSelectedRow = userSelectedRow;
exports.userSearchedNotes = userSearchedNotes;
exports.userFilteredNotes = userFilteredNotes;
exports.userSortedNotes = userSortedNotes;
exports.userSelectedPerPage = userSelectedPerPage;
exports.userSelectedPage = userSelectedPage;