"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MARKDOWN_ARIA_LABEL = exports.CREATE_NOTE_ERROR = exports.AddNote = exports.ATTACH_TO_TIMELINE_INFO = exports.ATTACH_TO_TIMELINE_CHECKBOX = exports.ADD_NOTE_BUTTON = void 0;
var _react = _interopRequireWildcard(require("react"));
var _eui = require("@elastic/eui");
var _react2 = require("@emotion/react");
var _reactRedux = require("react-redux");
var _i18n = require("@kbn/i18n");
var _use_which_flyout = require("../../shared/hooks/use_which_flyout");
var _flyouts = require("../../shared/constants/flyouts");
var _kibana = require("../../../../common/lib/kibana");
var _types = require("../../../../../common/types");
var _store = require("../../../../timelines/store");
var _test_ids = require("./test_ids");
var _use_app_toasts = require("../../../../common/hooks/use_app_toasts");
var _notes = require("../../../../notes/store/notes.slice");
var _markdown_editor = require("../../../../common/components/markdown_editor");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0; you may not use this file except in compliance with the Elastic License
 * 2.0.
 */

const timelineCheckBoxId = 'xpack.securitySolution.notes.attachToTimelineCheckboxId';
const MARKDOWN_ARIA_LABEL = exports.MARKDOWN_ARIA_LABEL = _i18n.i18n.translate('xpack.securitySolution.notes.markdownAriaLabel', {
  defaultMessage: 'Note'
});
const ADD_NOTE_BUTTON = exports.ADD_NOTE_BUTTON = _i18n.i18n.translate('xpack.securitySolution.notes.addNoteBtnLabel', {
  defaultMessage: 'Add note'
});
const CREATE_NOTE_ERROR = exports.CREATE_NOTE_ERROR = _i18n.i18n.translate('xpack.securitySolution.notes.createNoteErrorLabel', {
  defaultMessage: 'Error create note'
});
const ATTACH_TO_TIMELINE_CHECKBOX = exports.ATTACH_TO_TIMELINE_CHECKBOX = _i18n.i18n.translate('xpack.securitySolution.notes.attachToTimelineCheckboxLabel', {
  defaultMessage: 'Attach to active timeline'
});
const ATTACH_TO_TIMELINE_INFO = exports.ATTACH_TO_TIMELINE_INFO = _i18n.i18n.translate('xpack.securitySolution.notes.attachToTimelineInfoLabel', {
  defaultMessage: 'The active timeline must be saved before a note can be associated with it'
});
/**
 * Renders a markdown editor and an add button to create new notes.
 * The checkbox is automatically checked if the flyout is opened from a timeline and that timeline is saved. It is disabled if the flyout is NOT opened from a timeline.
 */
const AddNote = exports.AddNote = /*#__PURE__*/(0, _react.memo)(({
  eventId
}) => {
  const {
    telemetry
  } = (0, _kibana.useKibana)().services;
  const dispatch = (0, _reactRedux.useDispatch)();
  const {
    addError: addErrorToast
  } = (0, _use_app_toasts.useAppToasts)();
  const [editorValue, setEditorValue] = (0, _react.useState)('');
  const [isMarkdownInvalid, setIsMarkdownInvalid] = (0, _react.useState)(false);
  const activeTimeline = (0, _reactRedux.useSelector)(state => _store.timelineSelectors.selectTimelineById(state, _types.TimelineId.active));

  // if the flyout is open from a timeline and that timeline is saved, we automatically check the checkbox to associate the note to it
  const isTimelineFlyout = (0, _use_which_flyout.useWhichFlyout)() === _flyouts.Flyouts.timeline;
  const [checked, setChecked] = (0, _react.useState)(true);
  const onCheckboxChange = (0, _react.useCallback)(e => setChecked(e.target.checked), []);
  const createStatus = (0, _reactRedux.useSelector)(state => (0, _notes.selectCreateNoteStatus)(state));
  const createError = (0, _reactRedux.useSelector)(state => (0, _notes.selectCreateNoteError)(state));
  const addNote = (0, _react.useCallback)(() => {
    dispatch((0, _notes.createNote)({
      note: {
        timelineId: checked && (activeTimeline === null || activeTimeline === void 0 ? void 0 : activeTimeline.savedObjectId) || '',
        eventId,
        note: editorValue
      }
    }));
    telemetry.reportAddNoteFromExpandableFlyoutClicked({
      isRelatedToATimeline: checked && (activeTimeline === null || activeTimeline === void 0 ? void 0 : activeTimeline.savedObjectId) !== null
    });
    setEditorValue('');
  }, [activeTimeline === null || activeTimeline === void 0 ? void 0 : activeTimeline.savedObjectId, checked, dispatch, editorValue, eventId, telemetry]);

  // show a toast if the create note call fails
  (0, _react.useEffect)(() => {
    if (createStatus === _notes.ReqStatus.Failed && createError) {
      addErrorToast(null, {
        title: CREATE_NOTE_ERROR
      });
    }
  }, [addErrorToast, createError, createStatus]);
  const buttonDisabled = (0, _react.useMemo)(() => editorValue.trim().length === 0 || isMarkdownInvalid, [editorValue, isMarkdownInvalid]);
  const initialCheckboxChecked = (0, _react.useMemo)(() => isTimelineFlyout && activeTimeline.savedObjectId != null, [activeTimeline === null || activeTimeline === void 0 ? void 0 : activeTimeline.savedObjectId, isTimelineFlyout]);
  const checkBoxDisabled = (0, _react.useMemo)(() => !isTimelineFlyout || isTimelineFlyout && (activeTimeline === null || activeTimeline === void 0 ? void 0 : activeTimeline.savedObjectId) == null, [activeTimeline === null || activeTimeline === void 0 ? void 0 : activeTimeline.savedObjectId, isTimelineFlyout]);
  return /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, /*#__PURE__*/_react.default.createElement(_eui.EuiCommentList, null, /*#__PURE__*/_react.default.createElement(_eui.EuiComment, {
    username: ""
  }, /*#__PURE__*/_react.default.createElement(_markdown_editor.MarkdownEditor, {
    dataTestSubj: _test_ids.ADD_NOTE_MARKDOWN_TEST_ID,
    value: editorValue,
    onChange: setEditorValue,
    ariaLabel: MARKDOWN_ARIA_LABEL,
    setIsMarkdownInvalid: setIsMarkdownInvalid
  }))), /*#__PURE__*/_react.default.createElement(_eui.EuiSpacer, null), /*#__PURE__*/_react.default.createElement(_eui.EuiFlexGroup, {
    alignItems: "center",
    justifyContent: "flexEnd",
    responsive: false
  }, /*#__PURE__*/_react.default.createElement(_eui.EuiFlexItem, {
    grow: false
  }, /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, /*#__PURE__*/_react.default.createElement(_eui.EuiCheckbox, {
    "data-test-subj": _test_ids.ATTACH_TO_TIMELINE_CHECKBOX_TEST_ID,
    id: timelineCheckBoxId,
    label: /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, ATTACH_TO_TIMELINE_CHECKBOX, /*#__PURE__*/_react.default.createElement(_eui.EuiToolTip, {
      position: "top",
      content: ATTACH_TO_TIMELINE_INFO
    }, /*#__PURE__*/_react.default.createElement(_eui.EuiIcon, {
      type: "iInCircle",
      css: (0, _react2.css)`
                        margin-left: 4px;
                      `
    }))),
    disabled: checkBoxDisabled,
    checked: initialCheckboxChecked && checked,
    onChange: e => onCheckboxChange(e)
  }))), /*#__PURE__*/_react.default.createElement(_eui.EuiFlexItem, {
    grow: false
  }, /*#__PURE__*/_react.default.createElement(_eui.EuiButton, {
    onClick: addNote,
    isLoading: createStatus === _notes.ReqStatus.Loading,
    disabled: buttonDisabled,
    "data-test-subj": _test_ids.ADD_NOTE_BUTTON_TEST_ID
  }, ADD_NOTE_BUTTON))));
});
AddNote.displayName = 'AddNote';