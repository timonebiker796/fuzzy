"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CrowdstrikeActionsClient = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _constants = require("@kbn/stack-connectors-plugin/common/crowdstrike/constants");
var _stringify = require("../../../../utils/stringify");
var _errors = require("../errors");
var _base_response_actions_client = require("../lib/base_response_actions_client");
var _utils = require("../../utils");
/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0; you may not use this file except in compliance with the Elastic License
 * 2.0.
 */

class CrowdstrikeActionsClient extends _base_response_actions_client.ResponseActionsClientImpl {
  constructor({
    connectorActions,
    ...options
  }) {
    super(options);
    (0, _defineProperty2.default)(this, "agentType", 'crowdstrike');
    (0, _defineProperty2.default)(this, "connectorActionsClient", void 0);
    this.connectorActionsClient = connectorActions;
    connectorActions.setup(_constants.CROWDSTRIKE_CONNECTOR_ID);
  }
  async writeActionRequestToEndpointIndex(actionRequest) {
    var _actionRequest$meta;
    const agentId = actionRequest.endpoint_ids[0];
    const eventDetails = await this.getEventDetailsById(agentId);
    const hostname = eventDetails.host.name;
    return super.writeActionRequestToEndpointIndex({
      ...actionRequest,
      hosts: {
        [agentId]: {
          name: hostname
        }
      },
      meta: {
        hostName: hostname,
        ...((_actionRequest$meta = actionRequest.meta) !== null && _actionRequest$meta !== void 0 ? _actionRequest$meta : {})
      }
    });
  }

  /**
   * Sends actions to Crowdstrike directly (via Connector)
   * @private
   */
  async sendAction(actionType, actionParams) {
    const executeOptions = {
      params: {
        subAction: actionType,
        subActionParams: actionParams
      }
    };
    this.log.debug(`calling connector actions 'execute()' for Crowdstrike with:\n${(0, _stringify.stringify)(executeOptions)}`);
    const actionSendResponse = await this.connectorActionsClient.execute(executeOptions);
    if (actionSendResponse.status === 'error') {
      this.log.error((0, _stringify.stringify)(actionSendResponse));
      throw new _errors.ResponseActionsClientError(`Attempt to send [${actionType}] to Crowdstrike failed: ${actionSendResponse.serviceMessage || actionSendResponse.message}`, 500, actionSendResponse);
    } else {
      this.log.debug(`Response:\n${(0, _stringify.stringify)(actionSendResponse)}`);
    }
    return actionSendResponse;
  }
  async getEventDetailsById(agentId) {
    const search = {
      index: ['logs-crowdstrike.fdr*', 'logs-crowdstrike.falcon*'],
      size: 1,
      _source: ['host.name'],
      body: {
        query: {
          bool: {
            filter: [{
              term: {
                'device.id': agentId
              }
            }]
          }
        }
      }
    };
    try {
      var _result$hits$hits, _result$hits$hits$, _result$hits$hits$$_s, _result$hits$hits$$_s2;
      const result = await this.options.esClient.search(search, {
        ignore: [404]
      });

      // Check if host name exists
      const hostName = (_result$hits$hits = result.hits.hits) === null || _result$hits$hits === void 0 ? void 0 : (_result$hits$hits$ = _result$hits$hits[0]) === null || _result$hits$hits$ === void 0 ? void 0 : (_result$hits$hits$$_s = _result$hits$hits$._source) === null || _result$hits$hits$$_s === void 0 ? void 0 : (_result$hits$hits$$_s2 = _result$hits$hits$$_s.host) === null || _result$hits$hits$$_s2 === void 0 ? void 0 : _result$hits$hits$$_s2.name;
      if (!hostName) {
        throw new _errors.ResponseActionsClientError(`Host name not found in the event document for agentId: ${agentId}`, 404);
      }
      return result.hits.hits[0]._source;
    } catch (err) {
      var _err$statusCode;
      throw new _errors.ResponseActionsClientError(`Failed to fetch event document: ${err.message}`, (_err$statusCode = err.statusCode) !== null && _err$statusCode !== void 0 ? _err$statusCode : 500, err);
    }
  }
  async validateRequest(payload) {
    // TODO:PT support multiple agents
    if (payload.endpoint_ids.length > 1) {
      return {
        isValid: false,
        error: new _errors.ResponseActionsClientError(`[body.endpoint_ids]: Multiple agents IDs not currently supported for Crowdstrike`, 400)
      };
    }
    return super.validateRequest(payload);
  }
  async isolate(actionRequest, options = {}) {
    const reqIndexOptions = {
      ...actionRequest,
      ...this.getMethodOptions(options),
      command: 'isolate'
    };
    let actionResponse;
    if (!reqIndexOptions.error) {
      var _error;
      let error = (await this.validateRequest(reqIndexOptions)).error;
      const actionCommentMessage = (0, _utils.ELASTIC_RESPONSE_ACTION_MESSAGE)(this.options.username, reqIndexOptions.actionId);
      if (!error) {
        try {
          actionResponse = await this.sendAction(_constants.SUB_ACTION.HOST_ACTIONS, {
            ids: actionRequest.endpoint_ids,
            actionParameters: {
              comment: reqIndexOptions.comment ? `${actionCommentMessage}: ${reqIndexOptions.comment}` : actionCommentMessage
            },
            command: 'contain'
          });
        } catch (err) {
          error = err;
        }
      }
      reqIndexOptions.error = (_error = error) === null || _error === void 0 ? void 0 : _error.message;
      if (!this.options.isAutomated && error) {
        throw error;
      }
    }
    const actionRequestDoc = await this.writeActionRequestToEndpointIndex(reqIndexOptions);

    // Ensure actionResponse is assigned before using it
    if (actionResponse) {
      await this.completeCrowdstrikeAction(actionResponse, actionRequestDoc);
    }
    await this.updateCases({
      command: reqIndexOptions.command,
      caseIds: reqIndexOptions.case_ids,
      alertIds: reqIndexOptions.alert_ids,
      actionId: actionRequestDoc.EndpointActions.action_id,
      hosts: actionRequest.endpoint_ids.map(agentId => {
        var _actionRequestDoc$End, _actionRequestDoc$End2;
        return {
          hostId: agentId,
          hostname: (_actionRequestDoc$End = (_actionRequestDoc$End2 = actionRequestDoc.EndpointActions.data.hosts) === null || _actionRequestDoc$End2 === void 0 ? void 0 : _actionRequestDoc$End2[agentId].name) !== null && _actionRequestDoc$End !== void 0 ? _actionRequestDoc$End : ''
        };
      }),
      comment: reqIndexOptions.comment
    });
    return this.fetchActionDetails(actionRequestDoc.EndpointActions.action_id);
  }
  async release(actionRequest, options = {}) {
    const reqIndexOptions = {
      ...actionRequest,
      ...this.getMethodOptions(options),
      command: 'unisolate'
    };
    let actionResponse;
    if (!reqIndexOptions.error) {
      var _error2;
      let error = (await this.validateRequest(reqIndexOptions)).error;
      const actionCommentMessage = (0, _utils.ELASTIC_RESPONSE_ACTION_MESSAGE)(this.options.username, reqIndexOptions.actionId);
      if (!error) {
        try {
          actionResponse = await this.sendAction(_constants.SUB_ACTION.HOST_ACTIONS, {
            ids: actionRequest.endpoint_ids,
            command: 'lift_containment',
            comment: reqIndexOptions.comment ? `${actionCommentMessage}: ${reqIndexOptions.comment}` : actionCommentMessage
          });
        } catch (err) {
          error = err;
        }
      }
      reqIndexOptions.error = (_error2 = error) === null || _error2 === void 0 ? void 0 : _error2.message;
      if (!this.options.isAutomated && error) {
        throw error;
      }
    }
    const actionRequestDoc = await this.writeActionRequestToEndpointIndex(reqIndexOptions);

    // Ensure actionResponse is assigned before using it
    if (actionResponse) {
      await this.completeCrowdstrikeAction(actionResponse, actionRequestDoc);
    }
    await this.updateCases({
      command: reqIndexOptions.command,
      caseIds: reqIndexOptions.case_ids,
      alertIds: reqIndexOptions.alert_ids,
      actionId: actionRequestDoc.EndpointActions.action_id,
      hosts: actionRequest.endpoint_ids.map(agentId => {
        var _actionRequestDoc$End3, _actionRequestDoc$End4;
        return {
          hostId: agentId,
          hostname: (_actionRequestDoc$End3 = (_actionRequestDoc$End4 = actionRequestDoc.EndpointActions.data.hosts) === null || _actionRequestDoc$End4 === void 0 ? void 0 : _actionRequestDoc$End4[agentId].name) !== null && _actionRequestDoc$End3 !== void 0 ? _actionRequestDoc$End3 : ''
        };
      }),
      comment: reqIndexOptions.comment
    });
    return this.fetchActionDetails(actionRequestDoc.EndpointActions.action_id);
  }
  async completeCrowdstrikeAction(actionResponse, doc) {
    var _actionResponse$data, _actionResponse$data$;
    const options = {
      actionId: doc.EndpointActions.action_id,
      agentId: doc.agent.id,
      data: doc.EndpointActions.data,
      ...(actionResponse !== null && actionResponse !== void 0 && (_actionResponse$data = actionResponse.data) !== null && _actionResponse$data !== void 0 && (_actionResponse$data$ = _actionResponse$data.errors) !== null && _actionResponse$data$ !== void 0 && _actionResponse$data$.length ? {
        error: {
          code: '500',
          message: `Crowdstrike action failed: ${actionResponse.data.errors[0].message}`
        }
      } : {})
    };
    await this.writeActionResponseToEndpointIndex(options);
  }
  async processPendingActions({
    abortSignal,
    addToQueue
  }) {
    // TODO:PT implement resolving of pending crowdstrike actions
    // if (abortSignal.aborted) {
    //   return;
    // }
  }
}
exports.CrowdstrikeActionsClient = CrowdstrikeActionsClient;