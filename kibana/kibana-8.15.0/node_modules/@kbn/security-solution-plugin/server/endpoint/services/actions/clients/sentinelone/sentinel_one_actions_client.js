"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SentinelOneActionsClient = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _constants = require("@kbn/stack-connectors-plugin/common/sentinelone/constants");
var _lodash = require("lodash");
var _constants2 = require("../../constants");
var _common = require("../../../../../../common");
var _utils = require("../../../../utils");
var _stringify = require("../../../../utils/stringify");
var _errors = require("../errors");
var _base_response_actions_client = require("../lib/base_response_actions_client");
var _constants3 = require("../../../../../../common/endpoint/service/response_actions/constants");
/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0; you may not use this file except in compliance with the Elastic License
 * 2.0.
 */

class SentinelOneActionsClient extends _base_response_actions_client.ResponseActionsClientImpl {
  constructor({
    connectorActions,
    ...options
  }) {
    super(options);
    (0, _defineProperty2.default)(this, "agentType", 'sentinel_one');
    (0, _defineProperty2.default)(this, "connectorActionsClient", void 0);
    this.connectorActionsClient = connectorActions;
    connectorActions.setup(_constants.SENTINELONE_CONNECTOR_ID);
  }
  async handleResponseActionCreation(reqIndexOptions) {
    const actionRequestDoc = await this.writeActionRequestToEndpointIndex(reqIndexOptions);
    await this.updateCases({
      command: reqIndexOptions.command,
      caseIds: reqIndexOptions.case_ids,
      alertIds: reqIndexOptions.alert_ids,
      actionId: actionRequestDoc.EndpointActions.action_id,
      hosts: reqIndexOptions.endpoint_ids.map(agentId => {
        var _actionRequestDoc$End, _actionRequestDoc$End2;
        return {
          hostId: agentId,
          hostname: (_actionRequestDoc$End = (_actionRequestDoc$End2 = actionRequestDoc.EndpointActions.data.hosts) === null || _actionRequestDoc$End2 === void 0 ? void 0 : _actionRequestDoc$End2[agentId].name) !== null && _actionRequestDoc$End !== void 0 ? _actionRequestDoc$End : ''
        };
      }),
      comment: reqIndexOptions.comment
    });
    return {
      actionEsDoc: actionRequestDoc,
      actionDetails: await this.fetchActionDetails(actionRequestDoc.EndpointActions.action_id)
    };
  }
  async writeActionRequestToEndpointIndex(actionRequest) {
    var _actionRequest$meta;
    const agentUUID = actionRequest.endpoint_ids[0];
    const agentDetails = await this.getAgentDetails(agentUUID);
    const doc = await super.writeActionRequestToEndpointIndex({
      ...actionRequest,
      hosts: {
        [agentUUID]: {
          name: agentDetails.computerName
        }
      },
      meta: {
        // Add common meta data
        agentUUID,
        agentId: agentDetails.id,
        hostName: agentDetails.computerName,
        ...((_actionRequest$meta = actionRequest.meta) !== null && _actionRequest$meta !== void 0 ? _actionRequest$meta : {})
      }
    });
    return doc;
  }

  /**
   * Sends actions to SentinelOne directly (via Connector)
   * @private
   */
  async sendAction(actionType, actionParams) {
    const executeOptions = {
      params: {
        subAction: actionType,
        subActionParams: actionParams
      }
    };
    this.log.debug(`calling connector actions 'execute()' for SentinelOne with:\n${(0, _stringify.stringify)(executeOptions)}`);
    const actionSendResponse = await this.connectorActionsClient.execute(executeOptions);
    if (actionSendResponse.status === 'error') {
      this.log.error((0, _stringify.stringify)(actionSendResponse));
      throw new _errors.ResponseActionsClientError(`Attempt to send [${actionType}] to SentinelOne failed: ${actionSendResponse.serviceMessage || actionSendResponse.message}`, 500, actionSendResponse);
    }
    this.log.debug(`Response:\n${(0, _stringify.stringify)(actionSendResponse)}`);
    return actionSendResponse;
  }

  /** Gets agent details directly from SentinelOne */
  async getAgentDetails(agentUUID) {
    const executeOptions = {
      params: {
        subAction: _constants.SUB_ACTION.GET_AGENTS,
        subActionParams: {
          uuid: agentUUID
        }
      }
    };
    let s1ApiResponse;
    try {
      const response = await this.connectorActionsClient.execute(executeOptions);
      this.log.debug(`Response for SentinelOne agent id [${agentUUID}] returned:\n${(0, _stringify.stringify)(response)}`);
      s1ApiResponse = response.data;
    } catch (err) {
      throw new _errors.ResponseActionsClientError(`Error while attempting to retrieve SentinelOne host with agent id [${agentUUID}]: ${err.message}`, 500, err);
    }
    if (!s1ApiResponse || !s1ApiResponse.data[0]) {
      throw new _errors.ResponseActionsClientError(`SentinelOne agent id [${agentUUID}] not found`, 404);
    }
    return s1ApiResponse.data[0];
  }
  async validateRequest(payload) {
    // TODO:PT support multiple agents
    if (payload.endpoint_ids.length > 1) {
      return {
        isValid: false,
        error: new _errors.ResponseActionsClientError(`[body.endpoint_ids]: Multiple agents IDs not currently supported for SentinelOne`, 400)
      };
    }
    return super.validateRequest(payload);
  }
  async isolate(actionRequest, options = {}) {
    const reqIndexOptions = {
      ...actionRequest,
      ...this.getMethodOptions(options),
      command: 'isolate'
    };
    if (!reqIndexOptions.error) {
      var _error;
      let error = (await this.validateRequest(reqIndexOptions)).error;
      if (!error) {
        try {
          await this.sendAction(_constants.SUB_ACTION.ISOLATE_HOST, {
            uuid: actionRequest.endpoint_ids[0]
          });
        } catch (err) {
          error = err;
        }
      }
      reqIndexOptions.error = (_error = error) === null || _error === void 0 ? void 0 : _error.message;
      if (!this.options.isAutomated && error) {
        throw error;
      }
    }
    const {
      actionDetails,
      actionEsDoc: actionRequestDoc
    } = await this.handleResponseActionCreation(reqIndexOptions);
    if (!actionRequestDoc.error && !this.options.endpointService.experimentalFeatures.responseActionsSentinelOneV2Enabled) {
      await this.writeActionResponseToEndpointIndex({
        actionId: actionRequestDoc.EndpointActions.action_id,
        agentId: actionRequestDoc.agent.id,
        data: {
          command: actionRequestDoc.EndpointActions.data.command
        }
      });
      return this.fetchActionDetails(actionRequestDoc.EndpointActions.action_id);
    }
    return actionDetails;
  }
  async release(actionRequest, options = {}) {
    const reqIndexOptions = {
      ...actionRequest,
      ...this.getMethodOptions(options),
      command: 'unisolate'
    };
    if (!reqIndexOptions.error) {
      var _error2;
      let error = (await this.validateRequest(reqIndexOptions)).error;
      if (!error) {
        try {
          await this.sendAction(_constants.SUB_ACTION.RELEASE_HOST, {
            uuid: actionRequest.endpoint_ids[0]
          });
        } catch (err) {
          error = err;
        }
      }
      reqIndexOptions.error = (_error2 = error) === null || _error2 === void 0 ? void 0 : _error2.message;
      if (!this.options.isAutomated && error) {
        throw error;
      }
    }
    const {
      actionDetails,
      actionEsDoc: actionRequestDoc
    } = await this.handleResponseActionCreation(reqIndexOptions);
    if (!actionRequestDoc.error && !this.options.endpointService.experimentalFeatures.responseActionsSentinelOneV2Enabled) {
      await this.writeActionResponseToEndpointIndex({
        actionId: actionRequestDoc.EndpointActions.action_id,
        agentId: actionRequestDoc.agent.id,
        data: {
          command: actionRequestDoc.EndpointActions.data.command
        }
      });
      return this.fetchActionDetails(actionRequestDoc.EndpointActions.action_id);
    }
    return actionDetails;
  }
  async getFile(actionRequest, options) {
    if (!this.options.endpointService.experimentalFeatures.responseActionsSentinelOneGetFileEnabled) {
      throw new _errors.ResponseActionsClientError(`get-file not supported for ${this.agentType} agent type. Feature disabled`, 400);
    }
    const reqIndexOptions = {
      ...actionRequest,
      ...this.getMethodOptions(options),
      command: 'get-file'
    };
    if (!reqIndexOptions.error) {
      var _error3;
      let error = (await this.validateRequest(reqIndexOptions)).error;
      const timestamp = new Date().toISOString();
      if (!error) {
        try {
          await this.sendAction(_constants.SUB_ACTION.FETCH_AGENT_FILES, {
            agentUUID: actionRequest.endpoint_ids[0],
            files: [actionRequest.parameters.path],
            zipPassCode: _constants3.RESPONSE_ACTIONS_ZIP_PASSCODE.sentinel_one
          });
        } catch (err) {
          error = err;
        }
      }
      reqIndexOptions.error = (_error3 = error) === null || _error3 === void 0 ? void 0 : _error3.message;
      if (!this.options.isAutomated && error) {
        throw error;
      }
      if (!error) {
        var _activityLogSearchRes;
        const {
          id: agentId
        } = await this.getAgentDetails(actionRequest.endpoint_ids[0]);
        const activitySearchCriteria = {
          // Activity type for fetching a file from a host machine in SentinelOne:
          // {
          //   "id": 81
          //   "action": "User Requested Fetch Files",
          //   "descriptionTemplate": "The management user {{ username }} initiated a fetch file command to the agent {{ computer_name }} ({{ external_ip }}).",
          // },
          activityTypes: '81',
          limit: 1,
          sortBy: 'createdAt',
          sortOrder: 'asc',
          // eslint-disable-next-line @typescript-eslint/naming-convention
          createdAt__gte: timestamp,
          agentIds: agentId
        };

        // Fetch the Activity log entry for this get-file request and store needed data
        const activityLogSearchResponse = await this.sendAction(_constants.SUB_ACTION.GET_ACTIVITIES, activitySearchCriteria);
        this.log.debug(`Search of activity log with:\n${(0, _stringify.stringify)(activitySearchCriteria)}\n returned:\n${(0, _stringify.stringify)(activityLogSearchResponse.data)}`);
        if ((_activityLogSearchRes = activityLogSearchResponse.data) !== null && _activityLogSearchRes !== void 0 && _activityLogSearchRes.data.length) {
          var _activityLogSearchRes2;
          const activityLogItem = (_activityLogSearchRes2 = activityLogSearchResponse.data) === null || _activityLogSearchRes2 === void 0 ? void 0 : _activityLogSearchRes2.data[0];
          reqIndexOptions.meta = {
            commandBatchUuid: activityLogItem === null || activityLogItem === void 0 ? void 0 : activityLogItem.data.commandBatchUuid,
            activityId: activityLogItem === null || activityLogItem === void 0 ? void 0 : activityLogItem.id
          };
        } else {
          this.log.warn(`Unable to find a fetch file command entry in SentinelOne activity log. May be unable to complete response action`);
        }
      }
    }
    return (await this.handleResponseActionCreation(reqIndexOptions)).actionDetails;
  }
  async getFileInfo(actionId, agentId) {
    if (!this.options.endpointService.experimentalFeatures.responseActionsSentinelOneGetFileEnabled) {
      throw new _errors.ResponseActionsClientError(`File downloads are not supported for ${this.agentType} agent type. Feature disabled`, 400);
    }
    await this.ensureValidActionId(actionId);
    const fileInfo = {
      actionId,
      agentId,
      id: agentId,
      agentType: this.agentType,
      status: 'AWAITING_UPLOAD',
      created: '',
      name: '',
      size: 0,
      mimeType: ''
    };
    try {
      var _agentResponse$meta$c, _agentResponse$meta, _agentResponse$meta$f, _agentResponse$meta2;
      const agentResponse = await this.fetchGetFileResponseEsDocForAgentId(actionId, agentId);

      // Unfortunately, there is no way to determine if a file is still available in SentinelOne without actually
      // calling the download API, which would return the following error:
      // {  "errors":[ {
      //      "code":4100010,
      //      "detail":"The requested files do not exist. Fetched files are deleted after 3 days, or earlier if more than 30 files are fetched.",
      //      "title":"Resource not found"
      // } ] }
      fileInfo.status = 'READY';
      fileInfo.created = (_agentResponse$meta$c = (_agentResponse$meta = agentResponse.meta) === null || _agentResponse$meta === void 0 ? void 0 : _agentResponse$meta.createdAt) !== null && _agentResponse$meta$c !== void 0 ? _agentResponse$meta$c : '';
      fileInfo.name = (_agentResponse$meta$f = (_agentResponse$meta2 = agentResponse.meta) === null || _agentResponse$meta2 === void 0 ? void 0 : _agentResponse$meta2.filename) !== null && _agentResponse$meta$f !== void 0 ? _agentResponse$meta$f : '';
      fileInfo.mimeType = 'application/octet-stream';
    } catch (e) {
      // Ignore "no response doc" error for the agent and just return the file info with the status of 'AWAITING_UPLOAD'
      if (!(e instanceof _errors.ResponseActionAgentResponseEsDocNotFound)) {
        throw e;
      }
    }
    return fileInfo;
  }
  async getFileDownload(actionId, agentId) {
    var _agentResponse$meta3, _agentResponse$meta4;
    if (!this.options.endpointService.experimentalFeatures.responseActionsSentinelOneGetFileEnabled) {
      throw new _errors.ResponseActionsClientError(`File downloads are not supported for ${this.agentType} agent type. Feature disabled`, 400);
    }
    await this.ensureValidActionId(actionId);
    const agentResponse = await this.fetchGetFileResponseEsDocForAgentId(actionId, agentId);
    if (!((_agentResponse$meta3 = agentResponse.meta) !== null && _agentResponse$meta3 !== void 0 && _agentResponse$meta3.activityLogEntryId)) {
      throw new _errors.ResponseActionsClientError(`Unable to retrieve file from SentinelOne. Response ES document is missing [meta.activityLogEntryId]`);
    }
    const downloadAgentFileMethodOptions = {
      agentUUID: agentId,
      activityId: (_agentResponse$meta4 = agentResponse.meta) === null || _agentResponse$meta4 === void 0 ? void 0 : _agentResponse$meta4.activityLogEntryId
    };
    const {
      data
    } = await this.sendAction(_constants.SUB_ACTION.DOWNLOAD_AGENT_FILE, downloadAgentFileMethodOptions);
    if (!data) {
      throw new _errors.ResponseActionsClientError(`Unable to establish a readable stream for file with SentinelOne`);
    }
    return {
      stream: data,
      fileName: agentResponse.meta.filename,
      mimeType: undefined
    };
  }
  async processPendingActions({
    abortSignal,
    addToQueue
  }) {
    if (abortSignal.aborted) {
      return;
    }
    for await (const pendingActions of this.fetchAllPendingActions()) {
      if (abortSignal.aborted) {
        return;
      }
      const pendingActionsByType = (0, _lodash.groupBy)(pendingActions, 'action.EndpointActions.data.command');
      for (const [actionType, typePendingActions] of Object.entries(pendingActionsByType)) {
        if (abortSignal.aborted) {
          return;
        }
        switch (actionType) {
          case 'isolate':
          case 'unisolate':
            {
              const isolationResponseDocs = await this.checkPendingIsolateOrReleaseActions(typePendingActions, actionType);
              if (isolationResponseDocs.length) {
                addToQueue(...isolationResponseDocs);
              }
            }
            break;
          case 'get-file':
            {
              const responseDocsForGetFile = await this.checkPendingGetFileActions(typePendingActions);
              if (responseDocsForGetFile.length) {
                addToQueue(...responseDocsForGetFile);
              }
            }
            break;
        }
      }
    }
  }
  async fetchGetFileResponseEsDocForAgentId(actionId, agentId) {
    const agentResponse = (await this.fetchActionResponseEsDocs(actionId, [agentId]))[agentId];
    if (!agentResponse) {
      throw new _errors.ResponseActionAgentResponseEsDocNotFound(`Action ID [${actionId}] for agent ID [${actionId}] is still pending`, 404);
    }
    if (agentResponse.EndpointActions.data.command !== 'get-file') {
      throw new _errors.ResponseActionsClientError(`Invalid action ID [${actionId}] - Not a get-file action: [${agentResponse.EndpointActions.data.command}]`, 400);
    }
    return agentResponse;
  }

  /**
   * Checks if the provided Isolate or Unisolate actions are complete and if so, then it builds the Response
   * document for them and returns it. (NOTE: the response is NOT written to ES - only returned)
   * @param actionRequests
   * @param command
   * @private
   */
  async checkPendingIsolateOrReleaseActions(actionRequests, command) {
    const completedResponses = [];
    const actionsByAgentId = {};
    const warnings = [];

    // Create the `OR` clause that filters for each agent id and an updated date of greater than the date when
    // the isolate request was created
    const agentListQuery = actionRequests.reduce((acc, pendingActionData) => {
      var _action$meta;
      const action = pendingActionData.action;
      const s1AgentId = (_action$meta = action.meta) === null || _action$meta === void 0 ? void 0 : _action$meta.agentId;
      if (s1AgentId) {
        if (!actionsByAgentId[s1AgentId]) {
          actionsByAgentId[s1AgentId] = [];
        }
        actionsByAgentId[s1AgentId].push(action);
        acc.push({
          bool: {
            filter: [{
              term: {
                'sentinel_one.activity.agent.id': s1AgentId
              }
            }, {
              range: {
                'sentinel_one.activity.updated_at': {
                  gt: action['@timestamp']
                }
              }
            }]
          }
        });
      } else {
        // This is an edge case and should never happen. But just in case :-)
        warnings.push(`${command} response action ID [${action.EndpointActions.action_id}] missing SentinelOne agent ID, thus unable to check on it's status. Forcing it to complete as failure.`);
        completedResponses.push(this.buildActionResponseEsDoc({
          actionId: action.EndpointActions.action_id,
          agentId: Array.isArray(action.agent.id) ? action.agent.id[0] : action.agent.id,
          data: {
            command
          },
          error: {
            message: `Unable to very if action completed. SentinelOne agent id ('meta.agentId') missing on action request document!`
          }
        }));
      }
      return acc;
    }, []);
    if (agentListQuery.length > 0) {
      const query = {
        bool: {
          must: [{
            terms: {
              // Activity Types can be retrieved from S1 via API: `/web/api/v2.1/activities/types`
              'sentinel_one.activity.type': command === 'isolate' ? [
              // {
              //    "id": 1001
              //    "action": "Agent Disconnected From Network",
              //    "descriptionTemplate": "Agent {{ computer_name }} was disconnected from network.",
              // },
              1001,
              // {
              //    "id": 2010
              //    "action": "Agent Mitigation Report Quarantine Network Failed",
              //    "descriptionTemplate": "Agent {{ computer_name }} was unable to disconnect from network.",
              // },
              2010] : [
              // {
              //    "id": 1002
              //    "action": "Agent Reconnected To Network",
              //    "descriptionTemplate": "Agent {{ computer_name }} was connected to network.",
              // },
              1002]
            }
          }],
          should: agentListQuery,
          minimum_should_match: 1
        }
      };
      const searchRequestOptions = {
        index: _common.SENTINEL_ONE_ACTIVITY_INDEX_PATTERN,
        query,
        // There may be many documents for each host/agent, so we collapse it and only get back the
        // first one that came in after the isolate request was sent
        collapse: {
          field: 'sentinel_one.activity.agent.id',
          inner_hits: {
            name: 'first_found',
            size: 1,
            sort: [{
              'sentinel_one.activity.updated_at': 'asc'
            }]
          }
        },
        // we don't need the source. The document will be stored in `inner_hits.first_found`
        // due to use of `collapse
        _source: false,
        sort: [{
          'sentinel_one.activity.updated_at': {
            order: 'asc'
          }
        }],
        size: _constants2.ACTIONS_SEARCH_PAGE_SIZE
      };
      this.log.debug(`searching for ${command} responses from [${_common.SENTINEL_ONE_ACTIVITY_INDEX_PATTERN}] index with:\n${(0, _stringify.stringify)(searchRequestOptions, 15)}`);
      const searchResults = await this.options.esClient.search(searchRequestOptions).catch(_utils.catchAndWrapError);
      this.log.debug(`Search results for SentinelOne ${command} activity documents:\n${(0, _stringify.stringify)(searchResults)}`);
      for (const searchResultHit of searchResults.hits.hits) {
        var _searchResultHit$inne;
        const isolateActivityResponseDoc = (_searchResultHit$inne = searchResultHit.inner_hits) === null || _searchResultHit$inne === void 0 ? void 0 : _searchResultHit$inne.first_found.hits.hits[0];
        if (isolateActivityResponseDoc && isolateActivityResponseDoc._source) {
          const s1ActivityData = isolateActivityResponseDoc._source.sentinel_one.activity;

          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
          const elasticDocId = isolateActivityResponseDoc._id;
          const s1AgentId = s1ActivityData.agent.id;
          const activityLogEntryId = s1ActivityData.id;
          const activityLogEntryType = s1ActivityData.type;
          const activityLogEntryDescription = s1ActivityData.description.primary;
          for (const actionRequest of actionsByAgentId[s1AgentId]) {
            completedResponses.push(this.buildActionResponseEsDoc({
              actionId: actionRequest.EndpointActions.action_id,
              agentId: Array.isArray(actionRequest.agent.id) ? actionRequest.agent.id[0] : actionRequest.agent.id,
              data: {
                command
              },
              error: activityLogEntryType === 2010 && command === 'isolate' ? {
                message: activityLogEntryDescription !== null && activityLogEntryDescription !== void 0 ? activityLogEntryDescription : `Action failed. SentinelOne activity log entry [${activityLogEntryId}] has a 'type' value of 2010 indicating a failure to disconnect`
              } : undefined,
              meta: {
                elasticDocId,
                activityLogEntryId,
                activityLogEntryType,
                activityLogEntryDescription
              }
            }));
          }
        }
      }
    } else {
      this.log.debug(`Nothing to search for. List of agents IDs is empty.`);
    }
    this.log.debug(`${completedResponses.length} ${command} action responses generated:\n${(0, _stringify.stringify)(completedResponses)}`);
    if (warnings.length > 0) {
      this.log.warn(warnings.join('\n'));
    }
    return completedResponses;
  }
  async checkPendingGetFileActions(actionRequests) {
    const warnings = [];
    const completedResponses = [];
    const actionsByAgentAndBatchId = {};
    // Utility to create the key to lookup items in the `actionByAgentAndBatchId` grouping above
    const getLookupKey = (agentId, commandBatchUuid) => `${agentId}:${commandBatchUuid}`;
    const searchRequestOptions = {
      index: _common.SENTINEL_ONE_ACTIVITY_INDEX_PATTERN,
      size: _constants2.ACTIONS_SEARCH_PAGE_SIZE,
      query: {
        bool: {
          must: [{
            term: {
              // Activity Types can be retrieved from S1 via API: `/web/api/v2.1/activities/types`
              // {
              //   "action": "Agent Uploaded Fetched Files",
              //   "descriptionTemplate": "Agent {{ computer_name }} ({{ external_ip }}) successfully uploaded {{ filename }}.",
              //   "id": 80
              // },
              'sentinel_one.activity.type': 80
            }
          }],
          should: actionRequests.reduce((acc, {
            action
          }) => {
            var _action$meta2, _action$meta3;
            const s1AgentId = (_action$meta2 = action.meta) === null || _action$meta2 === void 0 ? void 0 : _action$meta2.agentId;
            const s1CommandBatchUUID = (_action$meta3 = action.meta) === null || _action$meta3 === void 0 ? void 0 : _action$meta3.commandBatchUuid;
            if (s1AgentId && s1CommandBatchUUID) {
              actionsByAgentAndBatchId[getLookupKey(s1AgentId, s1CommandBatchUUID)] = action;
              acc.push({
                bool: {
                  filter: [{
                    term: {
                      'sentinel_one.activity.agent.id': s1AgentId
                    }
                  }, {
                    term: {
                      'sentinel_one.activity.data.flattened.commandBatchUuid': s1CommandBatchUUID
                    }
                  }]
                }
              });
            } else {
              // This is an edge case and should never happen. But just in case :-)
              warnings.push(`get-file response action ID [${action.EndpointActions.action_id}] missing SentinelOne agent ID or commandBatchUuid value(s). Unable to check on it's status - forcing it to complete as a failure.`);
              completedResponses.push(this.buildActionResponseEsDoc({
                actionId: action.EndpointActions.action_id,
                agentId: Array.isArray(action.agent.id) ? action.agent.id[0] : action.agent.id,
                data: {
                  command: 'get-file'
                },
                error: {
                  message: `Unable to very if action completed. SentinelOne agent id or commandBatchUuid missing on action request document!`
                }
              }));
            }
            return acc;
          }, []),
          minimum_should_match: 1
        }
      }
    };
    if (Object.keys(actionsByAgentAndBatchId).length) {
      this.log.debug(`searching for get-file responses from [${_common.SENTINEL_ONE_ACTIVITY_INDEX_PATTERN}] index with:\n${(0, _stringify.stringify)(searchRequestOptions, 15)}`);
      const searchResults = await this.options.esClient.search(searchRequestOptions).catch(_utils.catchAndWrapError);
      this.log.debug(`Search results for SentinelOne get-file activity documents:\n${(0, _stringify.stringify)(searchResults)}`);
      for (const s1Hit of searchResults.hits.hits) {
        var _s1ActivityDoc$sentin, _s1ActivityDoc$sentin2;
        const s1ActivityDoc = s1Hit._source;
        const s1AgentId = s1ActivityDoc === null || s1ActivityDoc === void 0 ? void 0 : s1ActivityDoc.sentinel_one.activity.agent.id;
        const s1CommandBatchUuid = (_s1ActivityDoc$sentin = s1ActivityDoc === null || s1ActivityDoc === void 0 ? void 0 : s1ActivityDoc.sentinel_one.activity.data.flattened.commandBatchUuid) !== null && _s1ActivityDoc$sentin !== void 0 ? _s1ActivityDoc$sentin : '';
        const activityLogEntryId = (_s1ActivityDoc$sentin2 = s1ActivityDoc === null || s1ActivityDoc === void 0 ? void 0 : s1ActivityDoc.sentinel_one.activity.id) !== null && _s1ActivityDoc$sentin2 !== void 0 ? _s1ActivityDoc$sentin2 : '';
        if (s1AgentId && s1CommandBatchUuid) {
          const actionRequest = actionsByAgentAndBatchId[getLookupKey(s1AgentId, s1CommandBatchUuid)];
          if (actionRequest) {
            var _s1ActivityDoc$sentin3, _s1ActivityDoc$sentin4, _s1ActivityDoc$sentin5, _s1ActivityDoc$sentin6;
            const downloadUrl = (_s1ActivityDoc$sentin3 = s1ActivityDoc === null || s1ActivityDoc === void 0 ? void 0 : s1ActivityDoc.sentinel_one.activity.data.downloaded.url) !== null && _s1ActivityDoc$sentin3 !== void 0 ? _s1ActivityDoc$sentin3 : '';
            const error = !downloadUrl ? {
              message: `File retrieval failed (No download URL defined in SentinelOne activity log id [${activityLogEntryId}])`
            } : undefined;
            completedResponses.push(this.buildActionResponseEsDoc({
              actionId: actionRequest.EndpointActions.action_id,
              agentId: Array.isArray(actionRequest.agent.id) ? actionRequest.agent.id[0] : actionRequest.agent.id,
              data: {
                command: 'get-file',
                comment: (_s1ActivityDoc$sentin4 = s1ActivityDoc === null || s1ActivityDoc === void 0 ? void 0 : s1ActivityDoc.sentinel_one.activity.description.primary) !== null && _s1ActivityDoc$sentin4 !== void 0 ? _s1ActivityDoc$sentin4 : '',
                output: {
                  type: 'json',
                  content: {
                    // code applies only to Endpoint agents
                    code: '',
                    // We don't know the file size for S1 retrieved files
                    zip_size: 0,
                    // We don't have the contents of the zip file for S1
                    contents: []
                  }
                }
              },
              error,
              meta: {
                activityLogEntryId,
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                elasticDocId: s1Hit._id,
                downloadUrl,
                createdAt: (_s1ActivityDoc$sentin5 = s1ActivityDoc === null || s1ActivityDoc === void 0 ? void 0 : s1ActivityDoc.sentinel_one.activity.updated_at) !== null && _s1ActivityDoc$sentin5 !== void 0 ? _s1ActivityDoc$sentin5 : '',
                filename: (_s1ActivityDoc$sentin6 = s1ActivityDoc === null || s1ActivityDoc === void 0 ? void 0 : s1ActivityDoc.sentinel_one.activity.data.flattened.filename) !== null && _s1ActivityDoc$sentin6 !== void 0 ? _s1ActivityDoc$sentin6 : ''
              }
            }));
          } else {
            warnings.push(`Activity log entry ${s1Hit._id} was a matched, but no action request for it (should not happen)`);
          }
        }
      }
    } else {
      this.log.debug(`Nothing to search for. No pending get-file actions`);
    }
    this.log.debug(`${completedResponses.length} get-file action responses generated:\n${(0, _stringify.stringify)(completedResponses)}`);
    if (warnings.length > 0) {
      this.log.warn(warnings.join('\n'));
    }
    return completedResponses;
  }
}
exports.SentinelOneActionsClient = SentinelOneActionsClient;