"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SentinelOneAgentStatusClient = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _constants = require("../../../../../../common/constants");
var _utils = require("../../../../utils");
var _ = require("../../..");
var _types = require("../../../../../../common/endpoint/types");
var _base_agent_status_client = require("../lib/base_agent_status_client");
var _errors = require("../errors");
/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0; you may not use this file except in compliance with the Elastic License
 * 2.0.
 */

const SENTINEL_ONE_AGENT_INDEX_PATTERN = `logs-sentinel_one.agent-*`;
var SENTINEL_ONE_NETWORK_STATUS = /*#__PURE__*/function (SENTINEL_ONE_NETWORK_STATUS) {
  SENTINEL_ONE_NETWORK_STATUS["CONNECTING"] = "connecting";
  SENTINEL_ONE_NETWORK_STATUS["CONNECTED"] = "connected";
  SENTINEL_ONE_NETWORK_STATUS["DISCONNECTING"] = "disconnecting";
  SENTINEL_ONE_NETWORK_STATUS["DISCONNECTED"] = "disconnected";
  return SENTINEL_ONE_NETWORK_STATUS;
}(SENTINEL_ONE_NETWORK_STATUS || {});
class SentinelOneAgentStatusClient extends _base_agent_status_client.AgentStatusClient {
  constructor(...args) {
    super(...args);
    (0, _defineProperty2.default)(this, "agentType", 'sentinel_one');
  }
  async getAgentStatuses(agentIds) {
    const esClient = this.options.esClient;
    const metadataService = this.options.endpointService.getEndpointMetadataService();
    const sortField = 'sentinel_one.agent.last_active_date';
    const query = {
      bool: {
        must: [{
          bool: {
            filter: [{
              terms: {
                'sentinel_one.agent.uuid': agentIds
              }
            }]
          }
        }]
      }
    };
    try {
      var _searchResponse$hits, _searchResponse$hits$;
      const [searchResponse, allPendingActions] = await Promise.all([esClient.search({
        index: SENTINEL_ONE_AGENT_INDEX_PATTERN,
        from: 0,
        size: _constants.DEFAULT_MAX_TABLE_QUERY_SIZE,
        query,
        collapse: {
          field: 'sentinel_one.agent.uuid',
          inner_hits: {
            name: 'most_recent',
            size: 1,
            sort: [{
              [sortField]: {
                order: 'desc'
              }
            }]
          }
        },
        sort: [{
          [sortField]: {
            order: 'desc'
          }
        }],
        _source: false
      }, {
        ignore: [404]
      }), (0, _.getPendingActionsSummary)(esClient, metadataService, this.log, agentIds)]).catch(_utils.catchAndWrapError);
      const mostRecentAgentInfosByAgentId = searchResponse === null || searchResponse === void 0 ? void 0 : (_searchResponse$hits = searchResponse.hits) === null || _searchResponse$hits === void 0 ? void 0 : (_searchResponse$hits$ = _searchResponse$hits.hits) === null || _searchResponse$hits$ === void 0 ? void 0 : _searchResponse$hits$.reduce((acc, hit) => {
        var _hit$fields;
        if ((_hit$fields = hit.fields) !== null && _hit$fields !== void 0 && _hit$fields['sentinel_one.agent.uuid'][0]) {
          var _hit$fields2, _hit$inner_hits;
          acc[(_hit$fields2 = hit.fields) === null || _hit$fields2 === void 0 ? void 0 : _hit$fields2['sentinel_one.agent.uuid'][0]] = (_hit$inner_hits = hit.inner_hits) === null || _hit$inner_hits === void 0 ? void 0 : _hit$inner_hits.most_recent.hits.hits[0]._source;
        }
        return acc;
      }, {});
      return agentIds.reduce((acc, agentId) => {
        var _pendingActions$pendi;
        const agentInfo = mostRecentAgentInfosByAgentId[agentId].sentinel_one.agent;
        const pendingActions = allPendingActions.find(agentPendingActions => agentPendingActions.agent_id === agentId);
        acc[agentId] = {
          agentId,
          agentType: this.agentType,
          found: (agentInfo === null || agentInfo === void 0 ? void 0 : agentInfo.uuid) === agentId,
          isolated: (agentInfo === null || agentInfo === void 0 ? void 0 : agentInfo.network_status) === SENTINEL_ONE_NETWORK_STATUS.DISCONNECTED,
          lastSeen: (agentInfo === null || agentInfo === void 0 ? void 0 : agentInfo.last_active_date) || '',
          status: agentInfo !== null && agentInfo !== void 0 && agentInfo.is_active ? _types.HostStatus.HEALTHY :
          // If the agent is pending uninstall or uninstalled, we consider it unenrolled
          agentInfo !== null && agentInfo !== void 0 && agentInfo.is_pending_uninstall || agentInfo !== null && agentInfo !== void 0 && agentInfo.is_uninstalled ? _types.HostStatus.UNENROLLED : _types.HostStatus.OFFLINE,
          pendingActions: (_pendingActions$pendi = pendingActions === null || pendingActions === void 0 ? void 0 : pendingActions.pending_actions) !== null && _pendingActions$pendi !== void 0 ? _pendingActions$pendi : {}
        };
        return acc;
      }, {});
    } catch (err) {
      const error = new _errors.AgentStatusClientError(`Failed to fetch sentinel one agent status for agentIds: [${agentIds}], failed with: ${err.message}`, 500, err);
      this.log.error(error);
      throw error;
    }
  }
}
exports.SentinelOneAgentStatusClient = SentinelOneAgentStatusClient;