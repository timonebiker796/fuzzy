"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RiskScoreDataClient = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _server = require("@kbn/alerting-plugin/server");
var _common = require("@kbn/alerting-plugin/common");
var _configurations = require("./configurations");
var _create_datastream = require("../utils/create_datastream");
var _risk_engine_data_writer = require("./risk_engine_data_writer");
var _risk_engine = require("../../../../common/entity_analytics/risk_engine");
var _transforms = require("../utils/transforms");
var _get_risk_inputs_index = require("./get_risk_inputs_index");
var _create_or_update_index = require("../utils/create_or_update_index");
var _retry_transient_es_errors = require("../utils/retry_transient_es_errors");
var _audit = require("./audit");
var _audit2 = require("../audit");
/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0; you may not use this file except in compliance with the Elastic License
 * 2.0.
 */

class RiskScoreDataClient {
  constructor(options) {
    (0, _defineProperty2.default)(this, "writerCache", new Map());
    (0, _defineProperty2.default)(this, "refreshRiskScoreIndex", async () => {
      await this.options.esClient.indices.refresh({
        index: (0, _risk_engine.getRiskScoreTimeSeriesIndex)(this.options.namespace)
      });
    });
    (0, _defineProperty2.default)(this, "getRiskInputsIndex", ({
      dataViewId
    }) => (0, _get_risk_inputs_index.getRiskInputsIndex)({
      dataViewId,
      logger: this.options.logger,
      soClient: this.options.soClient
    }));
    this.options = options;
  }
  async getWriter({
    namespace
  }) {
    if (this.writerCache.get(namespace)) {
      return this.writerCache.get(namespace);
    }
    const indexPatterns = (0, _configurations.getIndexPatternDataStream)(namespace);
    await this.initializeWriter(namespace, indexPatterns.alias);
    return this.writerCache.get(namespace);
  }
  async initializeWriter(namespace, index) {
    const writer = new _risk_engine_data_writer.RiskEngineDataWriter({
      esClient: this.options.esClient,
      namespace,
      index,
      logger: this.options.logger
    });
    this.writerCache.set(namespace, writer);
    return writer;
  }
  async init() {
    const namespace = this.options.namespace;
    try {
      var _this$options$auditLo;
      const esClient = this.options.esClient;
      const indexPatterns = (0, _configurations.getIndexPatternDataStream)(namespace);
      const indexMetadata = {
        kibana: {
          version: this.options.kibanaVersion
        },
        managed: true,
        namespace
      };
      await Promise.all([(0, _server.createOrUpdateComponentTemplate)({
        logger: this.options.logger,
        esClient,
        template: {
          name: _configurations.mappingComponentName,
          _meta: {
            managed: true
          },
          template: {
            settings: {},
            mappings: (0, _common.mappingFromFieldMap)(_configurations.riskScoreFieldMap, 'strict')
          }
        },
        totalFieldsLimit: _configurations.totalFieldsLimit
      })]);
      await (0, _server.createOrUpdateIndexTemplate)({
        logger: this.options.logger,
        esClient,
        template: {
          name: indexPatterns.template,
          body: {
            data_stream: {
              hidden: true
            },
            index_patterns: [indexPatterns.alias],
            composed_of: [_configurations.mappingComponentName],
            template: {
              lifecycle: {},
              settings: {
                'index.mapping.total_fields.limit': _configurations.totalFieldsLimit
              },
              mappings: {
                dynamic: false,
                _meta: indexMetadata
              }
            },
            _meta: indexMetadata
          }
        }
      });
      await (0, _create_datastream.createDataStream)({
        logger: this.options.logger,
        esClient,
        totalFieldsLimit: _configurations.totalFieldsLimit,
        indexPatterns
      });
      await (0, _create_or_update_index.createOrUpdateIndex)({
        esClient,
        logger: this.options.logger,
        options: {
          index: (0, _risk_engine.getRiskScoreLatestIndex)(namespace),
          mappings: (0, _common.mappingFromFieldMap)(_configurations.riskScoreFieldMap, false)
        }
      });
      const transformId = (0, _transforms.getLatestTransformId)(namespace);
      await (0, _transforms.createTransform)({
        esClient,
        logger: this.options.logger,
        transform: {
          transform_id: transformId,
          ...(0, _configurations.getTransformOptions)({
            dest: (0, _risk_engine.getRiskScoreLatestIndex)(namespace),
            source: [indexPatterns.alias]
          })
        }
      });
      (_this$options$auditLo = this.options.auditLogger) === null || _this$options$auditLo === void 0 ? void 0 : _this$options$auditLo.log({
        message: 'System installed risk engine Elasticsearch components',
        event: {
          action: _audit.RiskScoreAuditActions.RISK_ENGINE_INSTALL,
          category: _audit2.AUDIT_CATEGORY.DATABASE,
          type: _audit2.AUDIT_TYPE.CHANGE,
          outcome: _audit2.AUDIT_OUTCOME.SUCCESS
        }
      });
    } catch (error) {
      this.options.logger.error(`Error initializing risk engine resources: ${error.message}`);
      throw error;
    }
  }

  /**
   * Deletes all resources created by init().
   * It returns an array of errors that occurred during the deletion.
   *
   * WARNING: It will remove all data.
   */
  async tearDown() {
    const namespace = this.options.namespace;
    const esClient = this.options.esClient;
    const indexPatterns = (0, _configurations.getIndexPatternDataStream)(namespace);
    const errors = [];
    const addError = e => errors.push(e);
    await esClient.transform.deleteTransform({
      transform_id: (0, _transforms.getLatestTransformId)(namespace),
      delete_dest_index: true,
      force: true
    }).catch(addError);
    await esClient.indices.deleteDataStream({
      name: indexPatterns.alias
    }).catch(addError);
    await esClient.indices.deleteIndexTemplate({
      name: indexPatterns.template
    }).catch(addError);
    await esClient.cluster.deleteComponentTemplate({
      name: _configurations.mappingComponentName
    }).catch(addError);
    return errors;
  }

  /**
   * Ensures that configuration migrations for risk score indices are seamlessly handled across Kibana upgrades.
   *
   * Upgrades:
   * - Migrating to 8.12+ requires a change to the risk score latest transform index's 'dynamic' setting to ensure that
   * unmapped fields are allowed within stored documents.
   *
   */
  async upgradeIfNeeded() {
    const desiredDynamicValue = 'false';
    const currentDynamicValue = await this.getRiskScoreLatestIndexDynamicConfiguration();
    if (currentDynamicValue !== desiredDynamicValue) {
      await this.setRiskScoreLatestIndexDynamicConfiguration(desiredDynamicValue);
    }
  }
  async getRiskScoreLatestIndexDynamicConfiguration() {
    var _riskScoreLatestIndex, _riskScoreLatestIndex2, _riskScoreLatestIndex3;
    const riskScoreLatestIndexName = (0, _risk_engine.getRiskScoreLatestIndex)(this.options.namespace);
    const riskScoreLatestIndexResponse = await (0, _retry_transient_es_errors.retryTransientEsErrors)(() => this.options.esClient.indices.get({
      index: riskScoreLatestIndexName
    }), {
      logger: this.options.logger
    });
    return (_riskScoreLatestIndex = riskScoreLatestIndexResponse[riskScoreLatestIndexName]) === null || _riskScoreLatestIndex === void 0 ? void 0 : (_riskScoreLatestIndex2 = _riskScoreLatestIndex.mappings) === null || _riskScoreLatestIndex2 === void 0 ? void 0 : (_riskScoreLatestIndex3 = _riskScoreLatestIndex2.dynamic) === null || _riskScoreLatestIndex3 === void 0 ? void 0 : _riskScoreLatestIndex3.toString();
  }

  /**
   * Sets the risk score latest index's 'dynamic' mapping property to the desired value.
   * @throws Error if the index does not exist.
   */
  async setRiskScoreLatestIndexDynamicConfiguration(dynamic) {
    return (0, _retry_transient_es_errors.retryTransientEsErrors)(() => this.options.esClient.indices.putMapping({
      index: (0, _risk_engine.getRiskScoreLatestIndex)(this.options.namespace),
      dynamic
    }), {
      logger: this.options.logger
    });
  }
}
exports.RiskScoreDataClient = RiskScoreDataClient;