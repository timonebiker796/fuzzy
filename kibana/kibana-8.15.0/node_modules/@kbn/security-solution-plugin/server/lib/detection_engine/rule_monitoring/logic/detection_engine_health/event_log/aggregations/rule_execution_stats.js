"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.normalizeRuleExecutionStatsAggregationResult = exports.getRuleExecutionStatsAggregation = void 0;
var _lodash = require("lodash");
var _rule_monitoring = require("../../../../../../../../common/api/detection_engine/rule_monitoring");
var _event_log_constants = require("../../../event_log/event_log_constants");
var f = _interopRequireWildcard(require("../../../event_log/event_log_fields"));
var _es_aggregations = require("../../../utils/es_aggregations");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0; you may not use this file except in compliance with the Elastic License
 * 2.0.
 */

const getRuleExecutionStatsAggregation = aggregationLevel => {
  return {
    executeEvents: {
      filter: {
        bool: {
          filter: [{
            term: {
              [f.EVENT_PROVIDER]: _event_log_constants.ALERTING_PROVIDER
            }
          }, {
            term: {
              [f.EVENT_ACTION]: 'execute'
            }
          }, {
            term: {
              [f.EVENT_CATEGORY]: 'siem'
            }
          }]
        }
      },
      aggs: {
        totalExecutions: {
          cardinality: {
            field: f.RULE_EXECUTION_UUID
          }
        },
        executionDurationMs: {
          percentiles: {
            field: f.RULE_EXECUTION_TOTAL_DURATION_MS,
            missing: 0,
            percents: _es_aggregations.DEFAULT_PERCENTILES
          }
        },
        scheduleDelayNs: {
          percentiles: {
            field: f.RULE_EXECUTION_SCHEDULE_DELAY_NS,
            missing: 0,
            percents: _es_aggregations.DEFAULT_PERCENTILES
          }
        }
      }
    },
    statusChangeEvents: {
      filter: {
        bool: {
          filter: [{
            term: {
              [f.EVENT_PROVIDER]: _event_log_constants.RULE_EXECUTION_LOG_PROVIDER
            }
          }, {
            term: {
              [f.EVENT_ACTION]: _rule_monitoring.RuleExecutionEventTypeEnum['status-change']
            }
          }],
          must_not: [{
            terms: {
              [f.RULE_EXECUTION_STATUS]: [_rule_monitoring.RuleExecutionStatusEnum.running, _rule_monitoring.RuleExecutionStatusEnum['going to run']]
            }
          }]
        }
      },
      aggs: {
        executionsByStatus: {
          terms: {
            field: f.RULE_EXECUTION_STATUS
          }
        }
      }
    },
    executionMetricsEvents: {
      filter: {
        bool: {
          filter: [{
            term: {
              [f.EVENT_PROVIDER]: _event_log_constants.RULE_EXECUTION_LOG_PROVIDER
            }
          }, {
            term: {
              [f.EVENT_ACTION]: _rule_monitoring.RuleExecutionEventTypeEnum['execution-metrics']
            }
          }]
        }
      },
      aggs: {
        gaps: {
          filter: {
            exists: {
              field: f.RULE_EXECUTION_GAP_DURATION_S
            }
          },
          aggs: {
            totalGapDurationS: {
              sum: {
                field: f.RULE_EXECUTION_GAP_DURATION_S
              }
            }
          }
        },
        searchDurationMs: {
          percentiles: {
            field: f.RULE_EXECUTION_SEARCH_DURATION_MS,
            missing: 0,
            percents: _es_aggregations.DEFAULT_PERCENTILES
          }
        },
        indexingDurationMs: {
          percentiles: {
            field: f.RULE_EXECUTION_INDEXING_DURATION_MS,
            missing: 0,
            percents: _es_aggregations.DEFAULT_PERCENTILES
          }
        }
      }
    },
    messageContainingEvents: {
      filter: {
        bool: {
          filter: [{
            term: {
              [f.EVENT_PROVIDER]: _event_log_constants.RULE_EXECUTION_LOG_PROVIDER
            }
          }, {
            terms: {
              [f.EVENT_ACTION]: [_rule_monitoring.RuleExecutionEventTypeEnum['status-change'], _rule_monitoring.RuleExecutionEventTypeEnum.message]
            }
          }]
        }
      },
      aggs: {
        messagesByLogLevel: {
          terms: {
            field: f.LOG_LEVEL
          }
        },
        ...(aggregationLevel === 'whole-interval' ? {
          errors: {
            filter: {
              term: {
                [f.LOG_LEVEL]: _rule_monitoring.LogLevelEnum.error
              }
            },
            aggs: {
              topErrors: {
                categorize_text: {
                  field: 'message',
                  size: 5,
                  similarity_threshold: 99
                }
              }
            }
          },
          warnings: {
            filter: {
              term: {
                [f.LOG_LEVEL]: _rule_monitoring.LogLevelEnum.warn
              }
            },
            aggs: {
              topWarnings: {
                categorize_text: {
                  field: 'message',
                  size: 5,
                  similarity_threshold: 99
                }
              }
            }
          }
        } : {})
      }
    }
  };
};
exports.getRuleExecutionStatsAggregation = getRuleExecutionStatsAggregation;
const normalizeRuleExecutionStatsAggregationResult = (aggregations, aggregationLevel) => {
  const executeEvents = aggregations.executeEvents || {};
  const statusChangeEvents = aggregations.statusChangeEvents || {};
  const executionMetricsEvents = aggregations.executionMetricsEvents || {};
  const messageContainingEvents = aggregations.messageContainingEvents || {};
  const totalExecutions = executeEvents.totalExecutions || {};
  const executionDurationMs = executeEvents.executionDurationMs || {};
  const scheduleDelayNs = executeEvents.scheduleDelayNs || {};
  const executionsByStatus = statusChangeEvents.executionsByStatus || {};
  const gaps = executionMetricsEvents.gaps || {};
  const searchDurationMs = executionMetricsEvents.searchDurationMs || {};
  const indexingDurationMs = executionMetricsEvents.indexingDurationMs || {};
  return {
    number_of_executions: normalizeNumberOfExecutions(totalExecutions, executionsByStatus),
    number_of_logged_messages: normalizeNumberOfLoggedMessages(messageContainingEvents),
    number_of_detected_gaps: normalizeNumberOfDetectedGaps(gaps),
    schedule_delay_ms: normalizeAggregatedMetric(scheduleDelayNs, val => val / 1_000_000),
    execution_duration_ms: normalizeAggregatedMetric(executionDurationMs),
    search_duration_ms: normalizeAggregatedMetric(searchDurationMs),
    indexing_duration_ms: normalizeAggregatedMetric(indexingDurationMs),
    top_errors: aggregationLevel === 'whole-interval' ? normalizeTopErrors(messageContainingEvents) : undefined,
    top_warnings: aggregationLevel === 'whole-interval' ? normalizeTopWarnings(messageContainingEvents) : undefined
  };
};
exports.normalizeRuleExecutionStatsAggregationResult = normalizeRuleExecutionStatsAggregationResult;
const normalizeNumberOfExecutions = (totalExecutions, executionsByStatus) => {
  const getStatusCount = status => {
    const bucket = executionsByStatus.buckets.find(b => b.key === status);
    return Number((bucket === null || bucket === void 0 ? void 0 : bucket.doc_count) || 0);
  };
  return {
    total: Number(totalExecutions.value || 0),
    by_outcome: {
      succeeded: getStatusCount(_rule_monitoring.RuleExecutionStatusEnum.succeeded),
      warning: getStatusCount(_rule_monitoring.RuleExecutionStatusEnum['partial failure']),
      failed: getStatusCount(_rule_monitoring.RuleExecutionStatusEnum.failed)
    }
  };
};
const normalizeNumberOfLoggedMessages = messageContainingEvents => {
  const messagesByLogLevel = messageContainingEvents.messagesByLogLevel || {};
  const getMessageCount = level => {
    const bucket = messagesByLogLevel.buckets.find(b => b.key === level);
    return Number((bucket === null || bucket === void 0 ? void 0 : bucket.doc_count) || 0);
  };
  return {
    total: Number(messageContainingEvents.doc_count || 0),
    by_level: {
      error: getMessageCount(_rule_monitoring.LogLevelEnum.error),
      warn: getMessageCount(_rule_monitoring.LogLevelEnum.warn),
      info: getMessageCount(_rule_monitoring.LogLevelEnum.info),
      debug: getMessageCount(_rule_monitoring.LogLevelEnum.debug),
      trace: getMessageCount(_rule_monitoring.LogLevelEnum.trace)
    }
  };
};
const normalizeNumberOfDetectedGaps = gaps => {
  var _gaps$totalGapDuratio;
  return {
    total: Number(gaps.doc_count || 0),
    total_duration_s: Number(((_gaps$totalGapDuratio = gaps.totalGapDurationS) === null || _gaps$totalGapDuratio === void 0 ? void 0 : _gaps$totalGapDuratio.value) || 0)
  };
};
const normalizeAggregatedMetric = (percentilesAggregate, modifier = v => v) => {
  const rawPercentiles = percentilesAggregate.values || {};
  return {
    percentiles: (0, _lodash.mapValues)(rawPercentiles, rawValue => modifier(Number(rawValue || 0)))
  };
};
const normalizeTopErrors = messageContainingEvents => {
  var _messageContainingEve;
  const topErrors = ((_messageContainingEve = messageContainingEvents.errors) === null || _messageContainingEve === void 0 ? void 0 : _messageContainingEve.topErrors) || {};
  return normalizeTopMessages(topErrors);
};
const normalizeTopWarnings = messageContainingEvents => {
  var _messageContainingEve2;
  const topWarnings = ((_messageContainingEve2 = messageContainingEvents.warnings) === null || _messageContainingEve2 === void 0 ? void 0 : _messageContainingEve2.topWarnings) || {};
  return normalizeTopMessages(topWarnings);
};
const normalizeTopMessages = categorizeTextAggregate => {
  const buckets = (categorizeTextAggregate || {}).buckets || [];
  return buckets.map(b => {
    return {
      count: Number((b === null || b === void 0 ? void 0 : b.doc_count) || 0),
      message: String((b === null || b === void 0 ? void 0 : b.key) || '')
    };
  });
};