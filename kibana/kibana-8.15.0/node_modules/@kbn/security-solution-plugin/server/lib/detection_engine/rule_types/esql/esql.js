"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.esqlExecutor = void 0;
var _perf_hooks = require("perf_hooks");
var _securitysolutionUtils = require("@kbn/securitysolution-utils");
var _build_esql_search_request = require("./build_esql_search_request");
var _esql_request = require("./esql_request");
var _wrap_esql_alerts = require("./wrap_esql_alerts");
var _wrap_suppressed_esql_alerts = require("./wrap_suppressed_esql_alerts");
var _bulk_create_suppressed_alerts_in_memory = require("../utils/bulk_create_suppressed_alerts_in_memory");
var _enrichments = require("../utils/enrichments");
var _utils = require("./utils");
var _fetch_source_documents = require("./fetch_source_documents");
var _reason_formatters = require("../utils/reason_formatters");
var _utils2 = require("../utils/utils");
var _with_security_span = require("../../../../utils/with_security_span");
var _get_is_alert_suppression_active = require("../utils/get_is_alert_suppression_active");
/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0; you may not use this file except in compliance with the Elastic License
 * 2.0.
 */

const esqlExecutor = async ({
  runOpts: {
    completeRule,
    tuple,
    ruleExecutionLogger,
    bulkCreate,
    mergeStrategy,
    primaryTimestamp,
    secondaryTimestamp,
    exceptionFilter,
    unprocessedExceptions,
    alertTimestampOverride,
    publicBaseUrl,
    alertWithSuppression
  },
  services,
  state,
  spaceId,
  experimentalFeatures,
  licensing
}) => {
  const ruleParams = completeRule.ruleParams;
  /**
   * ES|QL returns results as a single page. max size of 10,000
   * while we try increase size of the request to catch all alerts that might been deduplicated
   * we don't want to overload ES/Kibana with large responses
   */
  const ESQL_PAGE_SIZE_CIRCUIT_BREAKER = tuple.maxSignals * 3;
  return (0, _with_security_span.withSecuritySpan)('esqlExecutor', async () => {
    const result = (0, _utils2.createSearchAfterReturnType)();
    let size = tuple.maxSignals;
    while (result.createdSignalsCount <= tuple.maxSignals && size <= ESQL_PAGE_SIZE_CIRCUIT_BREAKER) {
      const esqlRequest = (0, _build_esql_search_request.buildEsqlSearchRequest)({
        query: ruleParams.query,
        from: tuple.from.toISOString(),
        to: tuple.to.toISOString(),
        size,
        filters: [],
        primaryTimestamp,
        secondaryTimestamp,
        exceptionFilter
      });
      ruleExecutionLogger.debug(`ES|QL query request: ${JSON.stringify(esqlRequest)}`);
      const exceptionsWarning = (0, _utils2.getUnprocessedExceptionsWarnings)(unprocessedExceptions);
      if (exceptionsWarning) {
        result.warningMessages.push(exceptionsWarning);
      }
      const esqlSignalSearchStart = _perf_hooks.performance.now();
      const response = await (0, _esql_request.performEsqlRequest)({
        esClient: services.scopedClusterClient.asCurrentUser,
        requestParams: esqlRequest
      });
      const esqlSearchDuration = (0, _utils2.makeFloatString)(_perf_hooks.performance.now() - esqlSignalSearchStart);
      result.searchAfterTimes.push(esqlSearchDuration);
      ruleExecutionLogger.debug(`ES|QL query request took: ${esqlSearchDuration}ms`);
      const isRuleAggregating = (0, _securitysolutionUtils.computeIsESQLQueryAggregating)(completeRule.ruleParams.query);
      const results = response.values
      // slicing already processed results in previous iterations
      .slice(size - tuple.maxSignals).map(row => (0, _utils.rowToDocument)(response.columns, row));
      const index = (0, _securitysolutionUtils.getIndexListFromEsqlQuery)(completeRule.ruleParams.query);
      const sourceDocuments = await (0, _fetch_source_documents.fetchSourceDocuments)({
        esClient: services.scopedClusterClient.asCurrentUser,
        results,
        index,
        isRuleAggregating
      });
      const isAlertSuppressionActive = await (0, _get_is_alert_suppression_active.getIsAlertSuppressionActive)({
        alertSuppression: completeRule.ruleParams.alertSuppression,
        licensing
      });
      const wrapHits = events => (0, _wrap_esql_alerts.wrapEsqlAlerts)({
        events,
        spaceId,
        completeRule,
        mergeStrategy,
        isRuleAggregating,
        alertTimestampOverride,
        ruleExecutionLogger,
        publicBaseUrl,
        tuple
      });
      const syntheticHits = results.map(document => {
        var _sourceDocuments$_id;
        const {
          _id,
          _version,
          _index,
          ...source
        } = document;
        return {
          _source: source,
          fields: _id ? (_sourceDocuments$_id = sourceDocuments[_id]) === null || _sourceDocuments$_id === void 0 ? void 0 : _sourceDocuments$_id.fields : {},
          _id: _id !== null && _id !== void 0 ? _id : '',
          _index: _index !== null && _index !== void 0 ? _index : ''
        };
      });
      if (isAlertSuppressionActive) {
        const wrapSuppressedHits = events => (0, _wrap_suppressed_esql_alerts.wrapSuppressedEsqlAlerts)({
          events,
          spaceId,
          completeRule,
          mergeStrategy,
          isRuleAggregating,
          alertTimestampOverride,
          ruleExecutionLogger,
          publicBaseUrl,
          primaryTimestamp,
          secondaryTimestamp,
          tuple
        });
        const bulkCreateResult = await (0, _bulk_create_suppressed_alerts_in_memory.bulkCreateSuppressedAlertsInMemory)({
          enrichedEvents: syntheticHits,
          toReturn: result,
          wrapHits,
          bulkCreate,
          services,
          ruleExecutionLogger,
          tuple,
          alertSuppression: completeRule.ruleParams.alertSuppression,
          wrapSuppressedHits,
          alertTimestampOverride,
          alertWithSuppression,
          experimentalFeatures,
          buildReasonMessage: _reason_formatters.buildReasonMessageForEsqlAlert,
          mergeSourceAndFields: true,
          // passing 1 here since ES|QL does not support pagination
          maxNumberOfAlertsMultiplier: 1
        });
        (0, _utils2.addToSearchAfterReturn)({
          current: result,
          next: bulkCreateResult
        });
        ruleExecutionLogger.debug(`Created ${bulkCreateResult.createdItemsCount} alerts. Suppressed ${bulkCreateResult.suppressedItemsCount} alerts`);
        if (bulkCreateResult.alertsWereTruncated) {
          result.warningMessages.push((0, _utils2.getSuppressionMaxSignalsWarning)());
          break;
        }
      } else {
        const wrappedAlerts = wrapHits(syntheticHits);
        const enrichAlerts = (0, _enrichments.createEnrichEventsFunction)({
          services,
          logger: ruleExecutionLogger
        });
        const bulkCreateResult = await bulkCreate(wrappedAlerts, tuple.maxSignals - result.createdSignalsCount, enrichAlerts);
        (0, _utils2.addToSearchAfterReturn)({
          current: result,
          next: bulkCreateResult
        });
        ruleExecutionLogger.debug(`Created ${bulkCreateResult.createdItemsCount} alerts`);
        if (bulkCreateResult.alertsWereTruncated) {
          result.warningMessages.push((0, _utils2.getMaxSignalsWarning)());
          break;
        }
      }

      // no more results will be found
      if (response.values.length < size) {
        ruleExecutionLogger.debug(`End of search: Found ${response.values.length} results with page size ${size}`);
        break;
      }
      // ES|QL does not support pagination so we need to increase size of response to be able to catch all events
      size += tuple.maxSignals;
    }
    return {
      ...result,
      state
    };
  });
};
exports.esqlExecutor = esqlExecutor;