"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.upgradePrebuiltRule = void 0;
var _zodHelpers = require("@kbn/zod-helpers");
var _rule_converters = require("../../../normalization/rule_converters");
var _transform_actions = require("../../../../../../../common/detection_engine/transform_actions");
var _rule_schema = require("../../../../../../../common/api/detection_engine/model/rule_schema");
var _utils = require("../utils");
var _read_rules = require("../read_rules");
/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0; you may not use this file except in compliance with the Elastic License
 * 2.0.
 */

const upgradePrebuiltRule = async (rulesClient, upgradePrebuiltRulePayload, mlAuthz) => {
  const {
    ruleAsset
  } = upgradePrebuiltRulePayload;
  await (0, _utils.validateMlAuth)(mlAuthz, ruleAsset.type);
  const existingRule = await (0, _read_rules.readRules)({
    rulesClient,
    ruleId: ruleAsset.rule_id,
    id: undefined
  });
  if (!existingRule) {
    throw new _utils.ClientError(`Failed to find rule ${ruleAsset.rule_id}`, 500);
  }
  if (ruleAsset.type !== existingRule.params.type) {
    // If we're trying to change the type of a prepackaged rule, we need to delete the old one
    // and replace it with the new rule, keeping the enabled setting, actions, throttle, id,
    // and exception lists from the old rule
    await rulesClient.delete({
      id: existingRule.id
    });
    const internalRule = (0, _rule_converters.convertCreateAPIToInternalSchema)({
      ...ruleAsset,
      enabled: existingRule.enabled,
      exceptions_list: existingRule.params.exceptionsList,
      actions: existingRule.actions.map(_transform_actions.transformAlertToRuleAction),
      timeline_id: existingRule.params.timelineId,
      timeline_title: existingRule.params.timelineTitle
    }, {
      immutable: true,
      defaultEnabled: existingRule.enabled
    });
    const createdRule = await rulesClient.create({
      data: internalRule,
      options: {
        id: existingRule.id
      }
    });

    /* Trying to convert the rule to a RuleResponse object */
    const parseResult = _rule_schema.RuleResponse.safeParse((0, _rule_converters.internalRuleToAPIResponse)(createdRule));
    if (!parseResult.success) {
      throw new _utils.RuleResponseValidationError({
        message: (0, _zodHelpers.stringifyZodError)(parseResult.error),
        ruleId: createdRule.params.ruleId
      });
    }
    return parseResult.data;
  }

  // Else, simply patch it.
  const patchedRule = (0, _rule_converters.convertPatchAPIToInternalSchema)(ruleAsset, existingRule);
  const patchedInternalRule = await rulesClient.update({
    id: existingRule.id,
    data: patchedRule
  });

  /* Trying to convert the internal rule to a RuleResponse object */
  const parseResult = _rule_schema.RuleResponse.safeParse((0, _rule_converters.internalRuleToAPIResponse)(patchedInternalRule));
  if (!parseResult.success) {
    throw new _utils.RuleResponseValidationError({
      message: (0, _zodHelpers.stringifyZodError)(parseResult.error),
      ruleId: patchedInternalRule.params.ruleId
    });
  }
  return parseResult.data;
};
exports.upgradePrebuiltRule = upgradePrebuiltRule;