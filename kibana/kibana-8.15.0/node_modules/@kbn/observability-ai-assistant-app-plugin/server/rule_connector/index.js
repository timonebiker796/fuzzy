"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getObsAIAssistantConnectorAdapter = void 0;
exports.getObsAIAssistantConnectorType = getObsAIAssistantConnectorType;
var _rxjs = require("rxjs");
var _lodash = require("lodash");
var _dedent = _interopRequireDefault(require("dedent"));
var _i18n = require("@kbn/i18n");
var _configSchema = require("@kbn/config-schema");
var _connector_feature_config = require("@kbn/actions-plugin/common/connector_feature_config");
var _server = require("@kbn/stack-connectors-plugin/server");
var _common = require("@kbn/observability-ai-assistant-plugin/common");
var _concatenate_chat_completion_chunks = require("@kbn/observability-ai-assistant-plugin/common/utils/concatenate_chat_completion_chunks");
var _get_system_message_from_instructions = require("@kbn/observability-ai-assistant-plugin/server/service/util/get_system_message_from_instructions");
var _convert_schema_to_open_api = require("./convert_schema_to_open_api");
var _rule_connector = require("../../common/rule_connector");
/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0; you may not use this file except in compliance with the Elastic License
 * 2.0.
 */

const CONNECTOR_PRIVILEGES = ['api:observabilityAIAssistant', 'app:observabilityAIAssistant'];
const connectorParamsSchemas = {
  '.slack_api': (0, _convert_schema_to_open_api.convertSchemaToOpenApi)(_server.SlackApiParamsSchema),
  '.slack': (0, _convert_schema_to_open_api.convertSchemaToOpenApi)(_server.SlackParamsSchema),
  '.email': (0, _convert_schema_to_open_api.convertSchemaToOpenApi)(_server.EmailParamsSchema),
  '.webhook': (0, _convert_schema_to_open_api.convertSchemaToOpenApi)(_server.WebhookParamsSchema),
  '.jira': (0, _convert_schema_to_open_api.convertSchemaToOpenApi)(_server.JiraParamsSchema),
  '.pagerduty': (0, _convert_schema_to_open_api.convertSchemaToOpenApi)(_server.PagerdutyParamsSchema)
};
const ParamsSchema = _configSchema.schema.object({
  connector: _configSchema.schema.string(),
  message: _configSchema.schema.string({
    minLength: 1
  })
});
const RuleSchema = _configSchema.schema.object({
  id: _configSchema.schema.string(),
  name: _configSchema.schema.string(),
  tags: _configSchema.schema.arrayOf(_configSchema.schema.string(), {
    defaultValue: []
  }),
  ruleUrl: _configSchema.schema.nullable(_configSchema.schema.string())
});
const AlertSchema = _configSchema.schema.recordOf(_configSchema.schema.string(), _configSchema.schema.any());
const AlertSummarySchema = _configSchema.schema.object({
  new: _configSchema.schema.arrayOf(AlertSchema),
  recovered: _configSchema.schema.arrayOf(AlertSchema)
});
const ConnectorParamsSchema = _configSchema.schema.object({
  connector: _configSchema.schema.string(),
  message: _configSchema.schema.string({
    minLength: 1
  }),
  rule: RuleSchema,
  alerts: AlertSummarySchema
});
function getObsAIAssistantConnectorType(initResources, alertDetailsContextService) {
  return {
    id: _rule_connector.OBSERVABILITY_AI_ASSISTANT_CONNECTOR_ID,
    isSystemActionType: true,
    getKibanaPrivileges: () => CONNECTOR_PRIVILEGES,
    minimumLicenseRequired: 'enterprise',
    name: _i18n.i18n.translate('xpack.observabilityAiAssistant.alertConnector.title', {
      defaultMessage: 'Observability AI Assistant'
    }),
    supportedFeatureIds: [_connector_feature_config.AlertingConnectorFeatureId],
    validate: {
      config: {
        schema: _configSchema.schema.object({}),
        customValidator: () => {}
      },
      params: {
        schema: ConnectorParamsSchema
      },
      secrets: {
        schema: _configSchema.schema.object({})
      }
    },
    renderParameterTemplates,
    executor(options) {
      return executor(options, initResources, alertDetailsContextService);
    }
  };
}
function renderParameterTemplates(logger, params, variables) {
  return {
    connector: params.connector,
    message: params.message,
    rule: params.rule,
    alerts: params.alerts
  };
}
async function executor(execOptions, initResources, alertDetailsContextService) {
  const request = execOptions.request;
  const alerts = execOptions.params.alerts;
  if (!request) {
    throw new Error('AI Assistant connector requires a kibana request');
  }
  if (alerts.new.length === 0 && alerts.recovered.length === 0) {
    // connector could be executed with only ongoing actions. we use this path as
    // dedup mechanism to prevent triggering the same worfklow for an ongoing alert
    return {
      actionId: execOptions.actionId,
      status: 'ok'
    };
  }
  const resources = await initResources(request);
  const client = await resources.service.getClient({
    request
  });
  const functionClient = await resources.service.getFunctionClient({
    signal: new AbortController().signal,
    resources,
    client,
    screenContexts: []
  });
  const actionsClient = await (await resources.plugins.actions.start()).getActionsClientWithRequest(request);
  const connectorsList = await actionsClient.getAll().then(connectors => {
    return connectors.map(connector => {
      if (connector.actionTypeId in connectorParamsSchemas) {
        return {
          ...connector,
          parameters: connectorParamsSchemas[connector.actionTypeId]
        };
      }
      return connector;
    });
  });
  const backgroundInstruction = (0, _dedent.default)(`You are called as a background process because alerts have changed state.
    As a background process you are not interacting with a user. Because of that DO NOT ask for user
    input if tasked to execute actions. You can generate multiple responses in a row.
    If available, include the link of the conversation at the end of your answer.`);
  const alertsContext = await getAlertsContext(execOptions.params.rule, execOptions.params.alerts, async alert => {
    const prompt = await alertDetailsContextService.getAlertDetailsContext({
      core: resources.context.core,
      licensing: resources.context.licensing,
      request: resources.request
    }, {
      alert_started_at: (0, _lodash.get)(alert, 'kibana.alert.start'),
      'service.name': (0, _lodash.get)(alert, 'service.name'),
      'service.environment': (0, _lodash.get)(alert, 'service.environment'),
      'host.name': (0, _lodash.get)(alert, 'host.name')
    });
    return prompt.map(({
      description,
      data
    }) => `${description}:\n${JSON.stringify(data, null, 2)}`).join('\n\n');
  });
  client.complete({
    functionClient,
    persist: true,
    isPublic: true,
    connectorId: execOptions.params.connector,
    signal: new AbortController().signal,
    kibanaPublicUrl: (await resources.context.core).coreStart.http.basePath.publicBaseUrl,
    instructions: [backgroundInstruction],
    messages: [{
      '@timestamp': new Date().toISOString(),
      message: {
        role: _common.MessageRole.System,
        content: (0, _get_system_message_from_instructions.getSystemMessageFromInstructions)({
          availableFunctionNames: functionClient.getFunctions().map(fn => fn.definition.name),
          registeredInstructions: functionClient.getInstructions(),
          userInstructions: [],
          requestInstructions: []
        })
      }
    }, {
      '@timestamp': new Date().toISOString(),
      message: {
        role: _common.MessageRole.User,
        content: execOptions.params.message
      }
    }, {
      '@timestamp': new Date().toISOString(),
      message: {
        role: _common.MessageRole.Assistant,
        content: '',
        function_call: {
          name: 'get_alerts_context',
          arguments: JSON.stringify({}),
          trigger: _common.MessageRole.Assistant
        }
      }
    }, {
      '@timestamp': new Date().toISOString(),
      message: {
        role: _common.MessageRole.User,
        name: 'get_alerts_context',
        content: JSON.stringify({
          context: alertsContext
        })
      }
    }, {
      '@timestamp': new Date().toISOString(),
      message: {
        role: _common.MessageRole.Assistant,
        content: '',
        function_call: {
          name: 'get_connectors',
          arguments: JSON.stringify({}),
          trigger: _common.MessageRole.Assistant
        }
      }
    }, {
      '@timestamp': new Date().toISOString(),
      message: {
        role: _common.MessageRole.User,
        name: 'get_connectors',
        content: JSON.stringify({
          connectors: connectorsList
        })
      }
    }]
  }).pipe((0, _rxjs.filter)(event => event.type === _common.StreamingChatResponseEventType.ChatCompletionChunk)).pipe((0, _concatenate_chat_completion_chunks.concatenateChatCompletionChunks)()).subscribe({
    error: err => {
      execOptions.logger.error(err);
    }
  });
  return {
    actionId: execOptions.actionId,
    status: 'ok'
  };
}
const getObsAIAssistantConnectorAdapter = () => {
  return {
    connectorTypeId: _rule_connector.OBSERVABILITY_AI_ASSISTANT_CONNECTOR_ID,
    ruleActionParamsSchema: ParamsSchema,
    getKibanaPrivileges: () => CONNECTOR_PRIVILEGES,
    buildActionParams: ({
      params,
      rule,
      ruleUrl,
      alerts
    }) => {
      return {
        connector: params.connector,
        message: params.message,
        rule: {
          id: rule.id,
          name: rule.name,
          tags: rule.tags,
          ruleUrl: ruleUrl !== null && ruleUrl !== void 0 ? ruleUrl : null
        },
        alerts: {
          new: alerts.new.data,
          recovered: alerts.recovered.data
        }
      };
    }
  };
};
exports.getObsAIAssistantConnectorAdapter = getObsAIAssistantConnectorAdapter;
async function getAlertsContext(rule, alerts, getAlertContext) {
  const getAlertGroupDetails = async alertGroup => {
    const formattedDetails = await Promise.all(alertGroup.map(async alert => {
      return `- ${JSON.stringify(alert)}. The following contextual information is available:\n${await getAlertContext(alert)}`;
    })).then(messages => messages.join('\n'));
    return formattedDetails;
  };
  let details = `The following alerts have changed state for the rule ${JSON.stringify(rule, null, 2)}:\n`;
  if (alerts.new.length > 0) {
    details += `- ${alerts.new.length} alerts have fired:\n${await getAlertGroupDetails(alerts.new)}\n`;
  }
  if (alerts.recovered.length > 0) {
    details += `- ${alerts.recovered.length} alerts have recovered\n: ${await getAlertGroupDetails(alerts.recovered)}\n`;
  }
  return details;
}