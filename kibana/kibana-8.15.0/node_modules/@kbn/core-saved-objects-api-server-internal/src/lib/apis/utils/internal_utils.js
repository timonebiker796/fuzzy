"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.errorContent = void 0;
exports.getBulkOperationError = getBulkOperationError;
exports.getCurrentTime = getCurrentTime;
exports.getExpectedVersionProperties = getExpectedVersionProperties;
exports.getSavedObjectFromSource = getSavedObjectFromSource;
exports.getSavedObjectNamespaces = getSavedObjectNamespaces;
exports.isMgetDoc = isMgetDoc;
exports.normalizeNamespace = normalizeNamespace;
exports.rawDocExistsInNamespace = rawDocExistsInNamespace;
exports.rawDocExistsInNamespaces = rawDocExistsInNamespaces;
exports.setManaged = setManaged;
var _coreSavedObjectsServer = require("@kbn/core-saved-objects-server");
var _coreSavedObjectsUtilsServer = require("@kbn/core-saved-objects-utils-server");
var _coreSavedObjectsBaseServerInternal = require("@kbn/core-saved-objects-base-server-internal");
/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0 and the Server Side Public License, v 1; you may not use this file except
 * in compliance with, at your election, the Elastic License 2.0 or the Server
 * Side Public License, v 1.
 */

/**
 * Checks the raw response of a bulk operation and returns an error if necessary.
 *
 * @param type
 * @param id
 * @param rawResponse
 *
 * @internal
 */
function getBulkOperationError(type, id, rawResponse) {
  const {
    status,
    error
  } = rawResponse;
  if (error) {
    switch (status) {
      case 404:
        return error.type === 'index_not_found_exception' ? _coreSavedObjectsServer.SavedObjectsErrorHelpers.createIndexAliasNotFoundError(error.index).output.payload : _coreSavedObjectsServer.SavedObjectsErrorHelpers.createGenericNotFoundError(type, id).output.payload;
      case 409:
        return _coreSavedObjectsServer.SavedObjectsErrorHelpers.createConflictError(type, id).output.payload;
      default:
        return {
          error: 'Internal Server Error',
          message: `Unexpected bulk response [${status}] ${error.type}: ${error.reason}`,
          statusCode: 500
        };
    }
  }
}

/**
 * Returns an object with the expected version properties. This facilitates Elasticsearch's Optimistic Concurrency Control.
 *
 * @param version Optional version specified by the consumer.
 * @param document Optional existing document that was obtained in a preflight operation.
 *
 * @internal
 */
function getExpectedVersionProperties(version, document) {
  if (version) {
    return (0, _coreSavedObjectsBaseServerInternal.decodeRequestVersion)(version);
  } else if (document) {
    return {
      if_seq_no: document._seq_no,
      if_primary_term: document._primary_term
    };
  }
  return {};
}

/**
 * @internal
 */

/**
 * Gets a saved object from a raw ES document.
 *
 * @param registry
 * @param type
 * @param id
 * @param doc
 *
 * @internal
 */
function getSavedObjectFromSource(registry, type, id, doc, {
  migrationVersionCompatibility = 'raw'
} = {}) {
  const {
    originId,
    updated_at: updatedAt,
    created_at: createdAt,
    created_by: createdBy,
    updated_by: updatedBy,
    coreMigrationVersion,
    typeMigrationVersion,
    managed,
    migrationVersion = migrationVersionCompatibility === 'compatible' && typeMigrationVersion ? {
      [type]: typeMigrationVersion
    } : undefined
  } = doc._source;
  let namespaces = [];
  if (!registry.isNamespaceAgnostic(type)) {
    var _doc$_source$namespac;
    namespaces = (_doc$_source$namespac = doc._source.namespaces) !== null && _doc$_source$namespac !== void 0 ? _doc$_source$namespac : [_coreSavedObjectsUtilsServer.SavedObjectsUtils.namespaceIdToString(doc._source.namespace)];
  }
  return {
    id,
    type,
    namespaces,
    migrationVersion,
    coreMigrationVersion,
    typeMigrationVersion,
    ...(originId && {
      originId
    }),
    ...(updatedAt && {
      updated_at: updatedAt
    }),
    ...(createdAt && {
      created_at: createdAt
    }),
    ...(createdBy && {
      created_by: createdBy
    }),
    ...(updatedBy && {
      updated_by: updatedBy
    }),
    version: (0, _coreSavedObjectsBaseServerInternal.encodeHitVersion)(doc),
    attributes: doc._source[type],
    references: doc._source.references || [],
    managed
  };
}

/**
 * Check to ensure that a raw document exists in a namespace. If the document is not a multi-namespace type, then this returns `true` as
 * we rely on the guarantees of the document ID format. If the document is a multi-namespace type, this checks to ensure that the
 * document's `namespaces` value includes the string representation of the given namespace.
 *
 * WARNING: This should only be used for documents that were retrieved from Elasticsearch. Otherwise, the guarantees of the document ID
 * format mentioned above do not apply.
 *
 * @param registry
 * @param raw
 * @param namespace
 *
 * @internal
 */
function rawDocExistsInNamespace(registry, raw, namespace) {
  const rawDocType = raw._source.type;

  // if the type is namespace isolated, or namespace agnostic, we can continue to rely on the guarantees
  // of the document ID format and don't need to check this
  if (!registry.isMultiNamespace(rawDocType)) {
    return true;
  }
  const namespaces = raw._source.namespaces;
  const existsInNamespace = (namespaces === null || namespaces === void 0 ? void 0 : namespaces.includes(_coreSavedObjectsUtilsServer.SavedObjectsUtils.namespaceIdToString(namespace))) || (namespaces === null || namespaces === void 0 ? void 0 : namespaces.includes(_coreSavedObjectsUtilsServer.ALL_NAMESPACES_STRING));
  return existsInNamespace !== null && existsInNamespace !== void 0 ? existsInNamespace : false;
}

/**
 * Check to ensure that a raw document exists in at least one of the given namespaces. If the document is not a multi-namespace type, then
 * this returns `true` as we rely on the guarantees of the document ID format. If the document is a multi-namespace type, this checks to
 * ensure that the document's `namespaces` value includes the string representation of at least one of the given namespaces.
 *
 * WARNING: This should only be used for documents that were retrieved from Elasticsearch. Otherwise, the guarantees of the document ID
 * format mentioned above do not apply.
 *
 * @param registry
 * @param raw
 * @param namespaces
 *
 * @internal
 */
function rawDocExistsInNamespaces(registry, raw, namespaces) {
  var _raw$_source$namespac;
  const rawDocType = raw._source.type;

  // if the type is namespace isolated, or namespace agnostic, we can continue to rely on the guarantees
  // of the document ID format and don't need to check this
  if (!registry.isMultiNamespace(rawDocType)) {
    return true;
  }
  const namespacesToCheck = new Set(namespaces);
  const existingNamespaces = (_raw$_source$namespac = raw._source.namespaces) !== null && _raw$_source$namespac !== void 0 ? _raw$_source$namespac : [];
  if (namespacesToCheck.size === 0 || existingNamespaces.length === 0) {
    return false;
  }
  if (namespacesToCheck.has(_coreSavedObjectsUtilsServer.ALL_NAMESPACES_STRING)) {
    return true;
  }
  return existingNamespaces.some(x => x === _coreSavedObjectsUtilsServer.ALL_NAMESPACES_STRING || namespacesToCheck.has(x));
}

/**
 * Ensure that a namespace is always in its namespace ID representation.
 * This allows `'default'` to be used interchangeably with `undefined`.
 *
 * @param namespace
 *
 * @internal
 */
function normalizeNamespace(namespace) {
  if (namespace === _coreSavedObjectsUtilsServer.ALL_NAMESPACES_STRING) {
    throw _coreSavedObjectsServer.SavedObjectsErrorHelpers.createBadRequestError('"options.namespace" cannot be "*"');
  } else if (namespace === undefined) {
    return namespace;
  } else {
    return _coreSavedObjectsUtilsServer.SavedObjectsUtils.namespaceStringToId(namespace);
  }
}

/**
 * Returns the current time. For use in Elasticsearch operations.
 *
 * @internal
 */
function getCurrentTime() {
  return new Date(Date.now()).toISOString();
}

/**
 * Returns the managed boolean to apply to a document as it's managed value.
 * For use by applications to modify behavior for managed saved objects.
 * The behavior is as follows:
 * If `optionsManaged` is set, it will override any existing `managed` value in all the documents being created
 * If `optionsManaged` is not provided, then the documents are created with whatever may be assigned to their `managed` property
 * or default to `false`.
 *
 * @internal
 */

function setManaged({
  optionsManaged,
  objectManaged
}) {
  var _ref;
  return (_ref = optionsManaged !== null && optionsManaged !== void 0 ? optionsManaged : objectManaged) !== null && _ref !== void 0 ? _ref : false;
}

/**
 * Returns a string array of namespaces for a given saved object. If the saved object is undefined, the result is an array that contains the
 * current namespace. Value may be undefined if an existing saved object has no namespaces attribute; this should not happen in normal
 * operations, but it is possible if the Elasticsearch document is manually modified.
 *
 * @param namespace The current namespace.
 * @param document Optional existing saved object that was obtained in a preflight operation.
 */
function getSavedObjectNamespaces(namespace, document) {
  if (document) {
    var _document$_source;
    return (_document$_source = document._source) === null || _document$_source === void 0 ? void 0 : _document$_source.namespaces;
  }
  return [_coreSavedObjectsUtilsServer.SavedObjectsUtils.namespaceIdToString(namespace)];
}

/**
 * Extracts the contents of a decorated error to return the attributes for bulk operations.
 */
const errorContent = error => error.output.payload;
exports.errorContent = errorContent;
function isMgetDoc(doc) {
  return Boolean(doc && 'found' in doc);
}