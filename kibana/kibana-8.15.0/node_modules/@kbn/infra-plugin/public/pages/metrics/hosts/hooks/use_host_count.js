"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useHostCountContext = exports.useHostCount = exports.HostCountProvider = exports.HostCount = void 0;
var rt = _interopRequireWildcard(require("io-ts"));
var _common = require("@kbn/data-plugin/common");
var _react = require("react");
var _rxjs = require("rxjs");
var _constate = _interopRequireDefault(require("constate"));
var _constants = require("../../../../../common/constants");
var _use_kibana = require("../../../../hooks/use_kibana");
var _runtime_types = require("../../../../../common/runtime_types");
var _data_search = require("../../../../utils/data_search");
var _metrics_source = require("../../../../containers/metrics_source");
var _use_unified_search = require("./use_unified_search");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0; you may not use this file except in compliance with the Elastic License
 * 2.0.
 */

const useHostCount = () => {
  const {
    metricsView
  } = (0, _metrics_source.useMetricsDataViewContext)();
  const {
    services: {
      telemetry
    }
  } = (0, _use_kibana.useKibanaContextForPlugin)();
  const {
    buildQuery,
    searchCriteria
  } = (0, _use_unified_search.useUnifiedSearchContext)();
  const {
    search: fetchHostCount,
    requests$
  } = (0, _data_search.useDataSearch)({
    getRequest: (0, _react.useCallback)(() => {
      var _metricsView$timeFiel;
      const query = buildQuery();
      const filters = {
        bool: {
          ...query.bool,
          filter: [...query.bool.filter, {
            exists: {
              field: _constants.HOST_NAME_FIELD
            }
          }, {
            range: {
              [(_metricsView$timeFiel = metricsView === null || metricsView === void 0 ? void 0 : metricsView.timeFieldName) !== null && _metricsView$timeFiel !== void 0 ? _metricsView$timeFiel : _constants.TIMESTAMP_FIELD]: {
                gte: searchCriteria.dateRange.from,
                lte: searchCriteria.dateRange.to
              }
            }
          }]
        }
      };
      return {
        request: {
          params: {
            allow_no_indices: true,
            ignore_unavailable: true,
            index: metricsView === null || metricsView === void 0 ? void 0 : metricsView.indices,
            size: 0,
            track_total_hits: false,
            body: {
              query: filters,
              aggs: {
                count: {
                  cardinality: {
                    field: _constants.HOST_NAME_FIELD
                  }
                }
              }
            }
          }
        },
        options: {
          strategy: _common.ES_SEARCH_STRATEGY
        }
      };
    }, [buildQuery, metricsView === null || metricsView === void 0 ? void 0 : metricsView.indices, metricsView === null || metricsView === void 0 ? void 0 : metricsView.timeFieldName, searchCriteria.dateRange.from, searchCriteria.dateRange.to]),
    parseResponses: (0, _react.useMemo)(() => normalizeDataSearchResponse({
      telemetry,
      telemetryData: {
        withQuery: !!searchCriteria.query.query,
        withFilters: searchCriteria.filters.length > 0 || searchCriteria.panelFilters.length > 0
      }
    }), [searchCriteria.filters.length, searchCriteria.panelFilters.length, searchCriteria.query.query, telemetry])
  });
  const {
    isRequestRunning,
    isResponsePartial,
    latestResponseData,
    latestResponseErrors
  } = (0, _data_search.useLatestPartialDataSearchResponse)(requests$);
  (0, _react.useEffect)(() => {
    fetchHostCount();
  }, [fetchHostCount]);
  return {
    errors: latestResponseErrors,
    isRequestRunning,
    isResponsePartial,
    data: latestResponseData !== null && latestResponseData !== void 0 ? latestResponseData : null
  };
};
exports.useHostCount = useHostCount;
const HostCount = exports.HostCount = (0, _constate.default)(useHostCount);
const [HostCountProvider, useHostCountContext] = HostCount;
exports.useHostCountContext = useHostCountContext;
exports.HostCountProvider = HostCountProvider;
const INITIAL_STATE = {
  data: null,
  errors: [],
  isPartial: true,
  isRunning: true,
  loaded: 0,
  total: undefined
};
const normalizeDataSearchResponse = ({
  telemetry,
  telemetryData
}) => response$ => {
  return response$.pipe((0, _rxjs.map)(response => {
    var _response$isPartial, _response$isRunning;
    return {
      data: (0, _runtime_types.decodeOrThrow)(HostCountResponseRT)(response.rawResponse.aggregations),
      errors: [],
      isPartial: (_response$isPartial = response.isPartial) !== null && _response$isPartial !== void 0 ? _response$isPartial : false,
      isRunning: (_response$isRunning = response.isRunning) !== null && _response$isRunning !== void 0 ? _response$isRunning : false,
      loaded: response.loaded,
      total: response.total
    };
  }), (0, _rxjs.tap)(({
    data
  }) => {
    telemetry.reportHostsViewTotalHostCountRetrieved({
      total: data.count.value,
      with_query: telemetryData.withQuery,
      with_filters: telemetryData.withFilters
    });
  }), (0, _rxjs.startWith)(INITIAL_STATE), (0, _rxjs.catchError)(error => {
    var _error$message;
    return (0, _rxjs.of)({
      ...INITIAL_STATE,
      errors: [(_error$message = error.message) !== null && _error$message !== void 0 ? _error$message : error],
      isRunning: false
    });
  }));
};
const HostCountResponseRT = rt.type({
  count: rt.type({
    value: rt.number
  })
});