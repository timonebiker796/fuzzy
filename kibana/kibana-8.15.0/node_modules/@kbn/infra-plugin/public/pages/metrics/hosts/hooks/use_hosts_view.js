"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useHostsViewContext = exports.useHostsView = exports.HostsViewProvider = exports.HostsView = void 0;
var _react = require("react");
var _constate = _interopRequireDefault(require("constate"));
var _useAsyncFn = _interopRequireDefault(require("react-use/lib/useAsyncFn"));
var _use_kibana = require("../../../../hooks/use_kibana");
var _metrics_source = require("../../../../containers/metrics_source");
var _use_unified_search = require("./use_unified_search");
/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0; you may not use this file except in compliance with the Elastic License
 * 2.0.
 */

/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0; you may not use this file except in compliance with the Elastic License
 * 2.0.
 */

const HOST_TABLE_METRICS = [{
  type: 'cpu'
}, {
  type: 'diskSpaceUsage'
}, {
  type: 'memory'
}, {
  type: 'memoryFree'
}, {
  type: 'normalizedLoad1m'
}, {
  type: 'rx'
}, {
  type: 'tx'
}];
const BASE_INFRA_METRICS_PATH = '/api/metrics/infra';
const useHostsView = () => {
  var _value$nodes;
  const {
    sourceId
  } = (0, _metrics_source.useSourceContext)();
  const {
    services: {
      http,
      data,
      telemetry
    }
  } = (0, _use_kibana.useKibanaContextForPlugin)();
  const {
    buildQuery,
    parsedDateRange,
    searchCriteria
  } = (0, _use_unified_search.useUnifiedSearchContext)();
  const abortCtrlRef = (0, _react.useRef)(new AbortController());
  const [searchSessionId, setSearchSessionId] = (0, _react.useState)(() => data.search.session.start());
  const baseRequest = (0, _react.useMemo)(() => createInfraMetricsRequest({
    dateRange: parsedDateRange,
    esQuery: buildQuery(),
    sourceId,
    limit: searchCriteria.limit
  }), [buildQuery, parsedDateRange, sourceId, searchCriteria.limit]);
  const [state, refetch] = (0, _useAsyncFn.default)(async () => {
    abortCtrlRef.current.abort();
    abortCtrlRef.current = new AbortController();
    const start = performance.now();
    const metricsResponse = await http.post(`${BASE_INFRA_METRICS_PATH}`, {
      signal: abortCtrlRef.current.signal,
      body: JSON.stringify(baseRequest)
    });
    const duration = performance.now() - start;
    telemetry === null || telemetry === void 0 ? void 0 : telemetry.reportPerformanceMetricEvent('infra_hosts_table_load', duration, {
      key1: 'data_load',
      value1: duration
    }, {
      limit: searchCriteria.limit
    });
    return metricsResponse;
  }, [baseRequest, http], {
    loading: true
  });
  (0, _react.useEffect)(() => {
    refetch();
    setSearchSessionId(data.search.session.start());
  }, [data.search.session, refetch]);
  const {
    value,
    error,
    loading
  } = state;
  return {
    loading,
    error,
    hostNodes: (_value$nodes = value === null || value === void 0 ? void 0 : value.nodes) !== null && _value$nodes !== void 0 ? _value$nodes : [],
    searchSessionId
  };
};
exports.useHostsView = useHostsView;
const HostsView = exports.HostsView = (0, _constate.default)(useHostsView);
const [HostsViewProvider, useHostsViewContext] = HostsView;

/**
 * Helpers
 */
exports.useHostsViewContext = useHostsViewContext;
exports.HostsViewProvider = HostsViewProvider;
const createInfraMetricsRequest = ({
  esQuery,
  sourceId,
  dateRange,
  limit
}) => ({
  type: 'host',
  query: esQuery,
  range: {
    from: dateRange.from,
    to: dateRange.to
  },
  metrics: HOST_TABLE_METRICS,
  limit,
  sourceId
});