"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useDashboardMenuItems = void 0;
var _reactRedux = require("react-redux");
var _react = require("react");
var _public = require("@kbn/embeddable-plugin/public");
var _common = require("../../../common");
var _dashboard_app = require("../dashboard_app");
var _dashboard_app_strings = require("../_dashboard_app_strings");
var _show_share_modal = require("./share/show_share_modal");
var _plugin_services = require("../../services/plugin_services");
var _dashboard_constants = require("../../dashboard_constants");
var _confirm_overlays = require("../../dashboard_listing/confirm_overlays");
/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0 and the Server Side Public License, v 1; you may not use this file except
 * in compliance with, at your election, the Elastic License 2.0 or the Server
 * Side Public License, v 1.
 */

const useDashboardMenuItems = ({
  redirectTo,
  isLabsShown,
  setIsLabsShown,
  showResetChange
}) => {
  const [isSaveInProgress, setIsSaveInProgress] = (0, _react.useState)(false);

  /**
   * Unpack dashboard services
   */
  const {
    share,
    dashboardBackup,
    settings: {
      uiSettings
    },
    dashboardCapabilities: {
      showWriteControls
    }
  } = _plugin_services.pluginServices.getServices();
  const isLabsEnabled = uiSettings.get(_common.UI_SETTINGS.ENABLE_LABS_UI);

  /**
   * Unpack dashboard state from redux
   */
  const dashboard = (0, _dashboard_app.useDashboardAPI)();
  const hasRunMigrations = dashboard.select(state => state.componentState.hasRunClientsideMigrations);
  const hasUnsavedChanges = dashboard.select(state => state.componentState.hasUnsavedChanges);
  const hasOverlays = dashboard.select(state => state.componentState.hasOverlays);
  const lastSavedId = dashboard.select(state => state.componentState.lastSavedId);
  const dashboardTitle = dashboard.select(state => state.explicitInput.title);
  const viewMode = dashboard.select(state => state.explicitInput.viewMode);
  const managed = dashboard.select(state => state.componentState.managed);
  const disableTopNav = isSaveInProgress || hasOverlays;

  /**
   * Show the Dashboard app's share menu
   */
  const showShare = (0, _react.useCallback)(anchorElement => {
    (0, _show_share_modal.ShowShareModal)({
      dashboardTitle,
      anchorElement,
      savedObjectId: lastSavedId,
      isDirty: Boolean(hasUnsavedChanges),
      getDashboardState: () => dashboard.getState().explicitInput
    });
  }, [dashboardTitle, hasUnsavedChanges, lastSavedId, dashboard]);
  const maybeRedirect = (0, _react.useCallback)(result => {
    if (!result) return;
    const {
      redirectRequired,
      id
    } = result;
    if (redirectRequired) {
      redirectTo({
        id,
        editMode: true,
        useReplace: true,
        destination: 'dashboard'
      });
    }
  }, [redirectTo]);

  /**
   * Save the dashboard without any UI or popups.
   */
  const quickSaveDashboard = (0, _react.useCallback)(() => {
    setIsSaveInProgress(true);
    dashboard.runQuickSave().then(() => setTimeout(() => setIsSaveInProgress(false), _dashboard_constants.CHANGE_CHECK_DEBOUNCE));
  }, [dashboard]);

  /**
   * initiate interactive dashboard copy action
   */
  const dashboardInteractiveSave = (0, _react.useCallback)(() => {
    dashboard.runInteractiveSave(viewMode).then(result => maybeRedirect(result));
  }, [maybeRedirect, dashboard, viewMode]);

  /**
   * Show the dashboard's "Confirm reset changes" modal. If confirmed:
   * (1) reset the dashboard to the last saved state, and
   * (2) if `switchToViewMode` is `true`, set the dashboard to view mode.
   */
  const resetChanges = (0, _react.useCallback)((switchToViewMode = false) => {
    dashboard.clearOverlays();
    const switchModes = switchToViewMode ? () => {
      dashboard.dispatch.setViewMode(_public.ViewMode.VIEW);
      dashboardBackup.storeViewMode(_public.ViewMode.VIEW);
    } : undefined;
    if (!hasUnsavedChanges) {
      switchModes === null || switchModes === void 0 ? void 0 : switchModes();
      return;
    }
    (0, _confirm_overlays.confirmDiscardUnsavedChanges)(() => {
      (0, _reactRedux.batch)(() => {
        dashboard.resetToLastSavedState();
        switchModes === null || switchModes === void 0 ? void 0 : switchModes();
      });
    }, viewMode);
  }, [dashboard, dashboardBackup, hasUnsavedChanges, viewMode]);

  /**
   * Register all of the top nav configs that can be used by dashboard.
   */

  const menuItems = (0, _react.useMemo)(() => {
    return {
      fullScreen: {
        ..._dashboard_app_strings.topNavStrings.fullScreen,
        id: 'full-screen',
        testId: 'dashboardFullScreenMode',
        run: () => dashboard.dispatch.setFullScreenMode(true),
        disableButton: disableTopNav
      },
      labs: {
        ..._dashboard_app_strings.topNavStrings.labs,
        id: 'labs',
        testId: 'dashboardLabs',
        run: () => setIsLabsShown(!isLabsShown)
      },
      edit: {
        ..._dashboard_app_strings.topNavStrings.edit,
        emphasize: true,
        id: 'edit',
        iconType: 'pencil',
        testId: 'dashboardEditMode',
        className: 'eui-hideFor--s eui-hideFor--xs',
        // hide for small screens - editing doesn't work in mobile mode.
        run: () => {
          dashboardBackup.storeViewMode(_public.ViewMode.EDIT);
          dashboard.dispatch.setViewMode(_public.ViewMode.EDIT);
          dashboard.clearOverlays();
        },
        disableButton: disableTopNav
      },
      quickSave: {
        ..._dashboard_app_strings.topNavStrings.quickSave,
        id: 'quick-save',
        iconType: 'save',
        emphasize: true,
        isLoading: isSaveInProgress,
        testId: 'dashboardQuickSaveMenuItem',
        disableButton: disableTopNav || !(hasRunMigrations || hasUnsavedChanges),
        run: () => quickSaveDashboard()
      },
      interactiveSave: {
        disableButton: disableTopNav,
        emphasize: !Boolean(lastSavedId),
        id: 'interactive-save',
        testId: 'dashboardInteractiveSaveMenuItem',
        run: dashboardInteractiveSave,
        label: viewMode === _public.ViewMode.VIEW ? _dashboard_app_strings.topNavStrings.viewModeInteractiveSave.label : Boolean(lastSavedId) ? _dashboard_app_strings.topNavStrings.editModeInteractiveSave.label : _dashboard_app_strings.topNavStrings.quickSave.label,
        description: viewMode === _public.ViewMode.VIEW ? _dashboard_app_strings.topNavStrings.viewModeInteractiveSave.description : _dashboard_app_strings.topNavStrings.editModeInteractiveSave.description
      },
      switchToViewMode: {
        ..._dashboard_app_strings.topNavStrings.switchToViewMode,
        id: 'cancel',
        disableButton: disableTopNav || !lastSavedId,
        testId: 'dashboardViewOnlyMode',
        run: () => resetChanges(true)
      },
      share: {
        ..._dashboard_app_strings.topNavStrings.share,
        id: 'share',
        testId: 'shareTopNavButton',
        disableButton: disableTopNav,
        run: showShare
      },
      settings: {
        ..._dashboard_app_strings.topNavStrings.settings,
        id: 'settings',
        testId: 'dashboardSettingsButton',
        disableButton: disableTopNav,
        run: () => dashboard.showSettings()
      }
    };
  }, [disableTopNav, isSaveInProgress, hasRunMigrations, hasUnsavedChanges, lastSavedId, dashboardInteractiveSave, viewMode, showShare, dashboard, setIsLabsShown, isLabsShown, dashboardBackup, quickSaveDashboard, resetChanges]);
  const resetChangesMenuItem = (0, _react.useMemo)(() => {
    return {
      ..._dashboard_app_strings.topNavStrings.resetChanges,
      id: 'reset',
      testId: 'dashboardDiscardChangesMenuItem',
      disableButton: !hasUnsavedChanges || hasOverlays || viewMode === _public.ViewMode.EDIT && (isSaveInProgress || !lastSavedId),
      run: () => resetChanges()
    };
  }, [hasOverlays, lastSavedId, resetChanges, viewMode, isSaveInProgress, hasUnsavedChanges]);

  /**
   * Build ordered menus for view and edit mode.
   */
  const viewModeTopNavConfig = (0, _react.useMemo)(() => {
    const labsMenuItem = isLabsEnabled ? [menuItems.labs] : [];
    const shareMenuItem = share ? [menuItems.share] : [];
    const duplicateMenuItem = showWriteControls ? [menuItems.interactiveSave] : [];
    const editMenuItem = showWriteControls && !managed ? [menuItems.edit] : [];
    const mayberesetChangesMenuItem = showResetChange ? [resetChangesMenuItem] : [];
    return [...labsMenuItem, menuItems.fullScreen, ...shareMenuItem, ...duplicateMenuItem, ...mayberesetChangesMenuItem, ...editMenuItem];
  }, [isLabsEnabled, menuItems, share, showWriteControls, managed, showResetChange, resetChangesMenuItem]);
  const editModeTopNavConfig = (0, _react.useMemo)(() => {
    const labsMenuItem = isLabsEnabled ? [menuItems.labs] : [];
    const shareMenuItem = share ? [menuItems.share] : [];
    const editModeItems = [];
    if (lastSavedId) {
      editModeItems.push(menuItems.interactiveSave, menuItems.switchToViewMode);
      if (showResetChange) {
        editModeItems.push(resetChangesMenuItem);
      }
      editModeItems.push(menuItems.quickSave);
    } else {
      editModeItems.push(menuItems.switchToViewMode, menuItems.interactiveSave);
    }
    return [...labsMenuItem, menuItems.settings, ...shareMenuItem, ...editModeItems];
  }, [isLabsEnabled, menuItems, share, lastSavedId, showResetChange, resetChangesMenuItem]);
  return {
    viewModeTopNavConfig,
    editModeTopNavConfig
  };
};
exports.useDashboardMenuItems = useDashboardMenuItems;