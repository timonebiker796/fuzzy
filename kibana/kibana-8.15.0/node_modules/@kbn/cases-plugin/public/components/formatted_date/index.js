"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isP1DTFormatterSetting = exports.PreferenceFormattedP1DTDate = exports.PreferenceFormattedDateFromPrimitive = exports.PreferenceFormattedDate = exports.FormattedRelativePreferenceLabel = exports.FormattedRelativePreferenceDate = exports.FormattedDate = void 0;
var _momentTimezone = _interopRequireDefault(require("moment-timezone"));
var _react = _interopRequireDefault(require("react"));
var _i18nReact = require("@kbn/i18n-react");
var _kibana = require("../../common/lib/kibana");
var _empty_value = require("../empty_value");
var _localized_date_tooltip = require("../localized_date_tooltip");
var _maybe_date = require("./maybe_date");
/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0; you may not use this file except in compliance with the Elastic License
 * 2.0.
 */

const PreferenceFormattedDate = exports.PreferenceFormattedDate = /*#__PURE__*/_react.default.memo(({
  value,
  dateFormat,
  stripMs = false
}) => {
  const systemDateFormat = (0, _kibana.useDateFormat)();
  const toUseDateFormat = dateFormat ? dateFormat : systemDateFormat;
  const strippedDateFormat = toUseDateFormat && stripMs ? toUseDateFormat.replace(/\.?SSS/, '') : toUseDateFormat;
  return /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, _momentTimezone.default.tz(value, (0, _kibana.useTimeZone)()).format(strippedDateFormat));
});
PreferenceFormattedDate.displayName = 'PreferenceFormattedDate';
const PreferenceFormattedDateFromPrimitive = ({
  value
}) => {
  if (value == null) {
    return (0, _empty_value.getOrEmptyTagFromValue)(value);
  }
  const maybeDate = (0, _maybe_date.getMaybeDate)(value);
  if (!maybeDate.isValid()) {
    return (0, _empty_value.getOrEmptyTagFromValue)(value);
  }
  const date = maybeDate.toDate();
  return /*#__PURE__*/_react.default.createElement(PreferenceFormattedDate, {
    value: date
  });
};
exports.PreferenceFormattedDateFromPrimitive = PreferenceFormattedDateFromPrimitive;
PreferenceFormattedDateFromPrimitive.displayName = 'PreferenceFormattedDateFromPrimitive';

/**
 * This function may be passed to `Array.find()` to locate the `P1DT`
 * configuration (sub) setting, a string array that contains two entries
 * like the following example: `['P1DT', 'YYYY-MM-DD']`.
 */
const isP1DTFormatterSetting = formatNameFormatterPair => Array.isArray(formatNameFormatterPair) && formatNameFormatterPair[0] === 'P1DT' && formatNameFormatterPair.length === 2;

/**
 * Renders a date in `P1DT` format, e.g. `YYYY-MM-DD`, as specified by
 * the `P1DT1` entry in the `dateFormat:scaled` Kibana Advanced setting.
 *
 * If the `P1DT` format is not specified in the `dateFormat:scaled` setting,
 * the fallback format `YYYY-MM-DD` will be applied
 */
exports.isP1DTFormatterSetting = isP1DTFormatterSetting;
const PreferenceFormattedP1DTDate = exports.PreferenceFormattedP1DTDate = /*#__PURE__*/_react.default.memo(({
  value
}) => {
  /**
   * A fallback "format name / formatter" 2-tuple for the `P1DT` formatter, which is
   * one of many such pairs expected to be contained in the `dateFormat:scaled`
   * Kibana advanced setting.
   */
  const FALLBACK_DATE_FORMAT_SCALED_P1DT = ['P1DT', 'YYYY-MM-DD'];

  // Read the 'dateFormat:scaled' Kibana Advanced setting, which contains 2-tuple sub-settings:
  const [scaledDateFormatPreference] = (0, _kibana.useUiSetting$)('dateFormat:scaled');

  // attempt to find the nested `['P1DT', 'formatString']` setting
  const maybeP1DTFormatter = Array.isArray(scaledDateFormatPreference) ? scaledDateFormatPreference.find(isP1DTFormatterSetting) : null;
  const p1dtFormat = Array.isArray(maybeP1DTFormatter) && maybeP1DTFormatter.length === 2 ? maybeP1DTFormatter[1] : FALLBACK_DATE_FORMAT_SCALED_P1DT[1];
  return /*#__PURE__*/_react.default.createElement(PreferenceFormattedDate, {
    dateFormat: p1dtFormat,
    value: value
  });
});
PreferenceFormattedP1DTDate.displayName = 'PreferenceFormattedP1DTDate';

/**
 * Renders the specified date value in a format determined by the user's preferences,
 * with a tooltip that renders:
 * - the name of the field
 * - a humanized relative date (e.g. 16 minutes ago)
 * - a long representation of the date that includes the day of the week (e.g. Thursday, March 21, 2019 6:47pm)
 * - the raw date value (e.g. 2019-03-22T00:47:46Z)
 */
const FormattedDate = exports.FormattedDate = /*#__PURE__*/_react.default.memo(({
  value,
  fieldName,
  className = ''
}) => {
  if (value == null) {
    return (0, _empty_value.getOrEmptyTagFromValue)(value);
  }
  const maybeDate = (0, _maybe_date.getMaybeDate)(value);
  return maybeDate.isValid() ? /*#__PURE__*/_react.default.createElement(_localized_date_tooltip.LocalizedDateTooltip, {
    date: maybeDate.toDate(),
    fieldName: fieldName,
    className: className
  }, /*#__PURE__*/_react.default.createElement(PreferenceFormattedDate, {
    value: maybeDate.toDate()
  })) : (0, _empty_value.getOrEmptyTagFromValue)(value);
});
FormattedDate.displayName = 'FormattedDate';

/**
 * Renders the specified date value according to under/over one hour
 * Under an hour = relative format
 * Over an hour = in a format determined by the user's preferences,
 * with a tooltip that renders:
 * - the name of the field
 * - a humanized relative date (e.g. 16 minutes ago)
 * - a long representation of the date that includes the day of the week (e.g. Thursday, March 21, 2019 6:47pm)
 * - the raw date value (e.g. 2019-03-22T00:47:46Z)
 * @param value -  raw date
 * @param  stripMs - strip milliseconds when formatting time (remove ".SSS" from the date format)
 */
const FormattedRelativePreferenceDate = ({
  value,
  stripMs = false
}) => {
  if (value == null) {
    return (0, _empty_value.getOrEmptyTagFromValue)(value);
  }
  const maybeDate = (0, _maybe_date.getMaybeDate)(value);
  if (!maybeDate.isValid()) {
    return (0, _empty_value.getOrEmptyTagFromValue)(value);
  }
  const date = maybeDate.toDate();
  return /*#__PURE__*/_react.default.createElement(_localized_date_tooltip.LocalizedDateTooltip, {
    date: date
  }, (0, _momentTimezone.default)(date).add(1, 'hours').isBefore(new Date()) ? /*#__PURE__*/_react.default.createElement(PreferenceFormattedDate, {
    "data-test-subj": "preference-time",
    value: date,
    stripMs: stripMs
  }) : /*#__PURE__*/_react.default.createElement(_i18nReact.FormattedRelative, {
    "data-test-subj": "relative-time",
    value: date
  }));
};
exports.FormattedRelativePreferenceDate = FormattedRelativePreferenceDate;
FormattedRelativePreferenceDate.displayName = 'FormattedRelativePreferenceDate';

/**
 * Renders a preceding label according to under/over one hour
 */

const FormattedRelativePreferenceLabel = ({
  value,
  preferenceLabel,
  relativeLabel
}) => {
  if (value == null) {
    return null;
  }
  const maybeDate = (0, _maybe_date.getMaybeDate)(value);
  if (!maybeDate.isValid()) {
    return null;
  }
  return (0, _momentTimezone.default)(maybeDate.toDate()).add(1, 'hours').isBefore(new Date()) ? /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, preferenceLabel) : /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, relativeLabel);
};
exports.FormattedRelativePreferenceLabel = FormattedRelativePreferenceLabel;
FormattedRelativePreferenceLabel.displayName = 'FormattedRelativePreferenceLabel';