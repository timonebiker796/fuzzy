"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MLInferenceLogic = exports.EMPTY_PIPELINE_CONFIGURATION = void 0;
var _kea = require("kea");
var _ml_inference_pipeline = require("../../../../../../../common/ml_inference_pipeline");
var _api = require("../../../../../../../common/types/api");
var _handle_api_errors = require("../../../../../shared/flash_messages/handle_api_errors");
var _cached_fetch_index_api_logic = require("../../../../api/index/cached_fetch_index_api_logic");
var _mappings_logic = require("../../../../api/mappings/mappings_logic");
var _cached_fetch_models_api_logic = require("../../../../api/ml_models/cached_fetch_models_api_logic");
var _start_text_expansion_model_api_logic = require("../../../../api/ml_models/text_expansion/start_text_expansion_model_api_logic");
var _attach_ml_inference_pipeline = require("../../../../api/pipelines/attach_ml_inference_pipeline");
var _create_ml_inference_pipeline = require("../../../../api/pipelines/create_ml_inference_pipeline");
var _fetch_ml_inference_pipeline_processors = require("../../../../api/pipelines/fetch_ml_inference_pipeline_processors");
var _fetch_ml_inference_pipelines = require("../../../../api/pipelines/fetch_ml_inference_pipelines");
var _fetch_pipeline = require("../../../../api/pipelines/fetch_pipeline");
var _indices = require("../../../../utils/indices");
var _utils = require("../../../shared/ml_inference/utils");
var _pipelines_logic = require("../pipelines_logic");
var _types = require("./types");
var _utils2 = require("./utils");
/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0; you may not use this file except in compliance with the Elastic License
 * 2.0.
 */

const EMPTY_PIPELINE_CONFIGURATION = exports.EMPTY_PIPELINE_CONFIGURATION = {
  modelID: '',
  pipelineName: '',
  targetField: ''
};
const API_REQUEST_COMPLETE_STATUSES = [_api.Status.SUCCESS, _api.Status.ERROR];
const DEFAULT_CONNECTOR_FIELDS = ['body', 'title', 'id', 'type', 'url'];
const getFullTargetFieldName = (sourceField, targetField, isTextExpansionModelSelected) => {
  const suffixedTargetField = `${targetField || sourceField}${isTextExpansionModelSelected ? '_expanded' : ''}`;
  return (0, _ml_inference_pipeline.getMlInferencePrefixedFieldName)(suffixedTargetField);
};
const MLInferenceLogic = exports.MLInferenceLogic = (0, _kea.kea)({
  actions: {
    addSelectedFieldsToMapping: isTextExpansionModelSelected => ({
      isTextExpansionModelSelected
    }),
    attachPipeline: true,
    clearFormErrors: true,
    clearModelPlaceholderFlag: modelId => ({
      modelId
    }),
    createPipeline: true,
    onAddInferencePipelineStepChange: step => ({
      step
    }),
    removeFieldFromMapping: fieldName => ({
      fieldName
    }),
    selectFields: fieldNames => ({
      fieldNames
    }),
    setAddInferencePipelineStep: step => ({
      step
    }),
    setIndexName: indexName => ({
      indexName
    }),
    setInferencePipelineConfiguration: configuration => ({
      configuration
    }),
    setTargetField: targetFieldName => ({
      targetFieldName
    })
  },
  connect: {
    actions: [_cached_fetch_models_api_logic.CachedFetchModelsApiLogic, ['apiSuccess as fetchModelsApiSuccess', 'startPolling as startPollingModels'], _fetch_ml_inference_pipelines.FetchMlInferencePipelinesApiLogic, ['makeRequest as makeMlInferencePipelinesRequest', 'apiSuccess as mlInferencePipelinesSuccess'], _mappings_logic.MappingsApiLogic, ['makeRequest as makeMappingRequest', 'apiError as mappingsApiError'], _create_ml_inference_pipeline.CreateMlInferencePipelineApiLogic, ['apiError as createApiError', 'apiSuccess as createApiSuccess', 'makeRequest as makeCreatePipelineRequest'], _attach_ml_inference_pipeline.AttachMlInferencePipelineApiLogic, ['apiError as attachApiError', 'apiSuccess as attachApiSuccess', 'makeRequest as makeAttachPipelineRequest'], _pipelines_logic.PipelinesLogic, ['closeAddMlInferencePipelineModal'], _start_text_expansion_model_api_logic.StartTextExpansionModelApiLogic, ['apiSuccess as startTextExpansionModelSuccess'], _fetch_pipeline.FetchPipelineApiLogic, ['apiReset as clearFetchedPipeline', 'makeRequest as fetchPipelineByName', 'apiSuccess as fetchPipelineSuccess']],
    values: [_cached_fetch_models_api_logic.CachedFetchModelsApiLogic, ['modelsData', 'status as modelsStatus', 'isInitialLoading as isModelsInitialLoading'], _cached_fetch_index_api_logic.CachedFetchIndexApiLogic, ['indexData as index'], _fetch_ml_inference_pipelines.FetchMlInferencePipelinesApiLogic, ['data as mlInferencePipelinesData'], _mappings_logic.MappingsApiLogic, ['data as mappingData', 'status as mappingStatus'], _fetch_ml_inference_pipeline_processors.FetchMlInferencePipelineProcessorsApiLogic, ['data as mlInferencePipelineProcessors'], _fetch_pipeline.FetchPipelineApiLogic, ['data as existingPipeline']]
  },
  listeners: ({
    values,
    actions
  }) => ({
    attachPipeline: () => {
      const {
        addInferencePipelineModal: {
          configuration: {
            pipelineName
          },
          indexName
        }
      } = values;
      actions.makeAttachPipelineRequest({
        indexName,
        pipelineName
      });
    },
    clearModelPlaceholderFlag: ({
      modelId
    }) => {
      const {
        addInferencePipelineModal: {
          configuration
        }
      } = values;

      // Don't change the flag if the user clicked away from the selected model
      if (modelId !== configuration.modelID) return;
      actions.setInferencePipelineConfiguration({
        ...configuration,
        isModelPlaceholderSelected: false
      });
    },
    createPipeline: () => {
      var _configuration$fieldM;
      const {
        addInferencePipelineModal: {
          configuration,
          indexName
        },
        mlInferencePipeline // Full pipeline definition
      } = values;
      actions.makeCreatePipelineRequest({
        indexName,
        fieldMappings: (_configuration$fieldM = configuration.fieldMappings) !== null && _configuration$fieldM !== void 0 ? _configuration$fieldM : [],
        modelId: configuration.modelID,
        pipelineDefinition: mlInferencePipeline,
        pipelineName: configuration.pipelineName
      });
    },
    mlInferencePipelinesSuccess: data => {
      var _data$length;
      if (((_data$length = data === null || data === void 0 ? void 0 : data.length) !== null && _data$length !== void 0 ? _data$length : 0) === 0 && values.addInferencePipelineModal.configuration.existingPipeline === undefined) {
        // Default to a new pipeline if there are no existing pipelines to choose
        actions.setInferencePipelineConfiguration({
          ...values.addInferencePipelineModal.configuration,
          existingPipeline: false
        });
      }
    },
    startTextExpansionModelSuccess: () => {
      // Refresh ML models list when the text expansion model is started
      actions.startPollingModels();
    },
    onAddInferencePipelineStepChange: ({
      step
    }) => {
      const {
        addInferencePipelineModal: {
          configuration: {
            pipelineName,
            existingPipeline
          },
          step: currentStep
        }
      } = values;
      if (currentStep === _types.AddInferencePipelineSteps.Configuration && !existingPipeline) {
        // Validate name is not in use
        actions.fetchPipelineByName({
          pipelineName: `ml-inference-${(0, _ml_inference_pipeline.formatPipelineName)(pipelineName)}`
        });
        // Continue to the next step so we don't have to save it to state, we will change
        // back to the Configuration step if we find a pipeline with the same name

        // Re-fetch ML model list to include those that were deployed in this step
        actions.startPollingModels();
      }
      actions.setAddInferencePipelineStep(step);
    },
    fetchPipelineSuccess: () => {
      // We found a pipeline with the name, go back to configuration step
      actions.setAddInferencePipelineStep(_types.AddInferencePipelineSteps.Configuration);
    }
  }),
  path: ['enterprise_search', 'content', 'pipelines_add_ml_inference_pipeline'],
  reducers: {
    addInferencePipelineModal: [{
      configuration: {
        ...EMPTY_PIPELINE_CONFIGURATION
      },
      indexName: '',
      step: _types.AddInferencePipelineSteps.Configuration
    }, {
      addSelectedFieldsToMapping: (modal, {
        isTextExpansionModelSelected
      }) => {
        const {
          configuration: {
            fieldMappings,
            targetField
          },
          selectedSourceFields
        } = modal;
        const mergedFieldMappings = [...(fieldMappings || []), ...(selectedSourceFields || []).map(fieldName => ({
          sourceField: fieldName,
          targetField: getFullTargetFieldName(fieldName, targetField, isTextExpansionModelSelected)
        }))];
        return {
          ...modal,
          configuration: {
            ...modal.configuration,
            fieldMappings: mergedFieldMappings,
            targetField: ''
          },
          selectedSourceFields: []
        };
      },
      closeAddMlInferencePipelineModal: () => ({
        configuration: {
          ...EMPTY_PIPELINE_CONFIGURATION
        },
        indexName: '',
        step: _types.AddInferencePipelineSteps.Configuration
      }),
      createApiSuccess: () => ({
        configuration: {
          ...EMPTY_PIPELINE_CONFIGURATION
        },
        indexName: '',
        step: _types.AddInferencePipelineSteps.Configuration
      }),
      removeFieldFromMapping: (modal, {
        fieldName
      }) => {
        const {
          configuration: {
            fieldMappings
          }
        } = modal;
        if (!fieldMappings) {
          return modal;
        }
        return {
          ...modal,
          configuration: {
            ...modal.configuration,
            fieldMappings: fieldMappings === null || fieldMappings === void 0 ? void 0 : fieldMappings.filter(({
              sourceField
            }) => sourceField !== fieldName)
          }
        };
      },
      selectFields: (modal, {
        fieldNames
      }) => ({
        ...modal,
        configuration: {
          ...modal.configuration
        },
        selectedSourceFields: fieldNames
      }),
      setAddInferencePipelineStep: (modal, {
        step
      }) => ({
        ...modal,
        step
      }),
      setIndexName: (modal, {
        indexName
      }) => ({
        ...modal,
        indexName
      }),
      setInferencePipelineConfiguration: (modal, {
        configuration
      }) => ({
        ...modal,
        configuration
      }),
      setTargetField: (modal, {
        targetFieldName
      }) => ({
        ...modal,
        configuration: {
          ...modal.configuration,
          targetField: targetFieldName
        }
      })
    }],
    createErrors: [[], {
      attachApiError: (_, error) => (0, _handle_api_errors.getErrorsFromHttpResponse)(error),
      createApiError: (_, error) => (0, _handle_api_errors.getErrorsFromHttpResponse)(error),
      makeAttachPipelineRequest: () => [],
      makeCreatePipelineRequest: () => []
    }]
  },
  selectors: ({
    selectors
  }) => ({
    formErrors: [() => [selectors.addInferencePipelineModal, selectors.existingPipeline], (modal, existingPipeline) => ({
      ...(0, _utils2.validateInferencePipelineConfiguration)(modal.configuration),
      ...(0, _utils2.validateInferencePipelineFields)(modal.configuration),
      ...(0, _utils2.validatePipelineNameIsAvailable)(existingPipeline)
    })],
    isConfigureStepValid: [() => [selectors.addInferencePipelineModal], modal => {
      const errors = (0, _utils2.validateInferencePipelineConfiguration)(modal.configuration);
      return Object.keys(errors).length === 0;
    }],
    isLoading: [() => [selectors.mappingStatus], mappingStatus => !API_REQUEST_COMPLETE_STATUSES.includes(mappingStatus)],
    isPipelineDataValid: [() => [selectors.formErrors], errors => Object.keys(errors).length === 0],
    isTextExpansionModelSelected: [() => [selectors.selectedModel], model => (model === null || model === void 0 ? void 0 : model.type) === 'text_expansion'],
    mlInferencePipeline: [() => [selectors.isPipelineDataValid, selectors.addInferencePipelineModal, selectors.modelsData, selectors.mlInferencePipelinesData], (isPipelineDataValid, {
      configuration
    }, models, mlInferencePipelinesData) => {
      var _configuration$fieldM2;
      if (configuration.existingPipeline) {
        if (configuration.pipelineName.length === 0) {
          return undefined;
        }
        const pipeline = mlInferencePipelinesData === null || mlInferencePipelinesData === void 0 ? void 0 : mlInferencePipelinesData[configuration.pipelineName];
        if (!pipeline) {
          return undefined;
        }
        return pipeline;
      }
      if (!isPipelineDataValid) return undefined;
      const model = models === null || models === void 0 ? void 0 : models.find(mlModel => mlModel.modelId === configuration.modelID);
      if (!model) return undefined;
      return (0, _ml_inference_pipeline.generateMlInferencePipelineBody)({
        model,
        pipelineName: `${_ml_inference_pipeline.ML_INFERENCE_PREFIX}${configuration.pipelineName}`,
        fieldMappings: (_configuration$fieldM2 = configuration.fieldMappings) !== null && _configuration$fieldM2 !== void 0 ? _configuration$fieldM2 : [],
        inferenceConfig: configuration.inferenceConfig
      });
    }],
    sourceFields: [() => [selectors.mappingStatus, selectors.mappingData, selectors.index], (status, mapping, index) => {
      var _mapping$mappings;
      if (status !== _api.Status.SUCCESS) return;
      if ((mapping === null || mapping === void 0 ? void 0 : (_mapping$mappings = mapping.mappings) === null || _mapping$mappings === void 0 ? void 0 : _mapping$mappings.properties) === undefined) {
        if ((0, _indices.isConnectorIndex)(index)) {
          return DEFAULT_CONNECTOR_FIELDS;
        }
        return [];
      }
      return Object.entries(mapping.mappings.properties).reduce((fields, [key, value]) => {
        if (value.type === 'text' || value.type === 'keyword') {
          fields.push(key);
        }
        return fields;
      }, []).sort(_utils.sortSourceFields);
    }],
    selectableModels: [() => [selectors.modelsData], response => response !== null && response !== void 0 ? response : []],
    selectedModel: [() => [selectors.selectableModels, selectors.addInferencePipelineModal], (models, addInferencePipelineModal) => models.find(m => m.modelId === addInferencePipelineModal.configuration.modelID)]
  })
});