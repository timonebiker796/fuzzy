"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RoleMappingsLogic = void 0;
var _kea = require("kea");
var _flash_messages = require("../../../shared/flash_messages");
var _http = require("../../../shared/http");
var _constants = require("./constants");
/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0; you may not use this file except in compliance with the Elastic License
 * 2.0.
 */

const getFirstAttributeName = roleMapping => Object.entries(roleMapping.rules)[0][0];
const getFirstAttributeValue = roleMapping => Object.entries(roleMapping.rules)[0][1];
const emptyUser = {
  username: '',
  email: ''
};
const RoleMappingsLogic = exports.RoleMappingsLogic = (0, _kea.kea)({
  path: ['enterprise_search', 'workplace_search', 'users_and_roles'],
  actions: {
    setRoleMappingsData: data => data,
    setRoleMapping: roleMapping => ({
      roleMapping
    }),
    setElasticsearchUser: elasticsearchUser => ({
      elasticsearchUser
    }),
    setSingleUserRoleMapping: singleUserRoleMapping => ({
      singleUserRoleMapping
    }),
    setRoleMappings: ({
      roleMappings
    }) => ({
      roleMappings
    }),
    setRoleMappingErrors: errors => ({
      errors
    }),
    handleRoleChange: roleType => ({
      roleType
    }),
    handleUsernameSelectChange: username => ({
      username
    }),
    handleGroupSelectionChange: groupIds => ({
      groupIds
    }),
    handleAttributeSelectorChange: (value, firstElasticsearchRole) => ({
      value,
      firstElasticsearchRole
    }),
    handleAttributeValueChange: value => ({
      value
    }),
    handleAllGroupsSelectionChange: selected => ({
      selected
    }),
    enableRoleBasedAccess: true,
    openSingleUserRoleMappingFlyout: true,
    setUserExistingRadioValue: userFormUserIsExisting => ({
      userFormUserIsExisting
    }),
    resetState: true,
    initializeRoleMappings: true,
    initializeSingleUserRoleMapping: roleMappingId => ({
      roleMappingId
    }),
    initializeRoleMapping: roleMappingId => ({
      roleMappingId
    }),
    handleDeleteMapping: roleMappingId => ({
      roleMappingId
    }),
    handleSaveMapping: true,
    handleSaveUser: true,
    setDefaultGroup: availableGroups => ({
      availableGroups
    }),
    openRoleMappingFlyout: true,
    closeUsersAndRolesFlyout: false,
    setElasticsearchUsernameValue: username => ({
      username
    }),
    setElasticsearchEmailValue: email => ({
      email
    }),
    setUserCreated: true,
    setUserFormIsNewUser: userFormIsNewUser => ({
      userFormIsNewUser
    })
  },
  reducers: {
    dataLoading: [true, {
      setRoleMappingsData: () => false,
      setRoleMappings: () => false,
      resetState: () => true,
      enableRoleBasedAccess: () => true
    }],
    roleMappings: [[], {
      setRoleMappingsData: (_, {
        roleMappings
      }) => roleMappings,
      setRoleMappings: (_, {
        roleMappings
      }) => roleMappings,
      resetState: () => []
    }],
    singleUserRoleMappings: [[], {
      setRoleMappingsData: (_, {
        singleUserRoleMappings
      }) => singleUserRoleMappings,
      resetState: () => []
    }],
    availableGroups: [[], {
      setRoleMappingsData: (_, {
        availableGroups
      }) => availableGroups
    }],
    attributes: [[], {
      setRoleMappingsData: (_, {
        attributes
      }) => attributes
    }],
    elasticsearchRoles: [[], {
      setRoleMappingsData: (_, {
        elasticsearchRoles
      }) => elasticsearchRoles
    }],
    elasticsearchUsers: [[], {
      setRoleMappingsData: (_, {
        elasticsearchUsers
      }) => elasticsearchUsers
    }],
    roleMapping: [null, {
      setRoleMapping: (_, {
        roleMapping
      }) => roleMapping,
      initializeRoleMappings: () => null,
      resetState: () => null,
      closeUsersAndRolesFlyout: () => null
    }],
    singleUserRoleMapping: [null, {
      setSingleUserRoleMapping: (_, {
        singleUserRoleMapping
      }) => singleUserRoleMapping || null,
      closeUsersAndRolesFlyout: () => null
    }],
    roleType: ['admin', {
      setRoleMapping: (_, {
        roleMapping
      }) => roleMapping.roleType,
      handleRoleChange: (_, {
        roleType
      }) => roleType
    }],
    includeInAllGroups: [false, {
      setRoleMapping: (_, {
        roleMapping
      }) => roleMapping.allGroups,
      handleAllGroupsSelectionChange: (_, {
        selected
      }) => selected,
      closeUsersAndRolesFlyout: () => false
    }],
    attributeValue: ['', {
      setRoleMapping: (_, {
        roleMapping
      }) => getFirstAttributeValue(roleMapping),
      handleAttributeSelectorChange: (_, {
        value,
        firstElasticsearchRole
      }) => value === 'role' ? firstElasticsearchRole : '',
      handleAttributeValueChange: (_, {
        value
      }) => value,
      resetState: () => '',
      closeUsersAndRolesFlyout: () => ''
    }],
    attributeName: ['username', {
      setRoleMapping: (_, {
        roleMapping
      }) => getFirstAttributeName(roleMapping),
      handleAttributeSelectorChange: (_, {
        value
      }) => value,
      resetState: () => 'username',
      closeUsersAndRolesFlyout: () => 'username'
    }],
    selectedGroups: [new Set(), {
      setRoleMappingsData: (_, {
        availableGroups
      }) => new Set(availableGroups.filter(group => group.name === _constants.DEFAULT_GROUP_NAME).map(group => group.id)),
      setDefaultGroup: (_, {
        availableGroups
      }) => new Set(availableGroups.filter(group => group.name === _constants.DEFAULT_GROUP_NAME).map(group => group.id)),
      setRoleMapping: (_, {
        roleMapping
      }) => new Set(roleMapping.groups.map(group => group.id)),
      handleGroupSelectionChange: (_, {
        groupIds
      }) => {
        const newSelectedGroupNames = new Set();
        groupIds.forEach(groupId => newSelectedGroupNames.add(groupId));
        return newSelectedGroupNames;
      },
      closeUsersAndRolesFlyout: () => new Set()
    }],
    roleMappingFlyoutOpen: [false, {
      openRoleMappingFlyout: () => true,
      closeUsersAndRolesFlyout: () => false,
      initializeRoleMappings: () => false,
      initializeRoleMapping: () => true
    }],
    singleUserRoleMappingFlyoutOpen: [false, {
      openSingleUserRoleMappingFlyout: () => true,
      closeUsersAndRolesFlyout: () => false,
      initializeSingleUserRoleMapping: () => true
    }],
    roleMappingErrors: [[], {
      setRoleMappingErrors: (_, {
        errors
      }) => errors,
      handleSaveMapping: () => [],
      closeUsersAndRolesFlyout: () => []
    }],
    userFormUserIsExisting: [true, {
      setUserExistingRadioValue: (_, {
        userFormUserIsExisting
      }) => userFormUserIsExisting,
      closeUsersAndRolesFlyout: () => true
    }],
    elasticsearchUser: [emptyUser, {
      setRoleMappingsData: (_, {
        elasticsearchUsers
      }) => elasticsearchUsers[0] || emptyUser,
      setElasticsearchUser: (_, {
        elasticsearchUser
      }) => elasticsearchUser || emptyUser,
      setElasticsearchUsernameValue: (state, {
        username
      }) => ({
        ...state,
        username
      }),
      setElasticsearchEmailValue: (state, {
        email
      }) => ({
        ...state,
        email
      }),
      closeUsersAndRolesFlyout: () => emptyUser
    }],
    userCreated: [false, {
      setUserCreated: () => true,
      closeUsersAndRolesFlyout: () => false
    }],
    userFormIsNewUser: [true, {
      setUserFormIsNewUser: (_, {
        userFormIsNewUser
      }) => userFormIsNewUser
    }],
    smtpSettingsPresent: [false, {
      setRoleMappingsData: (_, {
        smtpSettingsPresent
      }) => smtpSettingsPresent
    }],
    formLoading: [false, {
      handleSaveMapping: () => true,
      handleSaveUser: () => true,
      initializeRoleMappings: () => false,
      setRoleMappingErrors: () => false
    }]
  },
  selectors: ({
    selectors
  }) => ({
    selectedOptions: [() => [selectors.selectedGroups, selectors.availableGroups], (selectedGroups, availableGroups) => {
      const selectedIds = Array.from(selectedGroups.values());
      return availableGroups.filter(({
        id
      }) => selectedIds.includes(id)).map(({
        id,
        name
      }) => ({
        label: name,
        value: id
      }));
    }]
  }),
  listeners: ({
    actions,
    values
  }) => ({
    enableRoleBasedAccess: async () => {
      const {
        http
      } = _http.HttpLogic.values;
      const route = '/internal/workplace_search/org/role_mappings/enable_role_based_access';
      try {
        await http.post(route);
        actions.initializeRoleMappings();
      } catch (e) {
        (0, _flash_messages.flashAPIErrors)(e);
      }
    },
    initializeRoleMappings: async () => {
      const {
        http
      } = _http.HttpLogic.values;
      const route = '/internal/workplace_search/org/role_mappings';
      try {
        const response = await http.get(route);
        actions.setRoleMappingsData(response);
      } catch (e) {
        (0, _flash_messages.flashAPIErrors)(e);
      }
    },
    initializeRoleMapping: async ({
      roleMappingId
    }) => {
      const roleMapping = values.roleMappings.find(({
        id
      }) => id === roleMappingId);
      if (roleMapping) actions.setRoleMapping(roleMapping);
    },
    initializeSingleUserRoleMapping: ({
      roleMappingId
    }) => {
      const singleUserRoleMapping = values.singleUserRoleMappings.find(({
        roleMapping
      }) => roleMapping.id === roleMappingId);
      if (singleUserRoleMapping) {
        actions.setElasticsearchUser(singleUserRoleMapping.elasticsearchUser);
        actions.setRoleMapping(singleUserRoleMapping.roleMapping);
      }
      actions.setSingleUserRoleMapping(singleUserRoleMapping);
      actions.setUserFormIsNewUser(!singleUserRoleMapping);
    },
    handleDeleteMapping: async ({
      roleMappingId
    }) => {
      const {
        http
      } = _http.HttpLogic.values;
      const route = `/internal/workplace_search/org/role_mappings/${roleMappingId}`;
      try {
        await http.delete(route);
        actions.initializeRoleMappings();
        (0, _flash_messages.flashSuccessToast)(_constants.ROLE_MAPPING_DELETED_MESSAGE);
      } catch (e) {
        (0, _flash_messages.flashAPIErrors)(e);
      }
    },
    handleSaveMapping: async () => {
      const {
        http
      } = _http.HttpLogic.values;
      const {
        attributeName,
        attributeValue,
        roleType,
        roleMapping,
        selectedGroups,
        includeInAllGroups
      } = values;
      const body = JSON.stringify({
        roleType,
        allGroups: includeInAllGroups,
        rules: {
          [attributeName]: attributeValue
        },
        groups: includeInAllGroups ? [] : Array.from(selectedGroups)
      });
      const request = !roleMapping ? http.post('/internal/workplace_search/org/role_mappings', {
        body
      }) : http.put(`/internal/workplace_search/org/role_mappings/${roleMapping.id}`, {
        body
      });
      const SUCCESS_MESSAGE = !roleMapping ? _constants.ROLE_MAPPING_CREATED_MESSAGE : _constants.ROLE_MAPPING_UPDATED_MESSAGE;
      try {
        await request;
        actions.initializeRoleMappings();
        (0, _flash_messages.flashSuccessToast)(SUCCESS_MESSAGE);
      } catch (e) {
        var _e$body, _e$body$attributes;
        actions.setRoleMappingErrors(e === null || e === void 0 ? void 0 : (_e$body = e.body) === null || _e$body === void 0 ? void 0 : (_e$body$attributes = _e$body.attributes) === null || _e$body$attributes === void 0 ? void 0 : _e$body$attributes.errors);
      }
    },
    resetState: () => {
      (0, _flash_messages.clearFlashMessages)();
    },
    handleSaveUser: async () => {
      var _singleUserRoleMappin;
      const {
        http
      } = _http.HttpLogic.values;
      const {
        roleType,
        singleUserRoleMapping,
        includeInAllGroups,
        selectedGroups,
        elasticsearchUser: {
          email,
          username
        }
      } = values;
      const body = JSON.stringify({
        roleMapping: {
          groups: includeInAllGroups ? [] : Array.from(selectedGroups),
          roleType,
          allGroups: includeInAllGroups,
          id: singleUserRoleMapping === null || singleUserRoleMapping === void 0 ? void 0 : (_singleUserRoleMappin = singleUserRoleMapping.roleMapping) === null || _singleUserRoleMappin === void 0 ? void 0 : _singleUserRoleMappin.id
        },
        elasticsearchUser: {
          username,
          email
        }
      });
      try {
        const response = await http.post('/internal/workplace_search/org/single_user_role_mapping', {
          body
        });
        actions.setSingleUserRoleMapping(response);
        actions.setUserCreated();
        actions.initializeRoleMappings();
      } catch (e) {
        var _e$body2, _e$body2$attributes;
        actions.setRoleMappingErrors(e === null || e === void 0 ? void 0 : (_e$body2 = e.body) === null || _e$body2 === void 0 ? void 0 : (_e$body2$attributes = _e$body2.attributes) === null || _e$body2$attributes === void 0 ? void 0 : _e$body2$attributes.errors);
      }
    },
    closeUsersAndRolesFlyout: () => {
      (0, _flash_messages.clearFlashMessages)();
      const firstUser = values.elasticsearchUsers[0];
      actions.setElasticsearchUser(firstUser);
      actions.setDefaultGroup(values.availableGroups);
    },
    openRoleMappingFlyout: () => {
      (0, _flash_messages.clearFlashMessages)();
    },
    openSingleUserRoleMappingFlyout: () => {
      (0, _flash_messages.clearFlashMessages)();
    },
    setUserExistingRadioValue: ({
      userFormUserIsExisting
    }) => {
      const firstUser = values.elasticsearchUsers[0];
      actions.setElasticsearchUser(userFormUserIsExisting ? firstUser : emptyUser);
    },
    handleUsernameSelectChange: ({
      username
    }) => {
      const user = values.elasticsearchUsers.find(u => u.username === username);
      if (user) actions.setElasticsearchUser(user);
    }
  })
});