"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.registerSyntheticsStatusCheckRule = void 0;
var _server = require("@kbn/core/server");
var _lodash = require("lodash");
var _server2 = require("@kbn/alerting-plugin/server");
var _common = require("@kbn/observability-plugin/common");
var _synthetics_rule_field_map = require("../../../common/rules/synthetics_rule_field_map");
var _message_utils = require("./message_utils");
var _status_rule_executor = require("./status_rule_executor");
var _status_rule = require("../../../common/rules/status_rule");
var _synthetics_alerts = require("../../../common/constants/synthetics_alerts");
var _common2 = require("../common");
var _action_variables = require("../action_variables");
var _translations = require("../translations");
/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0; you may not use this file except in compliance with the Elastic License
 * 2.0.
 */

const registerSyntheticsStatusCheckRule = (server, plugins, syntheticsMonitorClient, alerting) => {
  if (!alerting) {
    throw new Error('Cannot register the synthetics monitor status rule type. The alerting plugin needs to be enabled.');
  }
  alerting.registerType({
    id: _synthetics_alerts.SYNTHETICS_ALERT_RULE_TYPES.MONITOR_STATUS,
    category: _server.DEFAULT_APP_CATEGORIES.observability.id,
    producer: 'uptime',
    name: _translations.STATUS_RULE_NAME,
    validate: {
      params: _status_rule.StatusRulePramsSchema
    },
    defaultActionGroupId: _synthetics_alerts.MONITOR_STATUS.id,
    actionGroups: [_synthetics_alerts.MONITOR_STATUS],
    actionVariables: (0, _action_variables.getActionVariables)({
      plugins
    }),
    isExportable: true,
    minimumLicenseRequired: 'basic',
    doesSetRecoveryContext: true,
    executor: async options => {
      var _ruleState$meta;
      const {
        state: ruleState,
        params,
        services,
        spaceId,
        previousStartedAt,
        startedAt
      } = options;
      const {
        alertsClient,
        savedObjectsClient,
        scopedClusterClient,
        uiSettingsClient
      } = services;
      if (!alertsClient) {
        throw new _server2.AlertsClientError();
      }
      const {
        basePath
      } = server;
      const dateFormat = await uiSettingsClient.get('dateFormat');
      const timezone = await uiSettingsClient.get('dateFormat:tz');
      const tz = timezone === 'Browser' ? 'UTC' : timezone;
      const statusRule = new _status_rule_executor.StatusRuleExecutor(previousStartedAt, params, savedObjectsClient, scopedClusterClient.asCurrentUser, server, syntheticsMonitorClient);
      const {
        downConfigs,
        staleDownConfigs,
        upConfigs
      } = await statusRule.getDownChecks((_ruleState$meta = ruleState.meta) === null || _ruleState$meta === void 0 ? void 0 : _ruleState$meta.downConfigs);
      Object.entries(downConfigs).forEach(([idWithLocation, {
        ping,
        configId
      }]) => {
        var _ping$observer$name;
        const locationId = (_ping$observer$name = ping.observer.name) !== null && _ping$observer$name !== void 0 ? _ping$observer$name : '';
        const alertId = idWithLocation;
        const monitorSummary = (0, _message_utils.getMonitorSummary)(ping, _message_utils.DOWN_LABEL, locationId, configId, dateFormat, tz);
        const {
          uuid,
          start
        } = alertsClient.report({
          id: alertId,
          actionGroup: _synthetics_alerts.MONITOR_STATUS.id
        });
        const errorStartedAt = start !== null && start !== void 0 ? start : startedAt.toISOString();
        let relativeViewInAppUrl = '';
        if (monitorSummary.stateId) {
          relativeViewInAppUrl = (0, _common2.getRelativeViewInAppUrl)({
            configId,
            stateId: monitorSummary.stateId,
            locationId
          });
        }
        const payload = (0, _message_utils.getMonitorAlertDocument)(monitorSummary);
        const context = {
          ...monitorSummary,
          idWithLocation,
          errorStartedAt,
          linkMessage: monitorSummary.stateId ? (0, _common2.getFullViewInAppMessage)(basePath, spaceId, relativeViewInAppUrl) : '',
          [_action_variables.VIEW_IN_APP_URL]: (0, _common2.getViewInAppUrl)(basePath, spaceId, relativeViewInAppUrl),
          [_action_variables.ALERT_DETAILS_URL]: (0, _common2.getAlertDetailsUrl)(basePath, spaceId, uuid)
        };
        alertsClient.setAlertData({
          id: alertId,
          payload,
          context
        });
      });
      (0, _common2.setRecoveredAlertsContext)({
        alertsClient,
        basePath,
        spaceId,
        staleDownConfigs,
        upConfigs,
        dateFormat,
        tz
      });
      return {
        state: (0, _common2.updateState)(ruleState, !(0, _lodash.isEmpty)(downConfigs), {
          downConfigs
        })
      };
    },
    alerts: {
      ..._common2.SyntheticsRuleTypeAlertDefinition,
      shouldWrite: true
    },
    fieldsForAAD: Object.keys(_synthetics_rule_field_map.syntheticsRuleFieldMap),
    getViewInAppRelativeUrl: ({
      rule
    }) => _common.observabilityPaths.ruleDetails(rule.id)
  });
};
exports.registerSyntheticsStatusCheckRule = registerSyntheticsStatusCheckRule;