"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LOAD_EVENT_LABEL = exports.LCP_LABEL = exports.LAYOUT_SHIFT_LABEL = exports.LAYOUT_SHIFT = exports.FIELD_SYNTHETICS_LCP = exports.FIELD_SYNTHETICS_FCP = exports.FIELD_SYNTHETICS_DOCUMENT_ONLOAD = exports.FIELD_SYNTHETICS_DCL = exports.FCP_LABEL = exports.DOCUMENT_CONTENT_LOADED_LABEL = void 0;
exports.WaterfallChartMarkers = WaterfallChartMarkers;
var _react = _interopRequireWildcard(require("react"));
var _charts = require("@elastic/charts");
var _i18n = require("@kbn/i18n");
var _public = require("@kbn/observability-shared-plugin/public");
var _common = require("@kbn/kibana-react-plugin/common");
var _waterfall_context = require("../context/waterfall_context");
var _waterfall_marker_icon = require("./waterfall_marker_icon");
var _data_formatting = require("../../../common/network_data/data_formatting");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0; you may not use this file except in compliance with the Elastic License
 * 2.0.
 */

const FIELD_SYNTHETICS_LCP = exports.FIELD_SYNTHETICS_LCP = 'browser.experience.lcp.us';
const FIELD_SYNTHETICS_FCP = exports.FIELD_SYNTHETICS_FCP = 'browser.experience.fcp.us';
const FIELD_SYNTHETICS_DOCUMENT_ONLOAD = exports.FIELD_SYNTHETICS_DOCUMENT_ONLOAD = 'browser.experience.load.us';
const FIELD_SYNTHETICS_DCL = exports.FIELD_SYNTHETICS_DCL = 'browser.experience.dcl.us';
const LAYOUT_SHIFT = exports.LAYOUT_SHIFT = 'layoutShift';
function WaterfallChartMarkers() {
  const theme = (0, _public.useTheme)();
  const {
    markerItems,
    showCustomMarks
  } = (0, _waterfall_context.useWaterfallContext)();
  const markerItemsByOffset = (0, _react.useMemo)(() => (markerItems !== null && markerItems !== void 0 ? markerItems : []).reduce((acc, cur) => {
    var _acc$get;
    acc.set(cur.offset, [...((_acc$get = acc.get(cur.offset)) !== null && _acc$get !== void 0 ? _acc$get : []), cur]);
    return acc;
  }, new Map()), [markerItems]);
  const annotations = (0, _react.useMemo)(() => {
    let lastOffset;
    const recognizedMarkerItemsByOffset = Array.from(markerItemsByOffset.entries()).reduce((acc, [offset, items]) => {
      // Remove unrecognized marks e.g. custom marks if `showCustomMarks` is false
      const vitalMarkers = showCustomMarks ? items : items.filter(({
        id
      }) => getMarkersInfo(id, theme) !== undefined);
      const hasMultipleMarksAtOffset = vitalMarkers.some(({
        id
      }) => id !== LAYOUT_SHIFT);
      const isLastOffsetTooClose = lastOffset && Math.abs(offset - lastOffset) < 100; // 100ms

      // If offsets coincide or are too close, remove less important marks e.g. Layout Shift
      const filteredItems = hasMultipleMarksAtOffset || isLastOffsetTooClose ? vitalMarkers.filter(({
        id
      }) => id !== LAYOUT_SHIFT) : vitalMarkers;
      if (filteredItems.length) {
        acc.set(offset, filteredItems);
      }
      lastOffset = offset;
      return acc;
    }, new Map());
    return Array.from(recognizedMarkerItemsByOffset.entries()).map(([offset, items]) => {
      var _markersInfo$field, _markersInfo$color, _markersInfo$strokeWi;
      const uniqueIds = (items !== null && items !== void 0 ? items : []).map(({
        id
      }) => id).filter((id, index, arr) => arr.indexOf(id) === index);
      const label = uniqueIds.map(id => {
        var _getMarkersInfo$label, _getMarkersInfo;
        return (_getMarkersInfo$label = (_getMarkersInfo = getMarkersInfo(id, theme)) === null || _getMarkersInfo === void 0 ? void 0 : _getMarkersInfo.label) !== null && _getMarkersInfo$label !== void 0 ? _getMarkersInfo$label : id;
      }).join(' / ');
      const id = uniqueIds[0];
      const markersInfo = getMarkersInfo(id, theme);
      return {
        id,
        offset,
        label,
        field: (_markersInfo$field = markersInfo === null || markersInfo === void 0 ? void 0 : markersInfo.field) !== null && _markersInfo$field !== void 0 ? _markersInfo$field : '',
        color: (_markersInfo$color = markersInfo === null || markersInfo === void 0 ? void 0 : markersInfo.color) !== null && _markersInfo$color !== void 0 ? _markersInfo$color : theme.eui.euiColorMediumShade,
        strokeWidth: (_markersInfo$strokeWi = markersInfo === null || markersInfo === void 0 ? void 0 : markersInfo.strokeWidth) !== null && _markersInfo$strokeWi !== void 0 ? _markersInfo$strokeWi : 1,
        dash: markersInfo === null || markersInfo === void 0 ? void 0 : markersInfo.dash
      };
    });
  }, [markerItemsByOffset, showCustomMarks, theme]);
  if (!markerItems) {
    return null;
  }
  return /*#__PURE__*/_react.default.createElement(Wrapper, null, annotations.map(({
    id,
    offset,
    label,
    field,
    color,
    strokeWidth,
    dash
  }) => {
    const key = `${id}-${offset}`;
    return /*#__PURE__*/_react.default.createElement(_charts.LineAnnotation, {
      key: key,
      id: key,
      domainType: _charts.AnnotationDomainType.YDomain,
      dataValues: [{
        dataValue: offset,
        details: label,
        header: (0, _data_formatting.formatMillisecond)(offset, {
          maxMillis: 4000
        })
      }],
      marker: /*#__PURE__*/_react.default.createElement(_waterfall_marker_icon.WaterfallMarkerIcon, {
        field: field,
        label: label
      }),
      style: {
        line: {
          strokeWidth,
          stroke: color,
          opacity: 1,
          dash
        }
      },
      zIndex: theme.eui.euiZLevel0
    });
  }));
}
function getMarkersInfo(id, theme) {
  switch (id) {
    case 'domContentLoaded':
      return {
        label: DOCUMENT_CONTENT_LOADED_LABEL,
        color: theme.eui.euiColorMediumShade,
        field: FIELD_SYNTHETICS_DCL,
        strokeWidth: 1,
        dash: undefined
      };
    case 'firstContentfulPaint':
      return {
        label: FCP_LABEL,
        color: theme.eui.euiColorMediumShade,
        field: FIELD_SYNTHETICS_FCP,
        strokeWidth: 1,
        dash: undefined
      };
    case 'largestContentfulPaint':
      return {
        label: LCP_LABEL,
        color: theme.eui.euiColorMediumShade,
        field: FIELD_SYNTHETICS_LCP,
        strokeWidth: 1,
        dash: undefined
      };
    case 'layoutShift':
      return {
        label: LAYOUT_SHIFT_LABEL,
        color: theme.eui.euiColorMediumShade,
        field: '',
        strokeWidth: 1,
        dash: [5, 5]
      };
    case 'loadEvent':
      return {
        label: LOAD_EVENT_LABEL,
        color: theme.eui.euiColorMediumShade,
        field: FIELD_SYNTHETICS_DOCUMENT_ONLOAD,
        strokeWidth: 1,
        dash: undefined
      };
  }
  return undefined;
}
const Wrapper = _common.euiStyled.span`
  &&& {
    > .echAnnotation__icon {
      top: 8px;
    }
  }
`;
const FCP_LABEL = exports.FCP_LABEL = _i18n.i18n.translate('xpack.synthetics.synthetics.waterfall.fcpLabel', {
  defaultMessage: 'First contentful paint'
});
const LCP_LABEL = exports.LCP_LABEL = _i18n.i18n.translate('xpack.synthetics.synthetics.waterfall.lcpLabel', {
  defaultMessage: 'Largest contentful paint'
});
const LAYOUT_SHIFT_LABEL = exports.LAYOUT_SHIFT_LABEL = _i18n.i18n.translate('xpack.synthetics.synthetics.waterfall.layoutShiftLabel', {
  defaultMessage: 'Layout shift'
});
const LOAD_EVENT_LABEL = exports.LOAD_EVENT_LABEL = _i18n.i18n.translate('xpack.synthetics.synthetics.waterfall.loadEventLabel', {
  defaultMessage: 'Load event'
});
const DOCUMENT_CONTENT_LOADED_LABEL = exports.DOCUMENT_CONTENT_LOADED_LABEL = _i18n.i18n.translate('xpack.synthetics.synthetics.waterfall.domContentLabel', {
  defaultMessage: 'DOM Content Loaded'
});