"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MONITOR_TYPE_CONFIG = exports.FIELD = void 0;
var _react = _interopRequireDefault(require("react"));
var _lodash = require("lodash");
var _i18n = require("@kbn/i18n");
var _i18nReact = require("@kbn/i18n-react");
var _common = require("@kbn/fleet-plugin/common");
var _eui = require("@elastic/eui");
var _throttling_config_field = require("../fields/throttling/throttling_config_field");
var _field_wrappers = require("./field_wrappers");
var _kibana_services = require("../../../../../kibana_services");
var _use_monitor_name = require("../../../hooks/use_monitor_name");
var _types = require("../types");
var _constants = require("../constants");
var _defaults = require("./defaults");
var _validation = require("./validation");
/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0; you may not use this file except in compliance with the Elastic License
 * 2.0.
 */

const getScheduleContent = (value, seconds) => {
  if (seconds) {
    return _i18n.i18n.translate('xpack.synthetics.monitorConfig.schedule.seconds.label', {
      defaultMessage: 'Every {value, number} {value, plural, one {second} other {seconds}}',
      values: {
        value
      }
    });
  }
  if (value > 60) {
    return _i18n.i18n.translate('xpack.synthetics.monitorConfig.schedule.label', {
      defaultMessage: 'Every {value, number} {value, plural, one {hour} other {hours}}',
      values: {
        value: value / 60
      }
    });
  } else {
    return _i18n.i18n.translate('xpack.synthetics.monitorConfig.schedule.minutes.label', {
      defaultMessage: 'Every {value, number} {value, plural, one {minute} other {minutes}}',
      values: {
        value
      }
    });
  }
};
const getSchedules = monitorType => {
  const minutes = _constants.ALLOWED_SCHEDULES_IN_MINUTES.map(value => ({
    value,
    text: getScheduleContent(parseInt(value, 10))
  }));
  const allowSeconds = monitorType === _types.MonitorTypeEnum.HTTP || monitorType === _types.MonitorTypeEnum.TCP || monitorType === _types.MonitorTypeEnum.ICMP;
  if (allowSeconds) {
    const seconds = _constants.ALLOWED_SCHEDULES_IN_SECONDS.map(value => ({
      value,
      text: getScheduleContent(parseInt(value, 10), true)
    }));
    return [...seconds, ...minutes];
  } else {
    return minutes;
  }
};
const MONITOR_TYPE_CONFIG = exports.MONITOR_TYPE_CONFIG = {
  [_types.FormMonitorType.MULTISTEP]: {
    id: 'syntheticsMonitorTypeMultistep',
    'data-test-subj': 'syntheticsMonitorTypeMultistep',
    label: _i18n.i18n.translate('xpack.synthetics.monitorConfig.monitorType.multiStep.label', {
      defaultMessage: 'Multistep'
    }),
    value: _types.FormMonitorType.MULTISTEP,
    descriptionTitle: _i18n.i18n.translate('xpack.synthetics.monitorConfig.monitorType.multiStep.title', {
      defaultMessage: 'Multistep Browser Journey'
    }),
    description: _i18n.i18n.translate('xpack.synthetics.monitorConfig.monitorType.multiStep.description', {
      defaultMessage: 'Navigate through multiple steps or pages to test key user flows from a real browser.'
    }),
    link: 'https://www.elastic.co/guide/en/observability/current/synthetics-journeys.html',
    icon: 'videoPlayer',
    beta: false
  },
  [_types.FormMonitorType.SINGLE]: {
    id: 'syntheticsMonitorTypeSingle',
    'data-test-subj': 'syntheticsMonitorTypeSingle',
    label: _i18n.i18n.translate('xpack.synthetics.monitorConfig.monitorType.singlePage.label', {
      defaultMessage: 'Single Page'
    }),
    value: _types.FormMonitorType.SINGLE,
    descriptionTitle: _i18n.i18n.translate('xpack.synthetics.monitorConfig.monitorType.singlePage.title', {
      defaultMessage: 'Single Page Browser Test'
    }),
    description: _i18n.i18n.translate('xpack.synthetics.monitorConfig.monitorType.singlePage.description', {
      defaultMessage: 'Test a single page load including all objects on the page from a real web browser.'
    }),
    link: 'https://www.elastic.co/guide/en/observability/current/synthetics-journeys.html',
    icon: 'videoPlayer',
    beta: false
  },
  [_types.FormMonitorType.HTTP]: {
    id: 'syntheticsMonitorTypeHTTP',
    'data-test-subj': 'syntheticsMonitorTypeHTTP',
    label: _i18n.i18n.translate('xpack.synthetics.monitorConfig.monitorType.http.label', {
      defaultMessage: 'HTTP Ping'
    }),
    value: _types.FormMonitorType.HTTP,
    descriptionTitle: _i18n.i18n.translate('xpack.synthetics.monitorConfig.monitorType.http.title', {
      defaultMessage: 'HTTP Ping'
    }),
    description: _i18n.i18n.translate('xpack.synthetics.monitorConfig.monitorType.http.description', {
      defaultMessage: 'A lightweight API check to validate the availability of a web service or endpoint.'
    }),
    link: 'https://elastic.co/guide/en/observability/current/synthetics-lightweight.html',
    icon: 'online',
    beta: false
  },
  [_types.FormMonitorType.TCP]: {
    id: 'syntheticsMonitorTypeTCP',
    'data-test-subj': 'syntheticsMonitorTypeTCP',
    label: _i18n.i18n.translate('xpack.synthetics.monitorConfig.monitorType.tcp.label', {
      defaultMessage: 'TCP Ping'
    }),
    value: _types.FormMonitorType.TCP,
    descriptionTitle: _i18n.i18n.translate('xpack.synthetics.monitorConfig.monitorType.tcp.title', {
      defaultMessage: 'TCP Ping'
    }),
    description: _i18n.i18n.translate('xpack.synthetics.monitorConfig.monitorType.tcp.description', {
      defaultMessage: 'A lightweight API check to validate the availability of a web service or endpoint.'
    }),
    link: 'https://www.elastic.co/guide/en/observability/current/synthetics-lightweight.html',
    icon: 'online',
    beta: false
  },
  [_types.FormMonitorType.ICMP]: {
    id: 'syntheticsMonitorTypeICMP',
    'data-test-subj': 'syntheticsMonitorTypeICMP',
    label: _i18n.i18n.translate('xpack.synthetics.monitorConfig.monitorType.icmp.label', {
      defaultMessage: 'ICMP Ping'
    }),
    value: _types.FormMonitorType.ICMP,
    descriptionTitle: _i18n.i18n.translate('xpack.synthetics.monitorConfig.monitorType.icmp.title', {
      defaultMessage: 'ICMP Ping'
    }),
    description: _i18n.i18n.translate('xpack.synthetics.monitorConfig.monitorType.icmp.description', {
      defaultMessage: 'A lightweight API check to validate the availability of a web service or endpoint.'
    }),
    link: 'https://www.elastic.co/guide/en/observability/current/synthetics-lightweight.html',
    icon: 'online',
    beta: false
  }
};
const FIELD = readOnly => {
  var _getDocLinks, _getDocLinks$links, _getDocLinks$links$ob;
  return {
    [_types.ConfigKey.FORM_MONITOR_TYPE]: {
      fieldKey: _types.ConfigKey.FORM_MONITOR_TYPE,
      required: true,
      component: _field_wrappers.MonitorTypeRadioGroup,
      ariaLabel: _i18n.i18n.translate('xpack.synthetics.monitorConfig.monitorType.label', {
        defaultMessage: 'Monitor type'
      }),
      controlled: true,
      props: ({
        field,
        reset,
        space
      }) => ({
        onChange: (_, monitorType) => {
          const defaultFields = (0, _defaults.getDefaultFormFields)(space)[monitorType];
          reset(defaultFields);
        },
        selectedOption: field === null || field === void 0 ? void 0 : field.value,
        options: Object.values(MONITOR_TYPE_CONFIG)
      }),
      validation: () => ({
        required: true
      })
    },
    [`urls__single`]: {
      fieldKey: _types.ConfigKey.URLS,
      required: true,
      component: _field_wrappers.FieldText,
      label: _i18n.i18n.translate('xpack.synthetics.monitorConfig.urlsSingle.label', {
        defaultMessage: 'Website URL'
      }),
      helpText: _i18n.i18n.translate('xpack.synthetics.monitorConfig.urlsSingle.helpText', {
        defaultMessage: 'For example, https://www.elastic.co.'
      }),
      controlled: true,
      dependencies: [_types.ConfigKey.NAME],
      props: ({
        setValue,
        dependenciesFieldMeta,
        isEdit,
        trigger
      }) => {
        return {
          'data-test-subj': 'syntheticsMonitorConfigURL',
          onChange: async event => {
            setValue(_types.ConfigKey.URLS, event.target.value, {
              shouldTouch: true
            });
            if (!dependenciesFieldMeta[_types.ConfigKey.NAME].isDirty && !isEdit) {
              setValue(_types.ConfigKey.NAME, event.target.value, {
                shouldTouch: true
              });
            }
            await trigger();
          },
          readOnly
        };
      }
    },
    [`urls__http`]: {
      fieldKey: _types.ConfigKey.URLS,
      required: true,
      component: _field_wrappers.FieldText,
      label: _i18n.i18n.translate('xpack.synthetics.monitorConfig.urls.label', {
        defaultMessage: 'URL'
      }),
      helpText: _i18n.i18n.translate('xpack.synthetics.monitorConfig.urls.helpText', {
        defaultMessage: 'For example, your service endpoint.'
      }),
      controlled: true,
      dependencies: [_types.ConfigKey.NAME],
      props: ({
        setValue,
        trigger,
        dependenciesFieldMeta,
        isEdit
      }) => {
        return {
          onChange: async event => {
            setValue(_types.ConfigKey.URLS, event.target.value, {
              shouldTouch: true
            });
            if (!dependenciesFieldMeta[_types.ConfigKey.NAME].isDirty && !isEdit) {
              setValue(_types.ConfigKey.NAME, event.target.value, {
                shouldTouch: true
              });
              await trigger();
            }
          },
          'data-test-subj': 'syntheticsMonitorConfigURL',
          readOnly
        };
      }
    },
    [`hosts__tcp`]: {
      fieldKey: _types.ConfigKey.HOSTS,
      required: true,
      component: _field_wrappers.FieldText,
      label: _i18n.i18n.translate('xpack.synthetics.monitorConfig.hostsTCP.label', {
        defaultMessage: 'Host:Port'
      }),
      controlled: true,
      dependencies: [_types.ConfigKey.NAME],
      props: ({
        setValue,
        trigger,
        dependenciesFieldMeta,
        isEdit
      }) => {
        return {
          onChange: async event => {
            setValue(_types.ConfigKey.HOSTS, event.target.value, {
              shouldTouch: true
            });
            if (!dependenciesFieldMeta[_types.ConfigKey.NAME].isDirty && !isEdit) {
              setValue(_types.ConfigKey.NAME, event.target.value, {
                shouldTouch: true
              });
            }
            await trigger();
          },
          'data-test-subj': 'syntheticsMonitorConfigHost',
          readOnly
        };
      }
    },
    [`hosts__icmp`]: {
      fieldKey: _types.ConfigKey.HOSTS,
      required: true,
      component: _field_wrappers.FieldText,
      label: _i18n.i18n.translate('xpack.synthetics.monitorConfig.hostsICMP.label', {
        defaultMessage: 'Host'
      }),
      controlled: true,
      dependencies: [_types.ConfigKey.NAME],
      props: ({
        setValue,
        trigger,
        dependenciesFieldMeta,
        isEdit
      }) => {
        return {
          onChange: async event => {
            setValue(_types.ConfigKey.HOSTS, event.target.value, {
              shouldTouch: true
            });
            if (!dependenciesFieldMeta[_types.ConfigKey.NAME].isDirty && !isEdit) {
              setValue(_types.ConfigKey.NAME, event.target.value, {
                shouldTouch: true
              });
            }
            await trigger();
          },
          'data-test-subj': 'syntheticsMonitorConfigHost',
          readOnly
        };
      }
    },
    [_types.ConfigKey.NAME]: {
      fieldKey: _types.ConfigKey.NAME,
      required: true,
      component: _field_wrappers.FieldText,
      controlled: true,
      label: _i18n.i18n.translate('xpack.synthetics.monitorConfig.name.label', {
        defaultMessage: 'Monitor name'
      }),
      helpText: _i18n.i18n.translate('xpack.synthetics.monitorConfig.name.helpText', {
        defaultMessage: 'Choose a name to help identify this monitor in the future.'
      }),
      dependencies: [_types.ConfigKey.URLS, _types.ConfigKey.HOSTS],
      customHook: value => ({
        fieldKey: 'nameAlreadyExists',
        func: _use_monitor_name.useMonitorName,
        params: {
          search: value
        },
        error: _i18n.i18n.translate('xpack.synthetics.monitorConfig.name.existsError', {
          defaultMessage: 'Monitor name already exists'
        })
      }),
      validation: () => ({
        validate: {
          notEmpty: value => !Boolean(value.trim()) ? _i18n.i18n.translate('xpack.synthetics.monitorConfig.name.error', {
            defaultMessage: 'Monitor name is required'
          }) : true
        }
      }),
      error: _i18n.i18n.translate('xpack.synthetics.monitorConfig.name.error', {
        defaultMessage: 'Monitor name is required'
      }),
      props: () => ({
        'data-test-subj': 'syntheticsMonitorConfigName',
        readOnly
      })
    },
    ['schedule.number']: {
      fieldKey: `schedule.number`,
      required: true,
      component: _field_wrappers.Select,
      label: _i18n.i18n.translate('xpack.synthetics.monitorConfig.frequency.label', {
        defaultMessage: 'Frequency'
      }),
      helpText: _i18n.i18n.translate('xpack.synthetics.monitorConfig.frequency.helpText', {
        defaultMessage: 'How often do you want to run this test? Higher frequencies will increase your total cost.'
      }),
      props: ({
        formState
      }) => {
        var _formState$defaultVal;
        return {
          'data-test-subj': 'syntheticsMonitorConfigSchedule',
          options: getSchedules((_formState$defaultVal = formState.defaultValues) === null || _formState$defaultVal === void 0 ? void 0 : _formState$defaultVal[_types.ConfigKey.MONITOR_TYPE]),
          disabled: readOnly
        };
      }
    },
    [_types.ConfigKey.LOCATIONS]: {
      fieldKey: _types.ConfigKey.LOCATIONS,
      required: true,
      controlled: true,
      component: _field_wrappers.ComboBox,
      label: _i18n.i18n.translate('xpack.synthetics.monitorConfig.locations.label', {
        defaultMessage: 'Locations'
      }),
      helpText: _i18n.i18n.translate('xpack.synthetics.monitorConfig.locations.helpText', {
        defaultMessage: 'Where do you want to run this test from? Additional locations will increase your total cost.'
      }),
      props: ({
        field,
        setValue,
        locations,
        trigger
      }) => {
        return {
          options: Object.values(locations).map(location => ({
            label: location.label,
            id: location.id,
            isServiceManaged: location.isServiceManaged || false,
            isInvalid: location.isInvalid,
            disabled: location.isInvalid
          })),
          selectedOptions: Object.values((field === null || field === void 0 ? void 0 : field.value) || {}).map(location => {
            var _ref, _locations$find;
            return {
              color: location.isInvalid || !locations.some(s => s.id === location.id) ? 'danger' : location.isServiceManaged ? 'default' : 'primary',
              label: (_ref = location.label || (locations === null || locations === void 0 ? void 0 : (_locations$find = locations.find(loc => location.id === loc.id)) === null || _locations$find === void 0 ? void 0 : _locations$find.label)) !== null && _ref !== void 0 ? _ref : location.id,
              id: location.id || '',
              isServiceManaged: location.isServiceManaged || false
            };
          }),
          'data-test-subj': 'syntheticsMonitorConfigLocations',
          onChange: async updatedValues => {
            const valuesToSave = updatedValues.map(({
              id,
              label,
              isServiceManaged
            }) => ({
              id,
              label,
              isServiceManaged
            }));
            setValue(_types.ConfigKey.LOCATIONS, valuesToSave);
            await trigger(_types.ConfigKey.LOCATIONS);
          },
          isDisabled: readOnly,
          renderOption: (option, searchValue) => {
            return /*#__PURE__*/_react.default.createElement(_eui.EuiToolTip, {
              anchorProps: {
                style: {
                  width: '100%'
                }
              },
              content: option.isInvalid ? _i18n.i18n.translate('xpack.synthetics.monitorConfig.locations.attachedPolicy', {
                defaultMessage: 'The attached agent policy for this location has been deleted.'
              }) : ''
            }, /*#__PURE__*/_react.default.createElement(_eui.EuiFlexGroup, {
              gutterSize: "s",
              alignItems: "center"
            }, /*#__PURE__*/_react.default.createElement(_eui.EuiFlexItem, null, /*#__PURE__*/_react.default.createElement(_eui.EuiHighlight, {
              search: searchValue
            }, option.label)), option.isInvalid && /*#__PURE__*/_react.default.createElement(_eui.EuiFlexItem, {
              grow: false
            }, /*#__PURE__*/_react.default.createElement(_eui.EuiBadge, {
              color: "danger"
            }, _i18n.i18n.translate('xpack.synthetics.monitorConfig.locations.invalid', {
              defaultMessage: 'Invalid'
            }))), !option.isServiceManaged && /*#__PURE__*/_react.default.createElement(_eui.EuiFlexItem, {
              grow: false
            }, /*#__PURE__*/_react.default.createElement(_eui.EuiBadge, {
              color: "primary"
            }, _i18n.i18n.translate('xpack.synthetics.monitorConfig.locations.private', {
              defaultMessage: 'Private'
            })))));
          }
        };
      }
    },
    [_types.ConfigKey.ENABLED]: {
      fieldKey: _types.ConfigKey.ENABLED,
      component: _field_wrappers.Switch,
      controlled: true,
      helpText: _i18n.i18n.translate('xpack.synthetics.monitorConfig.edit.enabled.label', {
        defaultMessage: `When disabled, the monitor doesn't run any tests. You can enable it at any time.`
      }),
      props: ({
        setValue,
        field,
        trigger,
        formState
      }) => {
        var _formState$defaultVal2;
        const isProjectMonitor = ((_formState$defaultVal2 = formState.defaultValues) === null || _formState$defaultVal2 === void 0 ? void 0 : _formState$defaultVal2[_types.ConfigKey.MONITOR_SOURCE_TYPE]) === _types.SourceType.PROJECT;
        return {
          id: 'syntheticsMontiorConfigIsEnabled',
          label: _i18n.i18n.translate('xpack.synthetics.monitorConfig.enabled.label', {
            defaultMessage: 'Enable Monitor'
          }),
          checked: (field === null || field === void 0 ? void 0 : field.value) || false,
          onChange: async event => {
            setValue(_types.ConfigKey.ENABLED, !!event.target.checked);
            await trigger(_types.ConfigKey.ENABLED);
          },
          'data-test-subj': 'syntheticsEnableSwitch',
          // enabled is an allowed field for read only
          disabled: !isProjectMonitor && readOnly
        };
      }
    },
    [_constants.AlertConfigKey.STATUS_ENABLED]: {
      fieldKey: _constants.AlertConfigKey.STATUS_ENABLED,
      component: _field_wrappers.Switch,
      controlled: true,
      props: ({
        setValue,
        field,
        trigger,
        formState
      }) => {
        var _formState$defaultVal3;
        const isProjectMonitor = ((_formState$defaultVal3 = formState.defaultValues) === null || _formState$defaultVal3 === void 0 ? void 0 : _formState$defaultVal3[_types.ConfigKey.MONITOR_SOURCE_TYPE]) === _types.SourceType.PROJECT;
        return {
          id: 'syntheticsMonitorConfigIsAlertEnabled',
          label: _i18n.i18n.translate('xpack.synthetics.monitorConfig.disabledAlerting.label', {
            defaultMessage: 'Enable status alerts on this monitor'
          }),
          checked: (field === null || field === void 0 ? void 0 : field.value) || false,
          onChange: async event => {
            setValue(_constants.AlertConfigKey.STATUS_ENABLED, !!event.target.checked);
            await trigger(_constants.AlertConfigKey.STATUS_ENABLED);
          },
          'data-test-subj': 'syntheticsAlertStatusSwitch',
          // alert config is an allowed field for read only
          disabled: !isProjectMonitor && readOnly
        };
      }
    },
    [_constants.AlertConfigKey.TLS_ENABLED]: {
      fieldKey: _constants.AlertConfigKey.TLS_ENABLED,
      component: _field_wrappers.Switch,
      controlled: true,
      props: ({
        setValue,
        field,
        trigger,
        formState
      }) => {
        var _formState$defaultVal4;
        const isProjectMonitor = ((_formState$defaultVal4 = formState.defaultValues) === null || _formState$defaultVal4 === void 0 ? void 0 : _formState$defaultVal4[_types.ConfigKey.MONITOR_SOURCE_TYPE]) === _types.SourceType.PROJECT;
        return {
          id: 'syntheticsMonitorConfigIsTlsAlertEnabled',
          label: _i18n.i18n.translate('xpack.synthetics.monitorConfig.create.alertTlsEnabled.label', {
            defaultMessage: 'Enable TLS alerts on this monitor.'
          }),
          checked: (field === null || field === void 0 ? void 0 : field.value) || false,
          onChange: async event => {
            setValue(_constants.AlertConfigKey.TLS_ENABLED, !!event.target.checked);
            await trigger(_constants.AlertConfigKey.TLS_ENABLED);
          },
          'data-test-subj': 'syntheticsAlertStatusSwitch',
          // alert config is an allowed field for read only
          disabled: !isProjectMonitor && readOnly
        };
      }
    },
    [_types.ConfigKey.TAGS]: {
      fieldKey: _types.ConfigKey.TAGS,
      component: _field_wrappers.FormattedComboBox,
      label: _i18n.i18n.translate('xpack.synthetics.monitorConfig.tags.label', {
        defaultMessage: 'Tags'
      }),
      helpText: _i18n.i18n.translate('xpack.synthetics.monitorConfig.tags.helpText', {
        defaultMessage: 'A list of tags that will be sent with each monitor event. Useful for searching and segmenting data.'
      }),
      controlled: true,
      props: ({
        field
      }) => ({
        selectedOptions: (field === null || field === void 0 ? void 0 : field.value) || [],
        isDisabled: readOnly
      })
    },
    [_types.ConfigKey.TIMEOUT]: {
      fieldKey: _types.ConfigKey.TIMEOUT,
      component: _field_wrappers.FieldNumber,
      label: _i18n.i18n.translate('xpack.synthetics.monitorConfig.timeout.label', {
        defaultMessage: 'Timeout in seconds'
      }),
      helpText: _i18n.i18n.translate('xpack.synthetics.monitorConfig.timeout.helpText', {
        defaultMessage: 'The total time allowed for testing the connection and exchanging data.'
      }),
      props: () => ({
        'data-test-subj': 'syntheticsMonitorConfigTimeout',
        min: 1,
        step: 'any',
        readOnly
      }),
      dependencies: [_types.ConfigKey.SCHEDULE],
      validation: ([schedule]) => ({
        validate: {
          validTimeout: value => {
            switch (true) {
              case value < 0:
                return _i18n.i18n.translate('xpack.synthetics.monitorConfig.timeout.greaterThan0Error', {
                  defaultMessage: 'Timeout must be greater than or equal to 0.'
                });
              case value > parseFloat(schedule.number) * 60:
                return _i18n.i18n.translate('xpack.synthetics.monitorConfig.timeout.scheduleError', {
                  defaultMessage: 'Timeout must be less than the monitor frequency.'
                });
              case !Boolean(`${value}`.match(_validation.FLOATS_ONLY)):
                return _i18n.i18n.translate('xpack.synthetics.monitorConfig.timeout.formatError', {
                  defaultMessage: 'Timeout is invalid.'
                });
              default:
                return true;
            }
          }
        }
      })
    },
    [_types.ConfigKey.APM_SERVICE_NAME]: {
      fieldKey: _types.ConfigKey.APM_SERVICE_NAME,
      component: _field_wrappers.FieldText,
      label: _i18n.i18n.translate('xpack.synthetics.monitorConfig.apmServiceName.label', {
        defaultMessage: 'APM service name'
      }),
      helpText: _i18n.i18n.translate('xpack.synthetics.monitorConfig.apmServiceName.helpText', {
        defaultMessage: 'Corresponds to the service.name ECS field from APM. Set this to enable integrations between APM and Synthetics data.'
      }),
      controlled: true,
      props: () => ({
        'data-test-subj': 'syntheticsMonitorConfigAPMServiceName',
        readOnly
      })
    },
    [_types.ConfigKey.NAMESPACE]: {
      fieldKey: _types.ConfigKey.NAMESPACE,
      component: _field_wrappers.FieldText,
      label: _i18n.i18n.translate('xpack.synthetics.monitorConfig.namespace.label', {
        defaultMessage: 'Data stream namespace'
      }),
      helpText: /*#__PURE__*/_react.default.createElement("span", null, _i18n.i18n.translate('xpack.synthetics.monitorConfig.namespace.helpText', {
        defaultMessage: "Change the default namespace. This setting changes the name of the monitor's data stream. "
      }), /*#__PURE__*/_react.default.createElement(_eui.EuiLink, {
        "data-test-subj": "syntheticsFIELDLearnMoreLink",
        href: "https://www.elastic.co/guide/en/fleet/current/data-streams.html",
        target: "_blank"
      }, _i18n.i18n.translate('xpack.synthetics.monitorConfig.namespace.learnMore', {
        defaultMessage: 'Learn more'
      }))),
      controlled: true,
      props: () => ({
        readOnly
      }),
      validation: () => ({
        validate: {
          validNamespace: namespace => (0, _common.isValidNamespace)(namespace).error
        }
      })
    },
    [_types.ConfigKey.MAX_REDIRECTS]: {
      fieldKey: _types.ConfigKey.MAX_REDIRECTS,
      component: _field_wrappers.FieldNumber,
      label: _i18n.i18n.translate('xpack.synthetics.monitorConfig.maxRedirects.label', {
        defaultMessage: 'Max redirects'
      }),
      helpText: _i18n.i18n.translate('xpack.synthetics.monitorConfig.maxRedirects.helpText', {
        defaultMessage: 'The total number of redirects to follow.'
      }),
      props: () => ({
        'data-test-subj': 'syntheticsMonitorConfigMaxRedirects',
        min: 0,
        max: 10,
        step: 1,
        readOnly
      }),
      validation: () => ({
        min: 0,
        max: 10,
        pattern: _validation.WHOLE_NUMBERS_ONLY
      }),
      error: _i18n.i18n.translate('xpack.synthetics.monitorConfig.maxRedirects.error', {
        defaultMessage: 'Max redirects is invalid.'
      })
    },
    [_types.ConfigKey.WAIT]: {
      fieldKey: _types.ConfigKey.WAIT,
      component: _field_wrappers.FieldNumber,
      label: _i18n.i18n.translate('xpack.synthetics.monitorConfig.wait.label', {
        defaultMessage: 'Wait'
      }),
      helpText: _i18n.i18n.translate('xpack.synthetics.monitorConfig.wait.helpText', {
        defaultMessage: 'The duration to wait before emitting another ICMP Echo Request if no response is received.'
      }),
      props: () => ({
        'data-test-subj': 'syntheticsMonitorConfigWait',
        min: 1,
        step: 1,
        readOnly
      }),
      validation: () => ({
        min: 1,
        pattern: _validation.WHOLE_NUMBERS_ONLY
      }),
      error: _i18n.i18n.translate('xpack.synthetics.monitorConfig.wait.error', {
        defaultMessage: 'Wait duration is invalid.'
      })
    },
    [_types.ConfigKey.USERNAME]: {
      fieldKey: _types.ConfigKey.USERNAME,
      component: _field_wrappers.FieldText,
      label: _i18n.i18n.translate('xpack.synthetics.monitorConfig.username.label', {
        defaultMessage: 'Username'
      }),
      helpText: _i18n.i18n.translate('xpack.synthetics.monitorConfig.username.helpText', {
        defaultMessage: 'Username for authenticating with the server.'
      }),
      props: () => ({
        readOnly
      })
    },
    [_types.ConfigKey.PASSWORD]: {
      fieldKey: _types.ConfigKey.PASSWORD,
      component: _field_wrappers.FieldPassword,
      label: _i18n.i18n.translate('xpack.synthetics.monitorConfig.password.label', {
        defaultMessage: 'Password'
      }),
      helpText: _i18n.i18n.translate('xpack.synthetics.monitorConfig.password.helpText', {
        defaultMessage: 'Password for authenticating with the server.'
      }),
      props: () => ({
        readOnly
      })
    },
    [_types.ConfigKey.PROXY_URL]: {
      fieldKey: _types.ConfigKey.PROXY_URL,
      component: _field_wrappers.FieldText,
      label: _i18n.i18n.translate('xpack.synthetics.monitorConfig.proxyUrl.label', {
        defaultMessage: 'Proxy URL'
      }),
      helpText: _i18n.i18n.translate('xpack.synthetics.monitorConfig.proxyUrl.helpText', {
        defaultMessage: 'HTTP proxy URL'
      }),
      props: () => ({
        readOnly
      })
    },
    [_types.ConfigKey.REQUEST_METHOD_CHECK]: {
      fieldKey: _types.ConfigKey.REQUEST_METHOD_CHECK,
      component: _field_wrappers.Select,
      label: _i18n.i18n.translate('xpack.synthetics.monitorConfig.requestMethod.label', {
        defaultMessage: 'Request method'
      }),
      helpText: _i18n.i18n.translate('xpack.synthetics.monitorConfig.requestMethod.helpText', {
        defaultMessage: 'The HTTP method to use.'
      }),
      props: () => ({
        options: Object.keys(_types.HTTPMethod).map(method => ({
          value: method,
          text: method
        })),
        disabled: readOnly
      })
    },
    [_types.ConfigKey.REQUEST_HEADERS_CHECK]: {
      fieldKey: _types.ConfigKey.REQUEST_HEADERS_CHECK,
      component: _field_wrappers.HeaderField,
      label: _i18n.i18n.translate('xpack.synthetics.monitorConfig.requestHeaders.label', {
        defaultMessage: 'Request headers'
      }),
      helpText: _i18n.i18n.translate('xpack.synthetics.monitorConfig.requestHeaders.helpText', {
        defaultMessage: 'A dictionary of additional HTTP headers to send. By default the client will set the User-Agent header to identify itself.'
      }),
      controlled: true,
      validation: () => ({
        validate: {
          validHeaders: headers => (0, _validation.validateHeaders)(headers) ? _i18n.i18n.translate('xpack.synthetics.monitorConfig.requestHeaders.error', {
            defaultMessage: 'Header key must be a valid HTTP token.'
          }) : true
        }
      }),
      dependencies: [_types.ConfigKey.REQUEST_BODY_CHECK],
      error: _i18n.i18n.translate('xpack.synthetics.monitorConfig.requestHeaders.error', {
        defaultMessage: 'Header key must be a valid HTTP token.'
      }),
      // contentMode is optional for other implementations, but required for this implementation of this field
      props: ({
        dependencies
      }) => {
        const [requestBody] = dependencies;
        return {
          'data-test-subj': 'syntheticsHeaderFieldRequestHeaders',
          readOnly,
          contentMode: !!(requestBody !== null && requestBody !== void 0 && requestBody.value) ? requestBody.type : undefined
        };
      }
    },
    [_types.ConfigKey.REQUEST_BODY_CHECK]: {
      fieldKey: _types.ConfigKey.REQUEST_BODY_CHECK,
      component: _field_wrappers.RequestBodyField,
      label: _i18n.i18n.translate('xpack.synthetics.monitorConfig.requestBody.label', {
        defaultMessage: 'Request body'
      }),
      helpText: _i18n.i18n.translate('xpack.synthetics.monitorConfig.requestBody.helpText', {
        defaultMessage: 'Request body content.'
      }),
      controlled: true,
      props: () => ({
        readOnly
      })
    },
    [_types.ConfigKey.RESPONSE_HEADERS_INDEX]: {
      fieldKey: _types.ConfigKey.RESPONSE_HEADERS_INDEX,
      component: _field_wrappers.Checkbox,
      helpText: /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, /*#__PURE__*/_react.default.createElement(_i18nReact.FormattedMessage, {
        id: "xpack.synthetics.monitorConfig.indexResponseHeaders.helpText",
        defaultMessage: "Controls the indexing of the HTTP response headers to "
      }), /*#__PURE__*/_react.default.createElement(_eui.EuiCode, null, 'http.response.body.headers')),
      props: () => ({
        label: _i18n.i18n.translate('xpack.synthetics.monitorConfig.indexResponseHeaders.label', {
          defaultMessage: 'Index response headers'
        }),
        id: 'syntheticsMonitorConfigResponseHeadersIndex',
        // checkbox needs an id or it won't work,
        disabled: readOnly
      }),
      controlled: true
    },
    [_types.ConfigKey.RESPONSE_BODY_INDEX]: {
      fieldKey: _types.ConfigKey.RESPONSE_BODY_INDEX,
      component: _field_wrappers.ResponseBodyIndexField,
      helpText: /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, /*#__PURE__*/_react.default.createElement(_i18nReact.FormattedMessage, {
        id: "xpack.synthetics.monitorConfig.indexResponseBody.helpText",
        defaultMessage: "Controls the indexing of the HTTP response body contents to"
      }), /*#__PURE__*/_react.default.createElement(_eui.EuiCode, null, 'http.response.body.contents')),
      props: () => ({
        readOnly
      }),
      controlled: true
    },
    [_types.ConfigKey.RESPONSE_STATUS_CHECK]: {
      fieldKey: _types.ConfigKey.RESPONSE_STATUS_CHECK,
      component: _field_wrappers.FormattedComboBox,
      label: _i18n.i18n.translate('xpack.synthetics.monitorConfig.responseStatusCheck.label', {
        defaultMessage: 'Response status equals'
      }),
      helpText: _i18n.i18n.translate('xpack.synthetics.monitorConfig.responseStatusCheck.helpText', {
        defaultMessage: 'A list of expected status codes. Press enter to add a new code. 4xx and 5xx codes are considered down by default. Other codes are considered up.'
      }),
      controlled: true,
      props: ({
        field
      }) => ({
        selectedOptions: field === null || field === void 0 ? void 0 : field.value,
        isDisabled: readOnly
      }),
      validation: () => ({
        validate: {
          validResponseStatusCheck: value => {
            const validateFn = _validation.validate[_types.MonitorTypeEnum.HTTP][_types.ConfigKey.RESPONSE_STATUS_CHECK];
            if (validateFn) {
              return !validateFn({
                [_types.ConfigKey.RESPONSE_STATUS_CHECK]: value
              });
            }
          }
        }
      }),
      error: _i18n.i18n.translate('xpack.synthetics.monitorConfig.responseStatusCheck.error', {
        defaultMessage: 'Status code must contain digits only.'
      })
    },
    [_types.ConfigKey.RESPONSE_HEADERS_CHECK]: {
      fieldKey: _types.ConfigKey.RESPONSE_HEADERS_CHECK,
      component: _field_wrappers.HeaderField,
      label: _i18n.i18n.translate('xpack.synthetics.monitorConfig.responseHeadersCheck.label', {
        defaultMessage: 'Response headers contain'
      }),
      helpText: _i18n.i18n.translate('xpack.synthetics.monitorConfig.responseHeadersCheck.helpText', {
        defaultMessage: 'A list of expected response headers.'
      }),
      controlled: true,
      validation: () => ({
        validate: {
          validHeaders: headers => (0, _validation.validateHeaders)(headers) ? _i18n.i18n.translate('xpack.synthetics.monitorConfig.responseHeadersCheck.error', {
            defaultMessage: 'Header key must be a valid HTTP token.'
          }) : true
        }
      }),
      props: () => ({
        'data-test-subj': 'syntheticsHeaderFieldResponseHeaders',
        readOnly
      })
    },
    [_types.ConfigKey.RESPONSE_BODY_CHECK_POSITIVE]: {
      fieldKey: _types.ConfigKey.RESPONSE_BODY_CHECK_POSITIVE,
      component: _field_wrappers.FormattedComboBox,
      label: _i18n.i18n.translate('xpack.synthetics.monitorConfig.responseBodyCheck.label', {
        defaultMessage: 'Response body contains'
      }),
      helpText: _i18n.i18n.translate('xpack.synthetics.monitorConfig.responseBodyCheck.helpText', {
        defaultMessage: 'A list of regular expressions to match the body output. Press enter to add a new expression. Only a single expression needs to match.'
      }),
      controlled: true,
      props: ({
        field
      }) => ({
        selectedOptions: field === null || field === void 0 ? void 0 : field.value,
        isDisabled: readOnly
      })
    },
    [_types.ConfigKey.RESPONSE_BODY_CHECK_NEGATIVE]: {
      fieldKey: _types.ConfigKey.RESPONSE_BODY_CHECK_NEGATIVE,
      component: _field_wrappers.FormattedComboBox,
      label: _i18n.i18n.translate('xpack.synthetics.monitorConfig.responseBodyCheckNegative.label', {
        defaultMessage: 'Response body does not contain'
      }),
      helpText: _i18n.i18n.translate('xpack.synthetics.monitorConfig.responseBodyCheckNegative.helpText', {
        defaultMessage: 'A list of regular expressions to match the the body output negatively. Press enter to add a new expression. Return match failed if single expression matches.'
      }),
      controlled: true,
      props: ({
        field
      }) => ({
        selectedOptions: field === null || field === void 0 ? void 0 : field.value,
        isDisabled: readOnly
      })
    },
    [_types.ConfigKey.RESPONSE_RECEIVE_CHECK]: {
      fieldKey: _types.ConfigKey.RESPONSE_RECEIVE_CHECK,
      component: _field_wrappers.FieldText,
      label: _i18n.i18n.translate('xpack.synthetics.monitorConfig.responseReceiveCheck.label', {
        defaultMessage: 'Response contains'
      }),
      helpText: _i18n.i18n.translate('xpack.synthetics.monitorConfig.responseReceiveCheck.helpText', {
        defaultMessage: 'The expected remote host response.'
      }),
      props: () => ({
        readOnly
      })
    },
    ['proxy_url__tcp']: {
      fieldKey: _types.ConfigKey.PROXY_URL,
      component: _field_wrappers.FieldText,
      label: _i18n.i18n.translate('xpack.synthetics.monitorConfig.proxyURLTCP.label', {
        defaultMessage: 'Proxy URL'
      }),
      helpText: _i18n.i18n.translate('xpack.synthetics.monitorConfig.proxyURLTCP.helpText', {
        defaultMessage: 'The URL of the SOCKS5 proxy to use when connecting to the server. The value must be a URL with a scheme of socks5://.'
      }),
      props: () => ({
        readOnly
      })
    },
    [_types.ConfigKey.REQUEST_SEND_CHECK]: {
      fieldKey: _types.ConfigKey.REQUEST_SEND_CHECK,
      component: _field_wrappers.FieldText,
      label: _i18n.i18n.translate('xpack.synthetics.monitorConfig.requestSendCheck.label', {
        defaultMessage: 'Request payload'
      }),
      helpText: _i18n.i18n.translate('xpack.synthetics.monitorConfig.requestSendCheck.helpText', {
        defaultMessage: 'A payload string to send to the remote host.'
      }),
      props: () => ({
        readOnly
      })
    },
    ['source.inline']: {
      fieldKey: 'source.inline',
      required: true,
      component: _field_wrappers.Source,
      ariaLabel: _i18n.i18n.translate('xpack.synthetics.monitorConfig.monitorScript.label', {
        defaultMessage: 'Monitor script'
      }),
      controlled: true,
      props: ({
        isEdit
      }) => ({
        isEditFlow: isEdit
      }),
      validation: () => ({
        validate: {
          validScript: value => {
            var _value$script, _value$script2, _value$script3, _value$script4;
            if (!value.script) {
              return _i18n.i18n.translate('xpack.synthetics.monitorConfig.monitorScript.error', {
                defaultMessage: 'Monitor script is required'
              });
            }

            // return false if script contains import or require statement
            if ((_value$script = value.script) !== null && _value$script !== void 0 && _value$script.includes('import ') || (_value$script2 = value.script) !== null && _value$script2 !== void 0 && _value$script2.includes('require(') || (_value$script3 = value.script) !== null && _value$script3 !== void 0 && _value$script3.includes('journey(')) {
              return _i18n.i18n.translate('xpack.synthetics.monitorConfig.monitorScript.invalid', {
                defaultMessage: 'Monitor script is invalid. Inline scripts cannot be full journey scripts, they may only contain step definitions.'
              });
            }
            // should contain at least one step
            if (value.script && !((_value$script4 = value.script) !== null && _value$script4 !== void 0 && _value$script4.includes('step('))) {
              return _i18n.i18n.translate('xpack.synthetics.monitorConfig.monitorScript.invalid.oneStep', {
                defaultMessage: 'Monitor script is invalid. Inline scripts must contain at least one step definition.'
              });
            }
            return true;
          }
        }
      })
    },
    [_types.ConfigKey.PARAMS]: {
      fieldKey: _types.ConfigKey.PARAMS,
      label: _i18n.i18n.translate('xpack.synthetics.monitorConfig.params.label', {
        defaultMessage: 'Parameters'
      }),
      controlled: true,
      component: _field_wrappers.JSONEditor,
      props: () => ({
        id: 'syntheticsMonitorConfigParams',
        height: '100px',
        ariaLabel: _i18n.i18n.translate('xpack.synthetics.monitorConfig.paramsAria.label', {
          defaultMessage: 'Monitor params code editor'
        }),
        readOnly
      }),
      helpText: /*#__PURE__*/_react.default.createElement(_i18nReact.FormattedMessage, {
        id: "xpack.synthetics.monitorConfig.params.helpText",
        defaultMessage: "Use JSON to define parameters that can be referenced in your script with {paramsValue}",
        values: {
          paramsValue: /*#__PURE__*/_react.default.createElement(_eui.EuiCode, null, 'params.value')
        }
      }),
      validation: () => ({
        validate: {
          validParams: value => {
            const validateFn = _validation.validate[_types.MonitorTypeEnum.BROWSER][_types.ConfigKey.PARAMS];
            if (validateFn) {
              return validateFn({
                [_types.ConfigKey.PARAMS]: value
              }) ? _i18n.i18n.translate('xpack.synthetics.monitorConfig.params.error', {
                defaultMessage: 'Invalid JSON format'
              }) : true;
            }
            return true;
          }
        }
      })
    },
    isTLSEnabled: {
      fieldKey: 'isTLSEnabled',
      component: _field_wrappers.Switch,
      controlled: true,
      props: ({
        setValue,
        field
      }) => {
        return {
          id: 'syntheticsMontiorConfigIsTLSEnabledSwitch',
          label: _i18n.i18n.translate('xpack.synthetics.monitorConfig.customTLS.label', {
            defaultMessage: 'Use custom TLS configuration'
          }),
          checked: (field === null || field === void 0 ? void 0 : field.value) || false,
          onChange: event => {
            setValue('isTLSEnabled', event.target.checked);
          },
          disabled: readOnly
        };
      }
    },
    [_types.ConfigKey.TLS_VERIFICATION_MODE]: {
      fieldKey: _types.ConfigKey.TLS_VERIFICATION_MODE,
      component: _field_wrappers.Select,
      label: _i18n.i18n.translate('xpack.synthetics.monitorConfig.verificationMode.label', {
        defaultMessage: 'Verification mode'
      }),
      helpText: _i18n.i18n.translate('xpack.synthetics.monitorConfig.verificationMode.helpText', {
        defaultMessage: 'Verifies that the provided certificate is signed by a trusted authority (CA) and also verifies that the server’s hostname (or IP address) matches the names identified within the certificate. If the Subject Alternative Name is empty, it returns an error.'
      }),
      hidden: dependencies => {
        const [isTLSEnabled] = dependencies;
        return !Boolean(isTLSEnabled);
      },
      dependencies: ['isTLSEnabled'],
      props: () => ({
        options: Object.values(_types.VerificationMode).map(method => ({
          value: method,
          text: method.toUpperCase()
        })),
        disabled: readOnly
      })
    },
    [_types.ConfigKey.TLS_VERSION]: {
      fieldKey: _types.ConfigKey.TLS_VERSION,
      component: _field_wrappers.ComboBox,
      label: _i18n.i18n.translate('xpack.synthetics.monitorConfig.tlsVersion.label', {
        defaultMessage: 'Supported TLS protocols'
      }),
      controlled: true,
      hidden: dependencies => {
        const [isTLSEnabled] = dependencies;
        return !Boolean(isTLSEnabled);
      },
      dependencies: ['isTLSEnabled'],
      props: ({
        field,
        setValue,
        trigger
      }) => {
        return {
          options: Object.values(_types.TLSVersion).map(version => ({
            label: version
          })),
          selectedOptions: Object.values((field === null || field === void 0 ? void 0 : field.value) || []).map(version => ({
            label: version
          })),
          onChange: async updatedValues => {
            setValue(_types.ConfigKey.TLS_VERSION, updatedValues.map(option => option.label));
            await trigger(_types.ConfigKey.TLS_VERSION);
          },
          isDisabled: readOnly
        };
      }
    },
    [_types.ConfigKey.TLS_CERTIFICATE_AUTHORITIES]: {
      fieldKey: _types.ConfigKey.TLS_CERTIFICATE_AUTHORITIES,
      component: _field_wrappers.TextArea,
      label: _i18n.i18n.translate('xpack.synthetics.monitorConfig.certificateAuthorities.label', {
        defaultMessage: 'Certificate authorities'
      }),
      helpText: _i18n.i18n.translate('xpack.synthetics.monitorConfig.certificateAuthorities.helpText', {
        defaultMessage: 'PEM-formatted custom certificate authorities.'
      }),
      hidden: dependencies => {
        const [isTLSEnabled] = dependencies;
        return !Boolean(isTLSEnabled);
      },
      dependencies: ['isTLSEnabled'],
      props: () => ({
        readOnly
      })
    },
    [_types.ConfigKey.TLS_CERTIFICATE]: {
      fieldKey: _types.ConfigKey.TLS_CERTIFICATE,
      component: _field_wrappers.TextArea,
      label: _i18n.i18n.translate('xpack.synthetics.monitorConfig.clientCertificate.label', {
        defaultMessage: 'Client certificate'
      }),
      helpText: _i18n.i18n.translate('xpack.synthetics.monitorConfig.clientCertificate.helpText', {
        defaultMessage: 'PEM-formatted certificate for TLS client authentication.'
      }),
      hidden: dependencies => {
        const [isTLSEnabled] = dependencies;
        return !Boolean(isTLSEnabled);
      },
      dependencies: ['isTLSEnabled'],
      props: () => ({
        readOnly
      })
    },
    [_types.ConfigKey.TLS_KEY]: {
      fieldKey: _types.ConfigKey.TLS_KEY,
      component: _field_wrappers.TextArea,
      label: _i18n.i18n.translate('xpack.synthetics.monitorConfig.clientKey.label', {
        defaultMessage: 'Client key'
      }),
      helpText: _i18n.i18n.translate('xpack.synthetics.monitorConfig.clientKey.helpText', {
        defaultMessage: 'PEM-formatted certificate key for TLS client authentication.'
      }),
      hidden: dependencies => {
        const [isTLSEnabled] = dependencies;
        return !Boolean(isTLSEnabled);
      },
      dependencies: ['isTLSEnabled'],
      props: () => ({
        readOnly
      })
    },
    [_types.ConfigKey.TLS_KEY_PASSPHRASE]: {
      fieldKey: _types.ConfigKey.TLS_KEY_PASSPHRASE,
      component: _field_wrappers.FieldPassword,
      label: _i18n.i18n.translate('xpack.synthetics.monitorConfig.clientKeyPassphrase.label', {
        defaultMessage: 'Client key passphrase'
      }),
      helpText: _i18n.i18n.translate('xpack.synthetics.monitorConfig.clientKeyPassphrase.helpText', {
        defaultMessage: 'Certificate key passphrase for TLS client authentication.'
      }),
      hidden: dependencies => {
        const [isTLSEnabled] = dependencies;
        return !Boolean(isTLSEnabled);
      },
      dependencies: ['isTLSEnabled'],
      props: () => ({
        readOnly
      })
    },
    [_types.ConfigKey.SCREENSHOTS]: {
      fieldKey: _types.ConfigKey.SCREENSHOTS,
      component: _field_wrappers.ButtonGroup,
      label: _i18n.i18n.translate('xpack.synthetics.monitorConfig.screenshotOptions.label', {
        defaultMessage: 'Screenshot options'
      }),
      helpText: _i18n.i18n.translate('xpack.synthetics.monitorConfig.screenshotOptions.helpText', {
        defaultMessage: 'Set this option to manage the screenshots captured by the synthetics agent.'
      }),
      controlled: true,
      props: ({
        field,
        setValue
      }) => ({
        idSelected: field === null || field === void 0 ? void 0 : field.value,
        onChange: option => setValue(_types.ConfigKey.SCREENSHOTS, option),
        options: Object.values(_types.ScreenshotOption).map(option => ({
          id: option,
          label: option.replace(/-/g, ' ')
        })),
        legend: _i18n.i18n.translate('xpack.synthetics.monitorConfig.screenshotOptions.label', {
          defaultMessage: 'Screenshot options'
        }),
        css: {
          textTransform: 'capitalize'
        },
        isDisabled: readOnly
      })
    },
    [_types.ConfigKey.TEXT_ASSERTION]: {
      fieldKey: _types.ConfigKey.TEXT_ASSERTION,
      component: _field_wrappers.FieldText,
      label: _i18n.i18n.translate('xpack.synthetics.monitorConfig.textAssertion.label', {
        defaultMessage: 'Text assertion'
      }),
      required: false,
      helpText: _i18n.i18n.translate('xpack.synthetics.monitorConfig.textAssertion.helpText', {
        defaultMessage: 'Consider the page loaded when the specified text is rendered.'
      }),
      validation: () => ({
        required: false
      }),
      props: () => ({
        readOnly
      })
    },
    [_types.ConfigKey.THROTTLING_CONFIG]: {
      fieldKey: _types.ConfigKey.THROTTLING_CONFIG,
      component: _field_wrappers.ThrottlingWrapper,
      label: /*#__PURE__*/_react.default.createElement(_i18nReact.FormattedMessage, {
        id: "xpack.synthetics.monitorConfig.throttlingDisabled.label",
        defaultMessage: "Connection profile ( {icon} Important information about throttling: {link})",
        values: {
          icon: /*#__PURE__*/_react.default.createElement(_eui.EuiIcon, {
            type: "alert",
            color: "warning",
            size: "s"
          }),
          link: /*#__PURE__*/_react.default.createElement(_eui.EuiLink, {
            "data-test-subj": "syntheticsFIELDNoticeLink",
            href: 'https://github.com/elastic/synthetics/blob/main/docs/throttling.md',
            target: "_blank"
          }, _i18n.i18n.translate('xpack.synthetics.monitorConfig.throttlingDisabled.link', {
            defaultMessage: 'notice'
          }))
        }
      }),
      required: true,
      controlled: true,
      helpText: _i18n.i18n.translate('xpack.synthetics.monitorConfig.throttling.helpText', {
        defaultMessage: 'Simulate network throttling (download, upload, latency).'
      }),
      props: ({
        formState
      }) => {
        var _formState$defaultVal5;
        return {
          options: _throttling_config_field.PROFILE_OPTIONS,
          readOnly,
          disabled: false,
          initialValue: (_formState$defaultVal5 = formState.defaultValues) === null || _formState$defaultVal5 === void 0 ? void 0 : _formState$defaultVal5[_types.ConfigKey.THROTTLING_CONFIG]
        };
      },
      validation: () => ({
        required: true
      })
    },
    [_types.ConfigKey.PLAYWRIGHT_OPTIONS]: {
      fieldKey: _types.ConfigKey.PLAYWRIGHT_OPTIONS,
      component: _field_wrappers.JSONEditor,
      label: _i18n.i18n.translate('xpack.synthetics.monitorConfig.playwrightOptions.label', {
        defaultMessage: 'Playwright options'
      }),
      helpText: /*#__PURE__*/_react.default.createElement("span", null, _i18n.i18n.translate('xpack.synthetics.monitorConfig.playwrightOptions.helpText', {
        defaultMessage: 'Configure Playwright agent with custom options. '
      }), /*#__PURE__*/_react.default.createElement(_eui.EuiLink, {
        "data-test-subj": "syntheticsFIELDLearnMoreLink",
        href: (_getDocLinks = (0, _kibana_services.getDocLinks)()) === null || _getDocLinks === void 0 ? void 0 : (_getDocLinks$links = _getDocLinks.links) === null || _getDocLinks$links === void 0 ? void 0 : (_getDocLinks$links$ob = _getDocLinks$links.observability) === null || _getDocLinks$links$ob === void 0 ? void 0 : _getDocLinks$links$ob.syntheticsCommandReference,
        target: "_blank"
      }, _i18n.i18n.translate('xpack.synthetics.monitorConfig.playwrightOptions.learnMore', {
        defaultMessage: 'Learn more'
      }))),
      ariaLabel: _i18n.i18n.translate('xpack.synthetics.monitorConfig.playwrightOptions.codeEditor.json.ariaLabel', {
        defaultMessage: 'Playwright options JSON code editor'
      }),
      controlled: true,
      required: false,
      props: () => ({
        ariaLabel: _i18n.i18n.translate('xpack.synthetics.monitorConfig.playwrightOptions.codeEditor.json.ariaLabel', {
          defaultMessage: 'Playwright options JSON code editor'
        }),
        readOnly,
        id: 'syntheticsPlaywrightOptionsJSONCodeEditor'
      }),
      validation: () => ({
        validate: {
          validPlaywrightOptions: value => {
            const validateFn = _validation.validate[_types.MonitorTypeEnum.BROWSER][_types.ConfigKey.PLAYWRIGHT_OPTIONS];
            if (validateFn) {
              return validateFn({
                [_types.ConfigKey.PLAYWRIGHT_OPTIONS]: value
              }) ? _i18n.i18n.translate('xpack.synthetics.monitorConfig.playwrightOptions.error', {
                defaultMessage: 'Invalid JSON format'
              }) : true;
            }
            return true;
          }
        }
      })
    },
    [_types.ConfigKey.IGNORE_HTTPS_ERRORS]: {
      fieldKey: _types.ConfigKey.IGNORE_HTTPS_ERRORS,
      component: _field_wrappers.Switch,
      controlled: true,
      helpText: /*#__PURE__*/_react.default.createElement("span", null, _i18n.i18n.translate('xpack.synthetics.monitorConfig.ignoreHttpsErrors.helpText', {
        defaultMessage: 'Turns off TLS/SSL validation in the synthetics browser. This is useful for testing sites that use self-signed certificates.'
      })),
      props: ({
        setValue
      }) => ({
        id: 'syntheticsMontiorConfigIgnoreHttpsErrors',
        label: _i18n.i18n.translate('xpack.synthetics.monitorConfig.ignoreHttpsErrors.label', {
          defaultMessage: 'Ignore HTTPS errors'
        }),
        onChange: event => {
          setValue(_types.ConfigKey.IGNORE_HTTPS_ERRORS, !!event.target.checked);
        },
        disabled: readOnly
      })
    },
    [_types.ConfigKey.SYNTHETICS_ARGS]: {
      fieldKey: _types.ConfigKey.SYNTHETICS_ARGS,
      component: _field_wrappers.ComboBox,
      controlled: true,
      label: _i18n.i18n.translate('xpack.synthetics.monitorConfig.syntheticsArgs.label', {
        defaultMessage: 'Synthetics args'
      }),
      helpText: /*#__PURE__*/_react.default.createElement("span", null, _i18n.i18n.translate('xpack.synthetics.monitorConfig.syntheticsArgs.helpText', {
        defaultMessage: 'Extra arguments to pass to the synthetics agent package. Takes a list of strings. This is useful in rare scenarios, and should not ordinarily need to be set.'
      })),
      props: ({
        setValue,
        field,
        trigger
      }) => ({
        id: 'syntheticsMontiorConfigSyntheticsArgs',
        selectedOptions: Object.values((field === null || field === void 0 ? void 0 : field.value) || []).map(arg => ({
          label: arg
        })),
        onChange: async updatedValues => {
          setValue(_types.ConfigKey.SYNTHETICS_ARGS, updatedValues.map(option => option.label));
          await trigger(_types.ConfigKey.SYNTHETICS_ARGS);
        },
        onCreateOption: newValue => {
          setValue(_types.ConfigKey.SYNTHETICS_ARGS, [...((field === null || field === void 0 ? void 0 : field.value) || []), newValue]);
        },
        isDisabled: readOnly
      })
    },
    [_types.ConfigKey.MODE]: {
      fieldKey: _types.ConfigKey.MODE,
      component: _field_wrappers.Select,
      label: _i18n.i18n.translate('xpack.synthetics.monitorConfig.mode.label', {
        defaultMessage: 'Mode'
      }),
      helpText: /*#__PURE__*/_react.default.createElement(_i18nReact.FormattedMessage, {
        id: "xpack.synthetics.monitorConfig.syntheticsArgs.mode.helpText",
        defaultMessage: "If {any}, the monitor pings only one IP address for a hostname. If {all}, the monitor pings all resolvable IPs for a hostname. {all} is useful if you are using a DNS-load balancer and want to ping every IP address for the specified hostname.",
        values: {
          all: /*#__PURE__*/_react.default.createElement(_eui.EuiCode, null, 'all'),
          any: /*#__PURE__*/_react.default.createElement(_eui.EuiCode, null, 'any')
        }
      }),
      props: () => ({
        options: Object.values(_types.Mode).map(value => ({
          value,
          text: value
        })),
        disabled: readOnly
      })
    },
    [_types.ConfigKey.RESPONSE_BODY_MAX_BYTES]: {
      fieldKey: _types.ConfigKey.RESPONSE_BODY_MAX_BYTES,
      component: _field_wrappers.FieldNumber,
      label: _i18n.i18n.translate('xpack.synthetics.monitorConfig.responseBodyMaxBytes.label', {
        defaultMessage: 'Response body max bytes'
      }),
      helpText: _i18n.i18n.translate('xpack.synthetics.monitorConfig.responseBodyMaxBytes.helpText', {
        defaultMessage: 'Controls the maximum size of the stored body contents.'
      }),
      hidden: dependencies => {
        const [responseBodyIndex] = dependencies || [];
        return responseBodyIndex === _types.ResponseBodyIndexPolicy.NEVER;
      },
      props: () => ({
        'data-test-subj': 'syntheticsMonitorConfigMaxBytes',
        min: 1,
        step: 'any',
        readOnly
      }),
      dependencies: [_types.ConfigKey.RESPONSE_BODY_INDEX]
    },
    [_types.ConfigKey.IPV4]: {
      fieldKey: _types.ConfigKey.IPV4,
      // also controls ipv6
      component: _field_wrappers.ComboBox,
      label: _i18n.i18n.translate('xpack.synthetics.monitorConfig.ipv4.label', {
        defaultMessage: 'IP protocols'
      }),
      helpText: _i18n.i18n.translate('xpack.synthetics.monitorConfig.ipv4.helpText', {
        defaultMessage: 'IP protocols to use when pinging the remote host.'
      }),
      controlled: true,
      dependencies: [_types.ConfigKey.IPV6],
      props: ({
        field,
        setValue,
        trigger,
        dependencies
      }) => {
        const [ipv6] = dependencies;
        const ipv4 = field === null || field === void 0 ? void 0 : field.value;
        const values = [];
        if (ipv4) {
          values.push('IPv4');
        }
        if (ipv6) {
          values.push('IPv6');
        }
        return {
          options: [{
            label: 'IPv4'
          }, {
            label: 'IPv6'
          }],
          selectedOptions: values.map(version => ({
            label: version
          })),
          onChange: async updatedValues => {
            setValue(_types.ConfigKey.IPV4, updatedValues.some(value => value.label === 'IPv4'));
            setValue(_types.ConfigKey.IPV6, updatedValues.some(value => value.label === 'IPv6'));
            await trigger([_types.ConfigKey.IPV4, _types.ConfigKey.IPV4]);
          },
          isDisabled: readOnly
        };
      }
    },
    [_types.ConfigKey.PROXY_HEADERS]: {
      fieldKey: _types.ConfigKey.PROXY_HEADERS,
      component: _field_wrappers.HeaderField,
      label: _i18n.i18n.translate('xpack.synthetics.monitorConfig.proxyHeaders.label', {
        defaultMessage: 'Proxy headers'
      }),
      helpText: _i18n.i18n.translate('xpack.synthetics.monitorConfig.proxyHeaders.helpText', {
        defaultMessage: 'Additional headers to send to proxies for CONNECT requests.'
      }),
      controlled: true,
      validation: () => ({
        validate: {
          validHeaders: headers => (0, _validation.validateHeaders)(headers) ? _i18n.i18n.translate('xpack.synthetics.monitorConfig.proxyHeaders.error', {
            defaultMessage: 'The header key must be a valid HTTP token.'
          }) : true
        }
      }),
      props: () => ({
        'data-test-subj': 'syntheticsHeaderFieldProxyHeaders',
        readOnly
      })
    },
    ['check.response.json']: {
      fieldKey: _types.ConfigKey.RESPONSE_JSON_CHECK,
      component: _field_wrappers.KeyValuePairsField,
      label: _i18n.i18n.translate('xpack.synthetics.monitorConfig.responseJSON.label', {
        defaultMessage: 'Response body contains JSON'
      }),
      helpText: _i18n.i18n.translate('xpack.synthetics.monitorConfig.responseJSON.helpText', {
        defaultMessage: 'A list of expressions executed against the body when parsed as JSON. The body size must be less than or equal to 100 MiB.'
      }),
      controlled: true,
      props: ({
        field,
        setValue,
        trigger
      }) => ({
        readOnly,
        keyLabel: _i18n.i18n.translate('xpack.synthetics.monitorConfig.responseJSON.key.label', {
          defaultMessage: 'Description'
        }),
        valueLabel: _i18n.i18n.translate('xpack.synthetics.monitorConfig.responseJSON.value.label', {
          defaultMessage: 'Expression'
        }),
        addPairControlLabel: _i18n.i18n.translate('xpack.synthetics.monitorConfig.responseJSON.addPair.label', {
          defaultMessage: 'Add expression'
        }),
        onChange: async pairs => {
          const value = pairs.map(pair => {
            const [description, expression] = pair;
            return {
              description,
              expression
            };
          }).filter(pair => pair.description || pair.expression);
          if (!(0, _lodash.isEqual)(value, field === null || field === void 0 ? void 0 : field.value)) {
            setValue(_types.ConfigKey.RESPONSE_JSON_CHECK, value);
            await trigger(_types.ConfigKey.RESPONSE_JSON_CHECK);
          }
        },
        defaultPairs: (field === null || field === void 0 ? void 0 : field.value.map(check => [check.description, check.expression])) || []
      }),
      validation: () => ({
        validate: {
          validBodyJSON: value => {
            if (value.some(check => !check.expression || !check.description)) {
              return _i18n.i18n.translate('xpack.synthetics.monitorConfig.responseJSON.error', {
                defaultMessage: "This JSON expression isn't valid. Make sure that both the label and expression are defined."
              });
            }
            return true;
          }
        }
      })
    },
    [_types.ConfigKey.MAX_ATTEMPTS]: {
      fieldKey: _types.ConfigKey.MAX_ATTEMPTS,
      component: _field_wrappers.Switch,
      controlled: true,
      props: ({
        setValue,
        field,
        trigger
      }) => ({
        disabled: readOnly,
        id: 'syntheticsMonitorConfigMaxAttempts',
        label: _i18n.i18n.translate('xpack.synthetics.monitorConfig.retest.label', {
          defaultMessage: 'Enable retest on failure'
        }),
        checked: (field === null || field === void 0 ? void 0 : field.value) === 2,
        onChange: async event => {
          const isChecked = !!event.target.checked;
          setValue(_types.ConfigKey.MAX_ATTEMPTS, isChecked ? 2 : 1);
          await trigger(_types.ConfigKey.MAX_ATTEMPTS);
        },
        'data-test-subj': 'syntheticsEnableAttemptSwitch'
      })
    }
  };
};
exports.FIELD = FIELD;