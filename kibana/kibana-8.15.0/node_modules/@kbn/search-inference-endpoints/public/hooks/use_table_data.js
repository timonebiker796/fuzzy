"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useTableData = void 0;
var _react = require("react");
var _types = require("../../common/types");
var _constants = require("../components/all_inference_endpoints/constants");
var _types2 = require("../components/all_inference_endpoints/types");
var _use_trained_model_stats = require("./use_trained_model_stats");
/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0; you may not use this file except in compliance with the Elastic License
 * 2.0.
 */

const useTableData = (inferenceEndpoints, queryParams, filterOptions, searchKey) => {
  const {
    data: trainedModelStats
  } = (0, _use_trained_model_stats.useTrainedModelStats)();
  const deploymentStatus = trainedModelStats === null || trainedModelStats === void 0 ? void 0 : trainedModelStats.trained_model_stats.reduce((acc, modelStat) => {
    if (modelStat.model_id) {
      var _modelStat$deployment;
      acc[modelStat.model_id] = (modelStat === null || modelStat === void 0 ? void 0 : (_modelStat$deployment = modelStat.deployment_stats) === null || _modelStat$deployment === void 0 ? void 0 : _modelStat$deployment.state) === 'started' ? _types2.DeploymentStatusEnum.deployed : _types2.DeploymentStatusEnum.notDeployed;
    }
    return acc;
  }, {});
  const tableData = (0, _react.useMemo)(() => {
    let filteredEndpoints = inferenceEndpoints;
    if (filterOptions.provider.length > 0) {
      filteredEndpoints = filteredEndpoints.filter(endpoint => filterOptions.provider.includes(_types2.ServiceProviderKeys[endpoint.service]));
    }
    if (filterOptions.type.length > 0) {
      filteredEndpoints = filteredEndpoints.filter(endpoint => filterOptions.type.includes(_types.TaskTypes[endpoint.task_type]));
    }
    return filteredEndpoints.filter(endpoint => endpoint.inference_id.includes(searchKey)).map(endpoint => {
      const isElasticService = endpoint.service === _types2.ServiceProviderKeys.elasticsearch || endpoint.service === _types2.ServiceProviderKeys.elser;
      let deploymentStatusValue = _types2.DeploymentStatusEnum.notApplicable;
      if (isElasticService) {
        var _endpoint$service_set;
        const modelId = (_endpoint$service_set = endpoint.service_settings) === null || _endpoint$service_set === void 0 ? void 0 : _endpoint$service_set.model_id;
        deploymentStatusValue = modelId && deploymentStatus !== null && deploymentStatus !== void 0 && deploymentStatus[modelId] ? deploymentStatus[modelId] : _types2.DeploymentStatusEnum.notDeployable;
      }
      return {
        deployment: deploymentStatusValue,
        endpoint,
        provider: endpoint.service,
        type: endpoint.task_type
      };
    });
  }, [inferenceEndpoints, searchKey, filterOptions, deploymentStatus]);
  const sortedTableData = (0, _react.useMemo)(() => {
    return [...tableData].sort((a, b) => {
      const aValue = a[queryParams.sortField];
      const bValue = b[queryParams.sortField];
      if (queryParams.sortOrder === _types2.SortOrder.asc) {
        return aValue.inference_id.localeCompare(bValue.inference_id);
      } else {
        return bValue.inference_id.localeCompare(aValue.inference_id);
      }
    });
  }, [tableData, queryParams]);
  const pagination = (0, _react.useMemo)(() => {
    var _inferenceEndpoints$l;
    return {
      pageIndex: queryParams.page - 1,
      pageSize: queryParams.perPage,
      pageSizeOptions: _types2.INFERENCE_ENDPOINTS_TABLE_PER_PAGE_VALUES,
      totalItemCount: (_inferenceEndpoints$l = inferenceEndpoints.length) !== null && _inferenceEndpoints$l !== void 0 ? _inferenceEndpoints$l : 0
    };
  }, [inferenceEndpoints, queryParams]);
  const paginatedSortedTableData = (0, _react.useMemo)(() => {
    const pageSize = pagination.pageSize || _constants.DEFAULT_TABLE_LIMIT;
    const startIndex = pagination.pageIndex * pageSize;
    const endIndex = startIndex + pageSize;
    return sortedTableData.slice(startIndex, endIndex);
  }, [sortedTableData, pagination]);
  const sorting = (0, _react.useMemo)(() => ({
    sort: {
      direction: queryParams.sortOrder,
      field: queryParams.sortField
    }
  }), [queryParams.sortField, queryParams.sortOrder]);
  return {
    tableData,
    sortedTableData,
    paginatedSortedTableData,
    pagination,
    sorting
  };
};
exports.useTableData = useTableData;