"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DocViewerTable = void 0;
var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));
require("./table.scss");
var _react = _interopRequireWildcard(require("react"));
var _useWindowSize = _interopRequireDefault(require("react-use/lib/useWindowSize"));
var _eui = require("@elastic/eui");
var _i18n = require("@kbn/i18n");
var _react2 = require("@emotion/react");
var _lodash = require("lodash");
var _get_field_icon_type = require("@kbn/field-utils/src/utils/get_field_icon_type");
var _discoverUtils = require("@kbn/discover-utils");
var _fieldUtils = require("@kbn/field-utils");
var _unifiedDocViewer = require("@kbn/unified-doc-viewer");
var _plugin = require("../../plugin");
var _table_cell_value = require("./table_cell_value");
var _table_cell_actions = require("./table_cell_actions");
var _get_height = require("../doc_viewer_source/get_height");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0 and the Server Side Public License, v 1; you may not use this file except
 * in compliance with, at your election, the Elastic License 2.0 or the Server
 * Side Public License, v 1.
 */

const MIN_NAME_COLUMN_WIDTH = 150;
const MAX_NAME_COLUMN_WIDTH = 350;
const PAGE_SIZE_OPTIONS = [25, 50, 100, 250, 500];
const DEFAULT_PAGE_SIZE = 25;
const PINNED_FIELDS_KEY = 'discover:pinnedFields';
const PAGE_SIZE = 'discover:pageSize';
const SEARCH_TEXT = 'discover:searchText';
const GRID_COLUMN_FIELD_NAME = 'name';
const GRID_COLUMN_FIELD_VALUE = 'value';
const GRID_PROPS = {
  columnVisibility: {
    visibleColumns: ['name', 'value'],
    setVisibleColumns: () => null
  },
  rowHeightsOptions: {
    defaultHeight: 'auto'
  },
  gridStyle: {
    border: 'horizontal',
    stripes: true,
    rowHover: 'highlight',
    header: 'underline',
    cellPadding: 'm',
    fontSize: 's'
  }
};
const getPinnedFields = (dataViewId, storage) => {
  const pinnedFieldsEntry = storage.get(PINNED_FIELDS_KEY);
  if (typeof pinnedFieldsEntry === 'object' && pinnedFieldsEntry !== null && Array.isArray(pinnedFieldsEntry[dataViewId])) {
    return pinnedFieldsEntry[dataViewId].filter(cur => typeof cur === 'string');
  }
  return [];
};
const updatePinnedFieldsState = (newFields, dataViewId, storage) => {
  let pinnedFieldsEntry = storage.get(PINNED_FIELDS_KEY);
  pinnedFieldsEntry = typeof pinnedFieldsEntry === 'object' && pinnedFieldsEntry !== null ? pinnedFieldsEntry : {};
  storage.set(PINNED_FIELDS_KEY, {
    ...pinnedFieldsEntry,
    [dataViewId]: newFields
  });
};
const getPageSize = storage => {
  const pageSize = Number(storage.get(PAGE_SIZE));
  return pageSize && PAGE_SIZE_OPTIONS.includes(pageSize) ? pageSize : DEFAULT_PAGE_SIZE;
};
const updatePageSize = (newPageSize, storage) => {
  storage.set(PAGE_SIZE, newPageSize);
};
const getSearchText = storage => {
  return storage.get(SEARCH_TEXT) || '';
};
const updateSearchText = (0, _lodash.debounce)((newSearchText, storage) => storage.set(SEARCH_TEXT, newSearchText), 500);
const DocViewerTable = ({
  columns,
  columnsMeta,
  hit,
  dataView,
  filter,
  decreaseAvailableHeightBy,
  onAddColumn,
  onRemoveColumn
}) => {
  const [containerRef, setContainerRef] = (0, _react.useState)(null);
  const {
    fieldFormats,
    storage,
    uiSettings
  } = (0, _plugin.getUnifiedDocViewerServices)();
  const showMultiFields = uiSettings.get(_discoverUtils.SHOW_MULTIFIELDS);
  const currentDataViewId = dataView.id;
  const [searchText, setSearchText] = (0, _react.useState)(getSearchText(storage));
  const [pinnedFields, setPinnedFields] = (0, _react.useState)(getPinnedFields(currentDataViewId, storage));
  const flattened = hit.flattened;
  const shouldShowFieldHandler = (0, _react.useMemo)(() => (0, _discoverUtils.getShouldShowFieldHandler)(Object.keys(flattened), dataView, showMultiFields), [flattened, dataView, showMultiFields]);
  const searchPlaceholder = _i18n.i18n.translate('unifiedDocViewer.docView.table.searchPlaceHolder', {
    defaultMessage: 'Search field names'
  });
  const mapping = (0, _react.useCallback)(name => dataView.fields.getByName(name), [dataView.fields]);
  const onToggleColumn = (0, _react.useMemo)(() => {
    if (!onRemoveColumn || !onAddColumn || !columns) {
      return undefined;
    }
    return field => {
      if (columns.includes(field)) {
        onRemoveColumn(field);
      } else {
        onAddColumn(field);
      }
    };
  }, [onRemoveColumn, onAddColumn, columns]);
  const onTogglePinned = (0, _react.useCallback)(field => {
    const newPinned = pinnedFields.includes(field) ? pinnedFields.filter(curField => curField !== field) : [...pinnedFields, field];
    updatePinnedFieldsState(newPinned, currentDataViewId, storage);
    setPinnedFields(newPinned);
  }, [currentDataViewId, pinnedFields, storage]);
  const onSearch = (0, _react.useCallback)(event => {
    const newSearchText = event.currentTarget.value;
    updateSearchText(newSearchText, storage);
    setSearchText(newSearchText);
  }, [storage]);
  const fieldToItem = (0, _react.useCallback)((field, isPinned) => {
    var _fieldMapping$display;
    const fieldMapping = mapping(field);
    const displayName = (_fieldMapping$display = fieldMapping === null || fieldMapping === void 0 ? void 0 : fieldMapping.displayName) !== null && _fieldMapping$display !== void 0 ? _fieldMapping$display : field;
    const columnMeta = columnsMeta === null || columnsMeta === void 0 ? void 0 : columnsMeta[field];
    const columnIconType = (0, _fieldUtils.getTextBasedColumnIconType)(columnMeta);
    const fieldType = columnIconType ? columnIconType // for text-based results types come separately
    : (0, _discoverUtils.isNestedFieldParent)(field, dataView) ? 'nested' : fieldMapping ? (0, _get_field_icon_type.getFieldIconType)(fieldMapping) : undefined;
    const ignored = (0, _discoverUtils.getIgnoredReason)(fieldMapping !== null && fieldMapping !== void 0 ? fieldMapping : field, hit.raw._ignored);
    return {
      action: {
        onToggleColumn,
        onFilter: filter,
        flattenedField: flattened[field]
      },
      field: {
        field,
        displayName,
        fieldMapping,
        fieldType,
        scripted: Boolean(fieldMapping === null || fieldMapping === void 0 ? void 0 : fieldMapping.scripted),
        pinned: isPinned,
        onTogglePinned
      },
      value: {
        formattedValue: (0, _discoverUtils.formatFieldValue)(hit.flattened[field], hit.raw, fieldFormats, dataView, fieldMapping),
        ignored
      }
    };
  }, [mapping, dataView, hit, onToggleColumn, filter, columnsMeta, flattened, onTogglePinned, fieldFormats]);
  const {
    pinnedItems,
    restItems
  } = Object.keys(flattened).sort((fieldA, fieldB) => {
    const mappingA = mapping(fieldA);
    const mappingB = mapping(fieldB);
    const nameA = !mappingA || !mappingA.displayName ? fieldA : mappingA.displayName;
    const nameB = !mappingB || !mappingB.displayName ? fieldB : mappingB.displayName;
    return nameA.localeCompare(nameB);
  }).reduce((acc, curFieldName) => {
    if (!shouldShowFieldHandler(curFieldName)) {
      return acc;
    }
    if (pinnedFields.includes(curFieldName)) {
      acc.pinnedItems.push(fieldToItem(curFieldName, true));
    } else {
      const fieldMapping = mapping(curFieldName);
      if (!(searchText !== null && searchText !== void 0 && searchText.trim()) || (0, _fieldUtils.fieldNameWildcardMatcher)({
        name: curFieldName,
        displayName: fieldMapping === null || fieldMapping === void 0 ? void 0 : fieldMapping.displayName
      }, searchText)) {
        // filter only unpinned fields
        acc.restItems.push(fieldToItem(curFieldName, false));
      }
    }
    return acc;
  }, {
    pinnedItems: [],
    restItems: []
  });
  const rows = (0, _react.useMemo)(() => [...pinnedItems, ...restItems], [pinnedItems, restItems]);
  const {
    curPageIndex,
    pageSize,
    totalPages,
    changePageIndex,
    changePageSize
  } = (0, _discoverUtils.usePager)({
    initialPageSize: getPageSize(storage),
    totalItems: rows.length
  });
  const showPagination = totalPages !== 0;
  const onChangePageSize = (0, _react.useCallback)(newPageSize => {
    updatePageSize(newPageSize, storage);
    changePageSize(newPageSize);
  }, [changePageSize, storage]);
  const pagination = (0, _react.useMemo)(() => {
    return showPagination ? {
      onChangeItemsPerPage: onChangePageSize,
      onChangePage: changePageIndex,
      pageIndex: curPageIndex,
      pageSize,
      pageSizeOptions: PAGE_SIZE_OPTIONS
    } : undefined;
  }, [showPagination, curPageIndex, pageSize, onChangePageSize, changePageIndex]);
  const fieldCellActions = (0, _react.useMemo)(() => (0, _table_cell_actions.getFieldCellActions)({
    rows,
    filter,
    onToggleColumn
  }), [rows, filter, onToggleColumn]);
  const fieldValueCellActions = (0, _react.useMemo)(() => (0, _table_cell_actions.getFieldValueCellActions)({
    rows,
    filter
  }), [rows, filter]);
  (0, _useWindowSize.default)(); // trigger re-render on window resize to recalculate the grid container height
  const {
    width: containerWidth
  } = (0, _eui.useResizeObserver)(containerRef);
  const gridColumns = (0, _react.useMemo)(() => [{
    id: GRID_COLUMN_FIELD_NAME,
    displayAsText: _i18n.i18n.translate('unifiedDocViewer.fieldChooser.discoverField.name', {
      defaultMessage: 'Field'
    }),
    initialWidth: Math.min(Math.max(Math.round(containerWidth * 0.3), MIN_NAME_COLUMN_WIDTH), MAX_NAME_COLUMN_WIDTH),
    actions: false,
    visibleCellActions: 3,
    cellActions: fieldCellActions
  }, {
    id: GRID_COLUMN_FIELD_VALUE,
    displayAsText: _i18n.i18n.translate('unifiedDocViewer.fieldChooser.discoverField.value', {
      defaultMessage: 'Value'
    }),
    actions: false,
    visibleCellActions: 2,
    cellActions: fieldValueCellActions
  }], [fieldCellActions, fieldValueCellActions, containerWidth]);
  const renderCellValue = (0, _react.useCallback)(({
    rowIndex,
    columnId,
    isDetails
  }) => {
    const row = rows[rowIndex];
    if (!row) {
      return null;
    }
    const {
      action: {
        flattenedField
      },
      field: {
        field,
        fieldMapping,
        fieldType,
        scripted,
        pinned
      },
      value: {
        formattedValue,
        ignored
      }
    } = row;
    if (columnId === 'name') {
      var _fieldMapping$display2;
      return /*#__PURE__*/_react.default.createElement("div", null, /*#__PURE__*/_react.default.createElement(_unifiedDocViewer.FieldName, {
        fieldName: field,
        fieldType: fieldType,
        fieldMapping: fieldMapping,
        scripted: scripted,
        highlight: (0, _fieldUtils.getFieldSearchMatchingHighlight)((_fieldMapping$display2 = fieldMapping === null || fieldMapping === void 0 ? void 0 : fieldMapping.displayName) !== null && _fieldMapping$display2 !== void 0 ? _fieldMapping$display2 : field, searchText),
        isPinned: pinned
      }), isDetails && fieldMapping !== null && fieldMapping !== void 0 && fieldMapping.customDescription ? /*#__PURE__*/_react.default.createElement("div", null, /*#__PURE__*/_react.default.createElement(_fieldUtils.FieldDescription, {
        field: fieldMapping,
        truncate: false
      })) : null);
    }
    if (columnId === 'value') {
      return /*#__PURE__*/_react.default.createElement(_table_cell_value.TableFieldValue, {
        field: field,
        formattedValue: formattedValue,
        rawValue: flattenedField,
        ignoreReason: ignored
      });
    }
    return null;
  }, [rows, searchText]);
  const renderCellPopover = (0, _react.useCallback)(props => {
    const {
      columnId,
      children,
      cellActions,
      rowIndex
    } = props;
    const row = rows[rowIndex];
    let warningMessage;
    if (columnId === GRID_COLUMN_FIELD_VALUE) {
      warningMessage = (0, _table_cell_actions.getFilterInOutPairDisabledWarning)(row);
    } else if (columnId === GRID_COLUMN_FIELD_NAME) {
      warningMessage = (0, _table_cell_actions.getFilterExistsDisabledWarning)(row);
    }
    return /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, /*#__PURE__*/_react.default.createElement(_eui.EuiText, {
      size: "s"
    }, children), cellActions, Boolean(warningMessage) && /*#__PURE__*/_react.default.createElement("div", null, /*#__PURE__*/_react.default.createElement(_eui.EuiSpacer, {
      size: "xs"
    }), /*#__PURE__*/_react.default.createElement(_eui.EuiCallOut, {
      title: warningMessage,
      color: "warning",
      size: "s"
    })));
  }, [rows]);
  const containerHeight = containerRef ? (0, _get_height.getTabContentAvailableHeight)(containerRef, decreaseAvailableHeightBy !== null && decreaseAvailableHeightBy !== void 0 ? decreaseAvailableHeightBy : _get_height.DEFAULT_MARGIN_BOTTOM) : 0;
  return /*#__PURE__*/_react.default.createElement(_eui.EuiFlexGroup, {
    ref: setContainerRef,
    direction: "column",
    gutterSize: "none",
    responsive: false,
    css: containerHeight ? (0, _react2.css)`
              height: ${containerHeight}px;
            ` : (0, _react2.css)`
              display: block;
            `
  }, /*#__PURE__*/_react.default.createElement(_eui.EuiFlexItem, {
    grow: false
  }, /*#__PURE__*/_react.default.createElement(_eui.EuiSpacer, {
    size: "s"
  })), /*#__PURE__*/_react.default.createElement(_eui.EuiFlexItem, {
    grow: false
  }, /*#__PURE__*/_react.default.createElement(_eui.EuiFieldSearch, {
    "aria-label": searchPlaceholder,
    fullWidth: true,
    onChange: onSearch,
    placeholder: searchPlaceholder,
    value: searchText,
    "data-test-subj": "unifiedDocViewerFieldsSearchInput"
  })), rows.length === 0 ? /*#__PURE__*/_react.default.createElement(_eui.EuiSelectableMessage, {
    style: {
      minHeight: 300
    }
  }, /*#__PURE__*/_react.default.createElement("p", null, /*#__PURE__*/_react.default.createElement(_eui.EuiI18n, {
    token: "unifiedDocViewer.docViews.table.noFieldFound",
    default: "No fields found"
  }))) : /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, /*#__PURE__*/_react.default.createElement(_eui.EuiFlexItem, {
    grow: false
  }, /*#__PURE__*/_react.default.createElement(_eui.EuiSpacer, {
    size: "s"
  })), /*#__PURE__*/_react.default.createElement(_eui.EuiFlexItem, {
    grow: Boolean(containerHeight),
    css: (0, _react2.css)`
              min-block-size: 0;
              display: block;
            `
  }, /*#__PURE__*/_react.default.createElement(_eui.EuiDataGrid, (0, _extends2.default)({}, GRID_PROPS, {
    "aria-label": _i18n.i18n.translate('unifiedDocViewer.fieldsTable.ariaLabel', {
      defaultMessage: 'Field values'
    }),
    className: "kbnDocViewer__fieldsGrid",
    columns: gridColumns,
    toolbarVisibility: false,
    rowCount: rows.length,
    renderCellValue: renderCellValue,
    renderCellPopover: renderCellPopover,
    pagination: pagination
  })))));
};
exports.DocViewerTable = DocViewerTable;