"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.executor = executor;
exports.getChecksum = getChecksum;
exports.getInvalidComparatorError = getInvalidComparatorError;
exports.getValidTimefieldSort = getValidTimefieldSort;
exports.tryToParseAsDate = tryToParseAsDate;
var _jsSha = require("js-sha256");
var _i18n = require("@kbn/i18n");
var _common = require("@kbn/triggers-actions-ui-plugin/common");
var _ruleDataUtils = require("@kbn/rule-data-utils");
var _server = require("@kbn/alerting-plugin/server");
var _lodash = require("lodash");
var _common2 = require("../../../common");
var _action_context = require("./action_context");
var _constants = require("./constants");
var _fetch_es_query = require("./lib/fetch_es_query");
var _fetch_search_source_query = require("./lib/fetch_search_source_query");
var _util = require("./util");
var _fetch_esql_query = require("./lib/fetch_esql_query");
var _ = require("..");
/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0; you may not use this file except in compliance with the Elastic License
 * 2.0.
 */

async function executor(core, options) {
  var _core$http$basePath$p;
  const searchSourceRule = (0, _util.isSearchSourceRule)(options.params.searchType);
  const esqlQueryRule = (0, _util.isEsqlQueryRule)(options.params.searchType);
  const {
    rule: {
      id: ruleId,
      name
    },
    services,
    params,
    state,
    spaceId,
    logger,
    getTimeRange
  } = options;
  const {
    alertsClient,
    scopedClusterClient,
    searchSourceClient,
    share,
    dataViews
  } = services;
  if (!alertsClient) {
    throw new _server.AlertsClientError();
  }
  const currentTimestamp = new Date().toISOString();
  const publicBaseUrl = (_core$http$basePath$p = core.http.basePath.publicBaseUrl) !== null && _core$http$basePath$p !== void 0 ? _core$http$basePath$p : '';
  const spacePrefix = spaceId !== 'default' ? `/s/${spaceId}` : '';
  const alertLimit = alertsClient.getAlertLimitValue();
  const compareFn = _common2.ComparatorFns.get(params.thresholdComparator);
  if (compareFn == null) {
    throw new Error(getInvalidComparatorError(params.thresholdComparator));
  }
  const isGroupAgg = (0, _common.isGroupAggregation)(params.termField);
  // For ungrouped queries, we run the configured query during each rule run, get a hit count
  // and retrieve up to params.size hits. We evaluate the threshold condition using the
  // value of the hit count. If the threshold condition is met, the hits are counted
  // toward the query match and we update the rule state with the timestamp of the latest hit.
  // In the next run of the rule, the latestTimestamp will be used to gate the query in order to
  // avoid counting a document multiple times.
  // latestTimestamp will be ignored if set for grouped queries
  let latestTimestamp = tryToParseAsDate(state.latestTimestamp);
  const {
    dateStart,
    dateEnd
  } = getTimeRange(`${params.timeWindowSize}${params.timeWindowUnit}`);
  const {
    parsedResults,
    link,
    index,
    query
  } = searchSourceRule ? await (0, _fetch_search_source_query.fetchSearchSourceQuery)({
    ruleId,
    alertLimit,
    params: params,
    latestTimestamp,
    spacePrefix,
    services: {
      share,
      searchSourceClient,
      logger,
      dataViews
    },
    dateStart,
    dateEnd
  }) : esqlQueryRule ? await (0, _fetch_esql_query.fetchEsqlQuery)({
    ruleId,
    alertLimit,
    params: params,
    spacePrefix,
    publicBaseUrl,
    services: {
      share,
      scopedClusterClient,
      logger
    },
    dateStart,
    dateEnd
  }) : await (0, _fetch_es_query.fetchEsQuery)({
    ruleId,
    name,
    alertLimit,
    params: params,
    timestamp: latestTimestamp,
    publicBaseUrl,
    spacePrefix,
    services: {
      scopedClusterClient,
      logger
    },
    dateStart,
    dateEnd
  });
  const unmetGroupValues = {};
  for (const result of parsedResults.results) {
    var _result$value, _params$threshold;
    const alertId = result.group;
    const value = (_result$value = result.value) !== null && _result$value !== void 0 ? _result$value : result.count;

    // check hits for dates out of range
    if (!esqlQueryRule) {
      checkHitsForDateOutOfRange(logger, ruleId, result.hits, params.timeField, dateStart, dateEnd, query);
    }

    // group aggregations use the bucket selector agg to compare conditions
    // within the ES query, so only 'met' results are returned, therefore we don't need
    // to use the compareFn
    const met = isGroupAgg ? true : compareFn(value, params.threshold);
    if (!met) {
      unmetGroupValues[alertId] = value;
      continue;
    }
    const baseContext = {
      title: name,
      date: currentTimestamp,
      value,
      hits: result.hits,
      link,
      sourceFields: result.sourceFields
    };
    const baseActiveContext = {
      ...baseContext,
      conditions: (0, _action_context.getContextConditionsDescription)({
        searchType: params.searchType,
        comparator: params.thresholdComparator,
        threshold: params.threshold,
        aggType: params.aggType,
        aggField: params.aggField,
        ...(isGroupAgg ? {
          group: alertId
        } : {})
      })
    };
    const actionContext = (0, _action_context.addMessages)({
      ruleName: name,
      baseContext: baseActiveContext,
      params,
      ...(isGroupAgg ? {
        group: alertId
      } : {}),
      index
    });
    const id = alertId === _common.UngroupedGroupId && !isGroupAgg ? _constants.ConditionMetAlertInstanceId : alertId;
    alertsClient.report({
      id,
      actionGroup: _constants.ActionGroupId,
      state: {
        latestTimestamp,
        dateStart,
        dateEnd
      },
      context: actionContext,
      payload: {
        [_ruleDataUtils.ALERT_URL]: actionContext.link,
        [_ruleDataUtils.ALERT_REASON]: actionContext.message,
        [_.ALERT_TITLE]: actionContext.title,
        [_.ALERT_EVALUATION_CONDITIONS]: actionContext.conditions,
        [_ruleDataUtils.ALERT_EVALUATION_VALUE]: `${actionContext.value}`,
        [_ruleDataUtils.ALERT_EVALUATION_THRESHOLD]: ((_params$threshold = params.threshold) === null || _params$threshold === void 0 ? void 0 : _params$threshold.length) === 1 ? params.threshold[0] : null,
        ...actionContext.sourceFields
      }
    });
    if (!isGroupAgg) {
      var _result$hits$find;
      // update the timestamp based on the current search results
      const firstValidTimefieldSort = getValidTimefieldSort((_result$hits$find = result.hits.find(hit => getValidTimefieldSort(hit.sort))) === null || _result$hits$find === void 0 ? void 0 : _result$hits$find.sort);
      if (firstValidTimefieldSort) {
        latestTimestamp = firstValidTimefieldSort;
      }
    }
  }
  alertsClient.setAlertLimitReached(parsedResults.truncated);
  const {
    getRecoveredAlerts
  } = alertsClient;
  for (const recoveredAlert of getRecoveredAlerts()) {
    var _unmetGroupValues$ale, _params$threshold2;
    const alertId = recoveredAlert.alert.getId();
    const baseRecoveryContext = {
      title: name,
      date: currentTimestamp,
      value: (_unmetGroupValues$ale = unmetGroupValues[alertId]) !== null && _unmetGroupValues$ale !== void 0 ? _unmetGroupValues$ale : 0,
      hits: [],
      link,
      conditions: (0, _action_context.getContextConditionsDescription)({
        searchType: params.searchType,
        comparator: params.thresholdComparator,
        threshold: params.threshold,
        isRecovered: true,
        aggType: params.aggType,
        aggField: params.aggField,
        ...(isGroupAgg ? {
          group: alertId
        } : {})
      }),
      sourceFields: []
    };
    const recoveryContext = (0, _action_context.addMessages)({
      ruleName: name,
      baseContext: baseRecoveryContext,
      params,
      isRecovered: true,
      ...(isGroupAgg ? {
        group: alertId
      } : {}),
      index
    });
    alertsClient.setAlertData({
      id: alertId,
      context: recoveryContext,
      payload: {
        [_ruleDataUtils.ALERT_URL]: recoveryContext.link,
        [_ruleDataUtils.ALERT_REASON]: recoveryContext.message,
        [_.ALERT_TITLE]: recoveryContext.title,
        [_.ALERT_EVALUATION_CONDITIONS]: recoveryContext.conditions,
        [_ruleDataUtils.ALERT_EVALUATION_VALUE]: `${recoveryContext.value}`,
        [_ruleDataUtils.ALERT_EVALUATION_THRESHOLD]: ((_params$threshold2 = params.threshold) === null || _params$threshold2 === void 0 ? void 0 : _params$threshold2.length) === 1 ? params.threshold[0] : null
      }
    });
  }
  return {
    state: {
      latestTimestamp
    }
  };
}

// diagnostic to help solve a puzzle of sometimes returning documents
// not matching the expected time range; usually kql using ccs.
function checkHitsForDateOutOfRange(logger, ruleId, hits, timeField, dateStart, dateEnd, query) {
  if (!timeField) return;
  const epochStart = new Date(dateStart).getTime();
  const epochEnd = new Date(dateEnd).getTime();
  const messageMeta = {
    tags: ['query-result-out-of-time-range']
  };
  const messagePrefix = `For rule '${ruleId}'`;
  const usingQuery = `using query <${JSON.stringify(query)}>`;
  const hitsWereReturned = 'hits were returned with invalid time range';
  let errors = 0;
  if (isNaN(epochStart)) {
    errors++;
    logger.error(`${messagePrefix}, ${hitsWereReturned} start date '${dateStart}' from field '${timeField}' ${usingQuery}`, messageMeta);
  }
  if (isNaN(epochEnd)) {
    errors++;
    logger.error(`${messagePrefix}, ${hitsWereReturned} end date '${dateEnd}' from field '${timeField}' ${usingQuery}`, messageMeta);
  }
  if (errors > 0) return;
  const outsideTimeRange = 'outside the query time range';
  for (const hit of hits) {
    const dateVal = (0, _lodash.get)(hit, `_source.${timeField}`);
    const epochDate = getEpochDateFromString(dateVal);
    if (epochDate) {
      if (epochDate < epochStart || epochDate > epochEnd) {
        const message = `the hit with date '${dateVal}' from field '${timeField}' is ${outsideTimeRange}`;
        const queryString = `Query: <${JSON.stringify(query)}>`;
        const document = `Document: <${JSON.stringify(hit)}>`;
        logger.error(`${messagePrefix}, ${message}. ${queryString}. ${document}`, messageMeta);
      }
    }
  }
}
function getEpochDateFromString(dateString) {
  let date;
  try {
    date = new Date(dateString);
  } catch (e) {
    return null;
  }
  const time = date.getTime();
  if (!isNaN(time)) return time;

  // if not a valid date string, try it as a stringified number
  const dateNum = parseInt(dateString, 10);
  if (isNaN(dateNum)) return null;
  const timeFromNumber = new Date(dateNum).getTime();
  if (isNaN(timeFromNumber)) return null;
  return timeFromNumber;
}
function getValidTimefieldSort(sortValues = []) {
  for (const sortValue of sortValues) {
    const sortDate = tryToParseAsDate(sortValue);
    if (sortDate) {
      return sortDate;
    }
  }
}
function tryToParseAsDate(sortValue) {
  const sortDate = typeof sortValue === 'string' ? Date.parse(sortValue) : sortValue;
  if (sortDate && !isNaN(sortDate)) {
    return new Date(sortDate).toISOString();
  }
}
function getChecksum(params) {
  return _jsSha.sha256.create().update(JSON.stringify(params));
}
function getInvalidComparatorError(comparator) {
  return _i18n.i18n.translate('xpack.stackAlerts.esQuery.invalidComparatorErrorMessage', {
    defaultMessage: 'invalid thresholdComparator specified: {comparator}',
    values: {
      comparator
    }
  });
}