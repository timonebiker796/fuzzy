"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.flowRouteRepository = void 0;
var _boom = _interopRequireDefault(require("@hapi/boom"));
var t = _interopRequireWildcard(require("io-ts"));
var _server = require("@kbn/fleet-plugin/server");
var _jsYaml = require("js-yaml");
var _state = require("../../lib/state");
var _create_observability_onboarding_server_route = require("../create_observability_onboarding_server_route");
var _get_has_logs = require("./get_has_logs");
var _get_fallback_urls = require("../../lib/get_fallback_urls");
var _has_log_monitoring_privileges = require("../logs/api_key/has_log_monitoring_privileges");
var _create_shipper_api_key = require("../logs/api_key/create_shipper_api_key");
var _create_install_api_key = require("../logs/api_key/create_install_api_key");
var _get_agent_version = require("../../lib/get_agent_version");
var _types = require("../types");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0; you may not use this file except in compliance with the Elastic License
 * 2.0.
 */

const updateOnboardingFlowRoute = (0, _create_observability_onboarding_server_route.createObservabilityOnboardingServerRoute)({
  endpoint: 'PUT /internal/observability_onboarding/flow/{onboardingId}',
  options: {
    tags: [],
    xsrfRequired: false
  },
  params: t.type({
    path: t.type({
      onboardingId: t.string
    }),
    body: t.partial({
      state: t.record(t.string, t.unknown)
    })
  }),
  async handler(resources) {
    const {
      params: {
        path: {
          onboardingId
        },
        body: {
          state
        }
      },
      core,
      request
    } = resources;
    const coreStart = await core.start();
    const savedObjectsClient = coreStart.savedObjects.getScopedClient(request);
    const {
      id
    } = await (0, _state.saveObservabilityOnboardingFlow)({
      savedObjectsClient,
      savedObjectId: onboardingId,
      observabilityOnboardingState: {
        type: 'logFiles',
        state,
        progress: {}
      }
    });
    return {
      onboardingId: id
    };
  }
});
const stepProgressUpdateRoute = (0, _create_observability_onboarding_server_route.createObservabilityOnboardingServerRoute)({
  endpoint: 'POST /internal/observability_onboarding/flow/{id}/step/{name}',
  options: {
    tags: [],
    xsrfRequired: false
  },
  params: t.type({
    path: t.type({
      id: t.string,
      name: t.string
    }),
    body: t.intersection([t.type({
      status: t.string
    }), t.partial({
      message: t.string
    }), t.partial({
      payload: _types.StepProgressPayloadRT
    })])
  }),
  async handler(resources) {
    const {
      params: {
        path: {
          id,
          name
        },
        body: {
          status,
          message,
          payload
        }
      },
      core
    } = resources;
    const coreStart = await core.start();
    const savedObjectsClient = coreStart.savedObjects.createInternalRepository();
    const savedObservabilityOnboardingState = await (0, _state.getObservabilityOnboardingFlow)({
      savedObjectsClient,
      savedObjectId: id
    });
    if (!savedObservabilityOnboardingState) {
      throw _boom.default.notFound('Unable to report setup progress - onboarding session not found.');
    }
    const {
      id: savedObjectId,
      updatedAt,
      ...observabilityOnboardingState
    } = savedObservabilityOnboardingState;
    await (0, _state.saveObservabilityOnboardingFlow)({
      savedObjectsClient,
      savedObjectId,
      observabilityOnboardingState: {
        ...observabilityOnboardingState,
        progress: {
          ...observabilityOnboardingState.progress,
          [name]: {
            status,
            message,
            payload
          }
        }
      }
    });
    return {
      name,
      status,
      message,
      payload
    };
  }
});
const getProgressRoute = (0, _create_observability_onboarding_server_route.createObservabilityOnboardingServerRoute)({
  endpoint: 'GET /internal/observability_onboarding/flow/{onboardingId}/progress',
  options: {
    tags: [],
    xsrfRequired: false
  },
  params: t.type({
    path: t.type({
      onboardingId: t.string
    })
  }),
  async handler(resources) {
    var _progress$eaStatus;
    const {
      params: {
        path: {
          onboardingId
        }
      },
      core,
      request
    } = resources;
    const coreStart = await core.start();
    const savedObjectsClient = coreStart.savedObjects.getScopedClient(request);
    const savedObservabilityOnboardingState = await (0, _state.getObservabilityOnboardingFlow)({
      savedObjectsClient,
      savedObjectId: onboardingId
    });
    if (!savedObservabilityOnboardingState) {
      throw _boom.default.notFound('Unable to report setup progress - onboarding session not found.');
    }
    const progress = {
      ...(savedObservabilityOnboardingState === null || savedObservabilityOnboardingState === void 0 ? void 0 : savedObservabilityOnboardingState.progress)
    };
    const esClient = coreStart.elasticsearch.client.asScoped(request).asCurrentUser;
    if (((_progress$eaStatus = progress['ea-status']) === null || _progress$eaStatus === void 0 ? void 0 : _progress$eaStatus.status) === 'complete') {
      var _progress$eaStatus2;
      const {
        agentId
      } = (_progress$eaStatus2 = progress['ea-status']) === null || _progress$eaStatus2 === void 0 ? void 0 : _progress$eaStatus2.payload;
      try {
        const hasLogs = await (0, _get_has_logs.getHasLogs)(esClient, agentId);
        progress['logs-ingest'] = {
          status: hasLogs ? 'complete' : 'loading'
        };
      } catch (error) {
        progress['logs-ingest'] = {
          status: 'warning',
          message: error.message
        };
      }
    } else {
      progress['logs-ingest'] = {
        status: 'incomplete'
      };
    }
    return {
      progress
    };
  }
});

/**
 * This endpoint starts a new onboarding flow and creates two API keys:
 * 1. A short-lived API key with privileges to install integrations.
 * 2. An API key with privileges to ingest log and metric data used to configure Elastic Agent.
 *
 * It also returns all required information to download the onboarding script and install the
 * Elastic agent.
 *
 * If the user does not have all necessary privileges a 403 Forbidden response is returned.
 *
 * This endpoint differs from the existing `POST /internal/observability_onboarding/logs/flow`
 * endpoint in that it caters for the auto-detect flow where integrations are detected and installed
 * on the host system, rather than in the Kiabana UI.
 */
const createFlowRoute = (0, _create_observability_onboarding_server_route.createObservabilityOnboardingServerRoute)({
  endpoint: 'POST /internal/observability_onboarding/flow',
  options: {
    tags: []
  },
  params: t.type({
    body: t.type({
      name: t.string
    })
  }),
  async handler(resources) {
    var _plugins$cloud;
    const {
      context,
      params: {
        body: {
          name
        }
      },
      core,
      request,
      plugins,
      kibanaVersion
    } = resources;
    const coreStart = await core.start();
    const {
      elasticsearch: {
        client
      }
    } = await context.core;
    const savedObjectsClient = coreStart.savedObjects.getScopedClient(request);
    const hasPrivileges = await (0, _has_log_monitoring_privileges.hasLogMonitoringPrivileges)(client.asCurrentUser);
    if (!hasPrivileges) {
      throw _boom.default.forbidden('Unauthorized to create log indices');
    }
    const fleetPluginStart = await plugins.fleet.start();
    const securityPluginStart = await plugins.security.start();
    const [onboardingFlow, ingestApiKey, installApiKey, elasticAgentVersion] = await Promise.all([(0, _state.saveObservabilityOnboardingFlow)({
      savedObjectsClient,
      observabilityOnboardingState: {
        type: 'autoDetect',
        state: undefined,
        progress: {}
      }
    }), (0, _create_shipper_api_key.createShipperApiKey)(client.asCurrentUser, name), securityPluginStart.authc.apiKeys.create(request, (0, _create_install_api_key.createInstallApiKey)(name)), (0, _get_agent_version.getAgentVersion)(fleetPluginStart, kibanaVersion)]);
    if (!installApiKey) {
      throw _boom.default.notFound('License does not allow API key creation.');
    }
    const kibanaUrl = (0, _get_fallback_urls.getKibanaUrl)(core.setup, (_plugins$cloud = plugins.cloud) === null || _plugins$cloud === void 0 ? void 0 : _plugins$cloud.setup);
    const scriptDownloadUrl = new URL(core.setup.http.staticAssets.getPluginAssetHref('auto_detect.sh'), kibanaUrl).toString();
    return {
      onboardingFlow,
      ingestApiKey: ingestApiKey.encoded,
      installApiKey: installApiKey.encoded,
      elasticAgentVersion,
      kibanaUrl,
      scriptDownloadUrl
    };
  }
});

/**
 * This endpoints installs the requested integrations and returns the corresponding config file for Elastic Agent.
 *
 * The request/response format is TSV (tab-separated values) to simplify parsing in bash.
 *
 * Example request:
 *
 * ```text
 * POST /internal/observability_onboarding/flow/${ONBOARDING_ID}/integrations/install
 *
 * system registry
 * product_service custom /path/to/access.log
 * product_service custom /path/to/error.log
 * checkout_service custom /path/to/access.log
 * checkout_service custom /path/to/error.log
 * ```
 *
 * Example curl:
 *
 * ```bash
 * curl --request POST \
 *  --url "http://localhost:5601/internal/observability_onboarding/flow/${ONBOARDING_ID}/integrations/install" \
 *  --header "Authorization: ApiKey ${ENCODED_API_KEY}" \
 *  --header "Content-Type: text/tab-separated-values" \
 *  --data $'system\tregistry\nproduct_service\tcustom\t/path/to/access.log\ncheckout_service\tcustom\t/path/to/access.log'
 * ```
 */
const integrationsInstallRoute = (0, _create_observability_onboarding_server_route.createObservabilityOnboardingServerRoute)({
  endpoint: 'POST /internal/observability_onboarding/flow/{onboardingId}/integrations/install',
  options: {
    tags: [],
    xsrfRequired: false
  },
  params: t.type({
    path: t.type({
      onboardingId: t.string
    }),
    body: t.string
  }),
  async handler({
    context,
    request,
    response,
    params,
    core,
    plugins,
    services
  }) {
    var _plugins$cloud2, _plugins$cloud2$setup, _plugins$cloud3, _plugins$cloud3$setup;
    const coreStart = await core.start();
    const fleetStart = await plugins.fleet.start();
    const savedObjectsClient = coreStart.savedObjects.createInternalRepository();
    const packageClient = fleetStart.packageService.asScoped(request);
    const savedObservabilityOnboardingState = await (0, _state.getObservabilityOnboardingFlow)({
      savedObjectsClient,
      savedObjectId: params.path.onboardingId
    });
    if (!savedObservabilityOnboardingState) {
      throw _boom.default.notFound(`Onboarding session '${params.path.onboardingId}' not found.`);
    }
    const integrationsToInstall = parseIntegrationsTSV(params.body);
    if (!integrationsToInstall.length) {
      return response.badRequest({
        body: {
          message: 'Please specify a list of integrations to install'
        }
      });
    }
    let installedIntegrations = [];
    try {
      installedIntegrations = await ensureInstalledIntegrations(integrationsToInstall, packageClient);
    } catch (error) {
      if (error instanceof _server.FleetUnauthorizedError) {
        return response.forbidden({
          body: {
            message: error.message
          }
        });
      }
      throw error;
    }
    await (0, _state.saveObservabilityOnboardingFlow)({
      savedObjectsClient,
      savedObjectId: params.path.onboardingId,
      observabilityOnboardingState: {
        ...savedObservabilityOnboardingState,
        progress: {
          ...savedObservabilityOnboardingState.progress,
          'install-integrations': {
            status: 'complete',
            payload: installedIntegrations
          }
        }
      }
    });
    const elasticsearchUrl = (_plugins$cloud2 = plugins.cloud) !== null && _plugins$cloud2 !== void 0 && (_plugins$cloud2$setup = _plugins$cloud2.setup) !== null && _plugins$cloud2$setup !== void 0 && _plugins$cloud2$setup.elasticsearchUrl ? [(_plugins$cloud3 = plugins.cloud) === null || _plugins$cloud3 === void 0 ? void 0 : (_plugins$cloud3$setup = _plugins$cloud3.setup) === null || _plugins$cloud3$setup === void 0 ? void 0 : _plugins$cloud3$setup.elasticsearchUrl] : await (0, _get_fallback_urls.getFallbackESUrl)(services.esLegacyConfigService);
    return response.ok({
      headers: {
        'content-type': 'application/yaml'
      },
      body: generateAgentConfig({
        esHost: elasticsearchUrl,
        inputs: installedIntegrations.map(({
          inputs
        }) => inputs).flat()
      })
    });
  }
});
async function ensureInstalledIntegrations(integrationsToInstall, packageClient) {
  return Promise.all(integrationsToInstall.map(async integration => {
    const {
      pkgName,
      installSource
    } = integration;
    if (installSource === 'registry') {
      var _packageInfo$data_str, _packageInfo$data_str2;
      const pkg = await packageClient.ensureInstalledPackage({
        pkgName
      });
      const inputs = await packageClient.getAgentPolicyInputs(pkg.name, pkg.version);
      const {
        packageInfo
      } = await packageClient.getPackage(pkg.name, pkg.version);
      return {
        installSource,
        pkgName: pkg.name,
        pkgVersion: pkg.version,
        title: packageInfo.title,
        inputs: inputs.filter(input => input.type !== 'httpjson'),
        dataStreams: (_packageInfo$data_str = (_packageInfo$data_str2 = packageInfo.data_streams) === null || _packageInfo$data_str2 === void 0 ? void 0 : _packageInfo$data_str2.map(({
          type,
          dataset
        }) => ({
          type,
          dataset
        }))) !== null && _packageInfo$data_str !== void 0 ? _packageInfo$data_str : [],
        kibanaAssets: pkg.installed_kibana
      };
    }
    const dataStream = {
      type: 'logs',
      dataset: pkgName
    };
    const installed = {
      installSource,
      pkgName,
      pkgVersion: '1.0.0',
      // Custom integrations are always installed as version `1.0.0`
      title: pkgName,
      inputs: [{
        id: `filestream-${pkgName}`,
        type: 'filestream',
        streams: [{
          id: `filestream-${pkgName}`,
          data_stream: dataStream,
          paths: integration.logFilePaths
        }]
      }],
      dataStreams: [dataStream],
      kibanaAssets: []
    };
    try {
      await packageClient.installCustomIntegration({
        pkgName,
        datasets: [{
          name: dataStream.dataset,
          type: dataStream.type
        }]
      });
      return installed;
    } catch (error) {
      // If the error is a naming collision, we can assume the integration is already installed and treat this step as successful
      if (error instanceof _server.NamingCollisionError) {
        return installed;
      } else {
        throw error;
      }
    }
  }));
}

/**
 * Parses and validates a TSV (tab-separated values) string of integrations with params.
 *
 * Returns an object of integrations to install.
 *
 * Example input:
 *
 * ```text
 * system registry
 * product_service custom /path/to/access.log
 * product_service custom /path/to/error.log
 * checkout_service custom /path/to/access.log
 * checkout_service custom /path/to/error.log
 * ```
 */
function parseIntegrationsTSV(tsv) {
  return Object.values(tsv.trim().split('\n').map(line => line.split('\t', 3)).reduce((acc, [pkgName, installSource, logFilePath]) => {
    const key = `${pkgName}-${installSource}`;
    if (installSource === 'registry') {
      if (logFilePath) {
        throw new Error(`Integration '${pkgName}' does not support a file path`);
      }
      acc[key] = {
        pkgName,
        installSource
      };
      return acc;
    } else if (installSource === 'custom') {
      if (!logFilePath) {
        throw new Error(`Missing file path for integration: ${pkgName}`);
      }
      // Append file path if integration is already in the list
      const existing = acc[key];
      if (existing && existing.installSource === 'custom') {
        existing.logFilePaths.push(logFilePath);
        return acc;
      }
      acc[key] = {
        pkgName,
        installSource,
        logFilePaths: [logFilePath]
      };
      return acc;
    }
    throw new Error(`Invalid install source: ${installSource}`);
  }, {}));
}
const generateAgentConfig = ({
  esHost,
  inputs = []
}) => {
  return (0, _jsYaml.dump)({
    outputs: {
      default: {
        type: 'elasticsearch',
        hosts: esHost,
        api_key: '${API_KEY}' // Placeholder to be replaced by bash script with the actual API key
      }
    },
    inputs
  });
};
const flowRouteRepository = exports.flowRouteRepository = {
  ...createFlowRoute,
  ...updateOnboardingFlowRoute,
  ...stepProgressUpdateRoute,
  ...getProgressRoute,
  ...integrationsInstallRoute
};