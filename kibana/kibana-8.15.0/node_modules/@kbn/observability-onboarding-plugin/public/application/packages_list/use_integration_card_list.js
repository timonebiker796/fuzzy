"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addPathParamToUrl = addPathParamToUrl;
exports.toOnboardingPath = toOnboardingPath;
exports.useIntegrationCardList = useIntegrationCardList;
var _react = require("react");
var _public = require("@kbn/kibana-react-plugin/public");
var _utils = require("./utils");
/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0; you may not use this file except in compliance with the Elastic License
 * 2.0.
 */

function toOnboardingPath({
  basePath,
  category,
  search
}) {
  if (typeof basePath !== 'string' && !basePath) return null;
  const path = `${basePath}/app/observabilityOnboarding`;
  if (!category && !search) return path;
  const params = new URLSearchParams();
  if (category) params.append('category', category);
  if (search) params.append('search', search);
  return `${path}?${params.toString()}`;
}
function addPathParamToUrl(url, onboardingLink) {
  const encoded = encodeURIComponent(onboardingLink);
  if (url.indexOf('?') >= 0) {
    return `${url}&observabilityOnboardingLink=${encoded}`;
  }
  return `${url}?observabilityOnboardingLink=${encoded}`;
}
function useCardUrlRewrite(props) {
  var _kibana$services$http;
  const kibana = (0, _public.useKibana)();
  const basePath = (_kibana$services$http = kibana.services.http) === null || _kibana$services$http === void 0 ? void 0 : _kibana$services$http.basePath.get();
  const onboardingLink = (0, _react.useMemo)(() => toOnboardingPath({
    basePath,
    ...props
  }), [basePath, props]);
  return card => ({
    ...card,
    url: card.url.indexOf('/app/integrations') >= 0 && onboardingLink ? addPathParamToUrl(card.url, onboardingLink) : card.url
  });
}
function extractFeaturedCards(filteredCards, featuredCardNames) {
  const featuredCards = {};
  filteredCards.forEach(card => {
    if (featuredCardNames !== null && featuredCardNames !== void 0 && featuredCardNames.includes(card.name)) {
      featuredCards[card.name] = card;
    }
  });
  return featuredCards;
}
function formatCustomCards(rewriteUrl, customCards, featuredCards) {
  const cards = [];
  for (const card of customCards) {
    if (card.type === 'featured' && !!featuredCards[card.name]) {
      cards.push((0, _utils.toCustomCard)(rewriteUrl(featuredCards[card.name])));
    } else if (card.type === 'virtual') {
      cards.push((0, _utils.toCustomCard)(rewriteUrl(card)));
    }
  }
  return cards;
}
function useFilteredCards(rewriteUrl, integrationsList, selectedCategory, customCards) {
  return (0, _react.useMemo)(() => {
    const integrationCards = integrationsList.filter(card => card.categories.some(category => selectedCategory.includes(category))).map(rewriteUrl).map(_utils.toCustomCard);
    if (!customCards) {
      return {
        featuredCards: {},
        integrationCards
      };
    }
    return {
      featuredCards: extractFeaturedCards(integrationsList, customCards.filter(c => c.type === 'featured').map(c => c.name)),
      integrationCards
    };
  }, [integrationsList, customCards, selectedCategory, rewriteUrl]);
}

/**
 * Formats the cards to display on the integration list.
 * @param integrationsList the list of cards from the integrations API.
 * @param selectedCategory the card category to filter by.
 * @param customCards any virtual or featured cards.
 * @param fullList when true all integration cards are included.
 * @returns the list of cards to display.
 */
function useIntegrationCardList(integrationsList, selectedCategory, customCards, flowCategory, flowSearch, fullList = false) {
  const rewriteUrl = useCardUrlRewrite({
    category: flowCategory,
    search: flowSearch
  });
  const {
    featuredCards,
    integrationCards
  } = useFilteredCards(rewriteUrl, integrationsList, selectedCategory, customCards);
  if (customCards && customCards.length > 0) {
    const formattedCustomCards = formatCustomCards(rewriteUrl, customCards, featuredCards);
    if (fullList) {
      return [...formattedCustomCards, ...integrationCards];
    }
    return formattedCustomCards;
  }
  return integrationCards;
}