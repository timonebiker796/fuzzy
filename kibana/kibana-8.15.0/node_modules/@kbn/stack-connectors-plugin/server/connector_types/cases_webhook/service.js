"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createExternalService = void 0;
var _axios = _interopRequireDefault(require("axios"));
var _mustache_renderer = require("@kbn/actions-plugin/server/lib/mustache_renderer");
var _axios_utils = require("@kbn/actions-plugin/server/lib/axios_utils");
var _lib = require("@kbn/actions-plugin/server/lib");
var _utils = require("../../../common/auth/utils");
var _validators = require("./validators");
var _utils2 = require("./utils");
var i18n = _interopRequireWildcard(require("./translations"));
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0; you may not use this file except in compliance with the Elastic License
 * 2.0.
 */

const createExternalService = (actionId, {
  config,
  secrets
}, logger, configurationUtilities) => {
  var _basicAuth$auth, _basicAuth$auth2;
  const {
    createCommentJson,
    createCommentMethod,
    createCommentUrl,
    createIncidentJson,
    createIncidentMethod,
    createIncidentResponseKey,
    createIncidentUrl: createIncidentUrlConfig,
    getIncidentResponseExternalTitleKey,
    getIncidentUrl,
    hasAuth,
    authType,
    headers,
    viewIncidentUrl,
    updateIncidentJson,
    updateIncidentMethod,
    updateIncidentUrl,
    verificationMode,
    ca
  } = config;
  const {
    basicAuth,
    sslOverrides
  } = (0, _utils.buildConnectorAuth)({
    hasAuth,
    authType,
    secrets,
    verificationMode,
    ca
  });
  (0, _utils.validateConnectorAuthConfiguration)({
    hasAuth,
    authType,
    basicAuth,
    sslOverrides,
    connectorName: i18n.NAME
  });
  if (!getIncidentUrl || !createIncidentUrlConfig || !viewIncidentUrl || !updateIncidentUrl) {
    throw Error(`[Action]${i18n.NAME}: Wrong configuration.`);
  }
  const headersWithBasicAuth = (0, _lib.combineHeadersWithBasicAuthHeader)({
    username: (_basicAuth$auth = basicAuth.auth) === null || _basicAuth$auth === void 0 ? void 0 : _basicAuth$auth.username,
    password: (_basicAuth$auth2 = basicAuth.auth) === null || _basicAuth$auth2 === void 0 ? void 0 : _basicAuth$auth2.password,
    headers
  });
  const axiosInstance = _axios.default.create({
    headers: {
      ['content-type']: 'application/json',
      ...headersWithBasicAuth
    }
  });
  const createIncidentUrl = (0, _utils2.removeSlash)(createIncidentUrlConfig);
  const getIncident = async id => {
    try {
      const getUrl = (0, _mustache_renderer.renderMustacheStringNoEscape)(getIncidentUrl, {
        external: {
          system: {
            id: encodeURIComponent(id)
          }
        }
      });
      const normalizedUrl = (0, _validators.validateAndNormalizeUrl)(`${getUrl}`, configurationUtilities, 'Get case URL');
      const res = await (0, _axios_utils.request)({
        axios: axiosInstance,
        url: normalizedUrl,
        logger,
        configurationUtilities,
        sslOverrides
      });
      (0, _utils2.throwDescriptiveErrorIfResponseIsNotValid)({
        res,
        requiredAttributesToBeInTheResponse: [getIncidentResponseExternalTitleKey]
      });
      const title = (0, _utils2.getObjectValueByKeyAsString)(res.data, getIncidentResponseExternalTitleKey);
      return {
        id,
        title
      };
    } catch (error) {
      throw (0, _utils2.createServiceError)(error, `Unable to get case with id ${id}`);
    }
  };
  const createIncident = async ({
    incident
  }) => {
    try {
      const {
        description,
        id,
        severity,
        status: incidentStatus,
        tags,
        title
      } = incident;
      const normalizedUrl = (0, _validators.validateAndNormalizeUrl)(`${createIncidentUrl}`, configurationUtilities, 'Create case URL');
      const json = (0, _mustache_renderer.renderMustacheStringNoEscape)(createIncidentJson, (0, _utils2.stringifyObjValues)({
        description: description !== null && description !== void 0 ? description : '',
        id: id !== null && id !== void 0 ? id : '',
        severity: severity !== null && severity !== void 0 ? severity : '',
        status: incidentStatus !== null && incidentStatus !== void 0 ? incidentStatus : '',
        tags: tags !== null && tags !== void 0 ? tags : [],
        title
      }));
      (0, _validators.validateJson)(json, 'Create case JSON body');
      const res = await (0, _axios_utils.request)({
        axios: axiosInstance,
        url: normalizedUrl,
        logger,
        method: createIncidentMethod,
        data: json,
        configurationUtilities,
        sslOverrides
      });
      const {
        status,
        statusText,
        data
      } = res;
      (0, _utils2.throwDescriptiveErrorIfResponseIsNotValid)({
        res,
        requiredAttributesToBeInTheResponse: [createIncidentResponseKey]
      });
      const externalId = (0, _utils2.getObjectValueByKeyAsString)(data, createIncidentResponseKey);
      const insertedIncident = await getIncident(externalId);
      logger.debug(`response from webhook action "${actionId}": [HTTP ${status}] ${statusText}`);
      const viewUrl = (0, _mustache_renderer.renderMustacheStringNoEscape)(viewIncidentUrl, {
        external: {
          system: {
            id: encodeURIComponent(externalId),
            title: encodeURIComponent(insertedIncident.title)
          }
        }
      });
      const normalizedViewUrl = (0, _validators.validateAndNormalizeUrl)(`${viewUrl}`, configurationUtilities, 'View case URL');
      return {
        id: externalId,
        title: insertedIncident.title,
        url: normalizedViewUrl,
        pushedDate: new Date().toISOString()
      };
    } catch (error) {
      throw (0, _utils2.createServiceError)(error, 'Unable to create case');
    }
  };
  const updateIncident = async ({
    incidentId,
    incident
  }) => {
    try {
      const updateUrl = (0, _mustache_renderer.renderMustacheStringNoEscape)(updateIncidentUrl, {
        external: {
          system: {
            id: encodeURIComponent(incidentId)
          }
        }
      });
      const normalizedUrl = (0, _validators.validateAndNormalizeUrl)(`${updateUrl}`, configurationUtilities, 'Update case URL');
      const {
        description,
        id,
        severity,
        status: incidentStatus,
        tags,
        title
      } = incident;
      const json = (0, _mustache_renderer.renderMustacheStringNoEscape)(updateIncidentJson, {
        ...(0, _utils2.stringifyObjValues)({
          description: description !== null && description !== void 0 ? description : '',
          id: id !== null && id !== void 0 ? id : '',
          severity: severity !== null && severity !== void 0 ? severity : '',
          status: incidentStatus !== null && incidentStatus !== void 0 ? incidentStatus : '',
          tags: tags !== null && tags !== void 0 ? tags : [],
          title
        }),
        external: {
          system: {
            id: JSON.stringify(incidentId)
          }
        }
      });
      (0, _validators.validateJson)(json, 'Update case JSON body');
      const res = await (0, _axios_utils.request)({
        axios: axiosInstance,
        method: updateIncidentMethod,
        url: normalizedUrl,
        logger,
        data: json,
        configurationUtilities,
        sslOverrides
      });
      (0, _utils2.throwDescriptiveErrorIfResponseIsNotValid)({
        res
      });
      const updatedIncident = await getIncident(incidentId);
      const viewUrl = (0, _mustache_renderer.renderMustacheStringNoEscape)(viewIncidentUrl, {
        external: {
          system: {
            id: encodeURIComponent(incidentId),
            title: encodeURIComponent(updatedIncident.title)
          }
        }
      });
      const normalizedViewUrl = (0, _validators.validateAndNormalizeUrl)(`${viewUrl}`, configurationUtilities, 'View case URL');
      return {
        id: incidentId,
        title: updatedIncident.title,
        url: normalizedViewUrl,
        pushedDate: new Date().toISOString()
      };
    } catch (error) {
      throw (0, _utils2.createServiceError)(error, `Unable to update case with id ${incidentId}`);
    }
  };
  const createComment = async ({
    incidentId,
    comment
  }) => {
    try {
      if (!createCommentUrl || !createCommentJson || !createCommentMethod) {
        return;
      }
      const commentUrl = (0, _mustache_renderer.renderMustacheStringNoEscape)(createCommentUrl, {
        external: {
          system: {
            id: encodeURIComponent(incidentId)
          }
        }
      });
      const normalizedUrl = (0, _validators.validateAndNormalizeUrl)(`${commentUrl}`, configurationUtilities, 'Create comment URL');
      const json = (0, _mustache_renderer.renderMustacheStringNoEscape)(createCommentJson, {
        ...(0, _utils2.stringifyObjValues)({
          comment: comment.comment
        }),
        external: {
          system: {
            id: JSON.stringify(incidentId)
          }
        }
      });
      (0, _validators.validateJson)(json, 'Create comment JSON body');
      const res = await (0, _axios_utils.request)({
        axios: axiosInstance,
        method: createCommentMethod,
        url: normalizedUrl,
        logger,
        data: json,
        configurationUtilities,
        sslOverrides
      });
      (0, _utils2.throwDescriptiveErrorIfResponseIsNotValid)({
        res
      });
    } catch (error) {
      throw (0, _utils2.createServiceError)(error, `Unable to create comment at case with id ${incidentId}`);
    }
  };
  return {
    createComment,
    createIncident,
    getIncident,
    updateIncident
  };
};
exports.createExternalService = createExternalService;