"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.reportingEventLoggerFactory = reportingEventLoggerFactory;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _deepmerge = _interopRequireDefault(require("deepmerge"));
var _reportingServer = require("@kbn/reporting-server");
var _ = require(".");
var _adapter = require("./adapter");
/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0; you may not use this file except in compliance with the Elastic License
 * 2.0.
 */

function reportingEventLoggerFactory(logger) {
  const genericLogger = new _adapter.EcsLogAdapter(logger, {
    event: {
      provider: _reportingServer.PLUGIN_ID
    }
  });
  return class ReportingEventLogger {
    constructor(report, task) {
      var _report$payload$brows, _report$payload, _report$jobtype;
      (0, _defineProperty2.default)(this, "eventObj", void 0);
      (0, _defineProperty2.default)(this, "report", void 0);
      (0, _defineProperty2.default)(this, "task", void 0);
      (0, _defineProperty2.default)(this, "completionLogger", void 0);
      this.report = report;
      this.task = task;
      this.eventObj = {
        event: {
          timezone: (_report$payload$brows = (_report$payload = report.payload) === null || _report$payload === void 0 ? void 0 : _report$payload.browserTimezone) !== null && _report$payload$brows !== void 0 ? _report$payload$brows : 'UTC'
        },
        kibana: {
          reporting: {
            id: report._id,
            jobType: (_report$jobtype = report.jobtype) !== null && _report$jobtype !== void 0 ? _report$jobtype : 'NULL'
          },
          ...(task !== null && task !== void 0 && task.id ? {
            task: {
              id: task.id
            }
          } : undefined)
        },
        user: report.created_by ? {
          name: report.created_by
        } : undefined
      };

      // create a "complete" logger that will use EventLog helpers to calculate timings
      this.completionLogger = new _adapter.EcsLogAdapter(logger, {
        event: {
          provider: _reportingServer.PLUGIN_ID
        }
      });
    }
    logScheduleTask() {
      const message = `queued report ${this.report._id}`;
      const event = (0, _deepmerge.default)({
        message,
        kibana: {
          reporting: {
            actionType: _.ActionType.SCHEDULE_TASK
          }
        }
      }, this.eventObj);
      genericLogger.logEvent(message, event);
      return event;
    }
    logExecutionStart() {
      const message = `starting ${this.report.jobtype} execution`;
      this.completionLogger.startTiming();
      const event = (0, _deepmerge.default)({
        message,
        kibana: {
          reporting: {
            actionType: _.ActionType.EXECUTE_START
          }
        }
      }, this.eventObj);
      genericLogger.logEvent(message, event);
      return event;
    }
    logExecutionComplete({
      byteSize,
      csv,
      pdf,
      png
    }) {
      const message = `completed ${this.report.jobtype} execution`;
      this.completionLogger.stopTiming();
      const event = (0, _deepmerge.default)({
        message,
        kibana: {
          reporting: {
            actionType: _.ActionType.EXECUTE_COMPLETE,
            byteSize,
            csv,
            pdf,
            png
          }
        }
      }, this.eventObj);
      this.completionLogger.logEvent(message, event);
      return event;
    }
    logError(error) {
      const message = `an error occurred`;
      const logErrorMessage = {
        message,
        kibana: {
          reporting: {
            actionType: _.ActionType.EXECUTE_ERROR
          }
        },
        error: {
          message: error.message,
          code: error.code,
          stack_trace: error.stack_trace,
          type: error.type
        }
      };
      const event = (0, _deepmerge.default)(logErrorMessage, this.eventObj);
      genericLogger.logEvent(message, event);
      return event;
    }
    logClaimTask({
      queueDurationMs
    }) {
      const message = `claimed report ${this.report._id}`;
      const queueDurationNs = queueDurationMs * 1000000;
      const event = (0, _deepmerge.default)({
        message,
        kibana: {
          reporting: {
            actionType: _.ActionType.CLAIM_TASK
          }
        },
        event: {
          duration: queueDurationNs
        } // this field is nanoseconds by ECS definition
      }, this.eventObj);
      genericLogger.logEvent(message, event);
      return event;
    }
    logReportFailure() {
      const message = `report ${this.report._id} has failed`;
      const event = (0, _deepmerge.default)({
        message,
        kibana: {
          reporting: {
            actionType: _.ActionType.FAIL_REPORT
          }
        }
      }, this.eventObj);
      genericLogger.logEvent(message, event);
      return event;
    }
    logReportSaved() {
      const message = `saved report ${this.report._id}`;
      const event = (0, _deepmerge.default)({
        message,
        kibana: {
          reporting: {
            actionType: _.ActionType.SAVE_REPORT
          }
        }
      }, this.eventObj);
      genericLogger.logEvent(message, event);
      return event;
    }
    logRetry() {
      const message = `scheduled retry for report ${this.report._id}`;
      const event = (0, _deepmerge.default)({
        message,
        kibana: {
          reporting: {
            actionType: _.ActionType.RETRY
          }
        }
      }, this.eventObj);
      genericLogger.logEvent(message, event);
      return event;
    }
  };
}