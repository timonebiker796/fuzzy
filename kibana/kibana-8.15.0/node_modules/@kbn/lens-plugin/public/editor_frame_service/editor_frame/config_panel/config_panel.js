"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ConfigPanelWrapper = void 0;
exports.LayerPanels = LayerPanels;
var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));
var _react = _interopRequireWildcard(require("react"));
var _eui = require("@elastic/eui");
var _esQuery = require("@kbn/es-query");
var _public = require("@kbn/unified-search-plugin/public");
var _lens_slice = require("../../../state_management/lens_slice");
var _layer_panel = require("./layer_panel");
var _id_generator = require("../../../id_generator");
var _use_focus_update = require("./use_focus_update");
var _state_management = require("../../../state_management");
var _utils = require("../../../utils");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0; you may not use this file except in compliance with the Elastic License
 * 2.0.
 */

const ConfigPanelWrapper = exports.ConfigPanelWrapper = /*#__PURE__*/(0, _react.memo)(function ConfigPanelWrapper(props) {
  const visualization = (0, _state_management.useLensSelector)(_state_management.selectVisualization);
  const activeVisualization = visualization.activeId ? props.visualizationMap[visualization.activeId] : null;
  return activeVisualization && visualization.state ? /*#__PURE__*/_react.default.createElement(LayerPanels, (0, _extends2.default)({}, props, {
    activeVisualization: activeVisualization
  })) : null;
});
function LayerPanels(props) {
  var _activeVisualization$3;
  const {
    activeVisualization,
    datasourceMap,
    indexPatternService
  } = props;
  const {
    activeDatasourceId,
    visualization,
    datasourceStates,
    query
  } = (0, _state_management.useLensSelector)(state => state.lens);
  const dispatchLens = (0, _state_management.useLensDispatch)();
  const layerIds = activeVisualization.getLayerIds(visualization.state);
  const {
    setNextFocusedId: setNextFocusedLayerId,
    removeRef: removeLayerRef,
    registerNewRef: registerNewLayerRef
  } = (0, _use_focus_update.useFocusUpdate)(layerIds);
  const setVisualizationState = (0, _react.useMemo)(() => newState => {
    dispatchLens((0, _state_management.updateVisualizationState)({
      visualizationId: activeVisualization.id,
      newState
    }));
  }, [activeVisualization.id, dispatchLens]);
  const updateDatasource = (0, _react.useMemo)(() => (datasourceId, newState, dontSyncLinkedDimensions) => {
    if (datasourceId) {
      dispatchLens((0, _state_management.updateDatasourceState)({
        newDatasourceState: typeof newState === 'function' ? newState(datasourceStates[datasourceId].state) : newState,
        datasourceId,
        clearStagedPreview: false,
        dontSyncLinkedDimensions
      }));
    }
  }, [dispatchLens, datasourceStates]);
  const updateDatasourceAsync = (0, _react.useMemo)(() => (datasourceId, newState) => {
    // React will synchronously update if this is triggered from a third party component,
    // which we don't want. The timeout lets user interaction have priority, then React updates.
    setTimeout(() => {
      updateDatasource(datasourceId, newState);
    });
  }, [updateDatasource]);
  const updateAll = (0, _react.useMemo)(() => (datasourceId, newDatasourceState, newVisualizationState) => {
    if (!datasourceId) return;
    // React will synchronously update if this is triggered from a third party component,
    // which we don't want. The timeout lets user interaction have priority, then React updates.

    setTimeout(() => {
      const newDsState = typeof newDatasourceState === 'function' ? newDatasourceState(datasourceStates[datasourceId].state) : newDatasourceState;
      const newVisState = typeof newVisualizationState === 'function' ? newVisualizationState(visualization.state) : newVisualizationState;
      dispatchLens((0, _state_management.updateVisualizationState)({
        visualizationId: activeVisualization.id,
        newState: newVisState,
        dontSyncLinkedDimensions: true // TODO: to refactor: this is quite brittle, we avoid to sync linked dimensions because we do it with datasourceState update
      }));
      dispatchLens((0, _state_management.updateDatasourceState)({
        newDatasourceState: newDsState,
        datasourceId,
        clearStagedPreview: false
      }));
    }, 0);
  }, [dispatchLens, visualization.state, datasourceStates, activeVisualization.id]);
  const toggleFullscreen = (0, _react.useCallback)(() => {
    dispatchLens((0, _state_management.setToggleFullscreen)());
  }, [dispatchLens]);
  const handleDimensionDrop = (0, _react.useCallback)(payload => {
    dispatchLens((0, _lens_slice.onDropToDimension)(payload));
  }, [dispatchLens]);
  const onRemoveLayer = (0, _react.useCallback)(layerToRemoveId => {
    var _props$framePublicAPI;
    const datasourcePublicAPI = (_props$framePublicAPI = props.framePublicAPI.datasourceLayers) === null || _props$framePublicAPI === void 0 ? void 0 : _props$framePublicAPI[layerToRemoveId];
    const datasourceId = datasourcePublicAPI === null || datasourcePublicAPI === void 0 ? void 0 : datasourcePublicAPI.datasourceId;
    if (datasourceId) {
      var _datasourceStates$dat;
      const layerDatasource = datasourceMap[datasourceId];
      const layerDatasourceState = datasourceStates === null || datasourceStates === void 0 ? void 0 : (_datasourceStates$dat = datasourceStates[datasourceId]) === null || _datasourceStates$dat === void 0 ? void 0 : _datasourceStates$dat.state;
      const trigger = props.uiActions.getTrigger(_public.UPDATE_FILTER_REFERENCES_TRIGGER);
      const action = props.uiActions.getAction(_public.UPDATE_FILTER_REFERENCES_ACTION);
      action === null || action === void 0 ? void 0 : action.execute({
        trigger,
        fromDataView: layerDatasource.getUsedDataView(layerDatasourceState, layerToRemoveId),
        usedDataViews: layerDatasource.getLayers(layerDatasourceState).map(layer => layerDatasource.getUsedDataView(layerDatasourceState, layer)),
        defaultDataView: layerDatasource.getUsedDataView(layerDatasourceState)
      });
    }
    dispatchLens((0, _state_management.removeOrClearLayer)({
      visualizationId: activeVisualization.id,
      layerId: layerToRemoveId,
      layerIds
    }));
    removeLayerRef(layerToRemoveId);
  }, [activeVisualization.id, datasourceMap, datasourceStates, dispatchLens, layerIds, props.framePublicAPI.datasourceLayers, props.uiActions, removeLayerRef]);
  const onChangeIndexPattern = (0, _react.useCallback)(async ({
    indexPatternId,
    datasourceId,
    visualizationId,
    layerId
  }) => {
    var _props$indexPatternSe;
    const indexPatterns = await ((_props$indexPatternSe = props.indexPatternService) === null || _props$indexPatternSe === void 0 ? void 0 : _props$indexPatternSe.ensureIndexPattern({
      id: indexPatternId,
      cache: props.framePublicAPI.dataViews.indexPatterns
    }));
    if (indexPatterns) {
      dispatchLens((0, _lens_slice.changeIndexPattern)({
        indexPatternId,
        datasourceIds: datasourceId ? [datasourceId] : [],
        visualizationIds: visualizationId ? [visualizationId] : [],
        layerId,
        dataViews: {
          indexPatterns
        }
      }));
    }
  }, [dispatchLens, props.framePublicAPI.dataViews.indexPatterns, props.indexPatternService]);
  const addLayer = (layerType, extraArg, ignoreInitialValues, seriesType) => {
    const layerId = (0, _id_generator.generateId)();
    dispatchLens((0, _state_management.addLayer)({
      layerId,
      layerType,
      extraArg,
      ignoreInitialValues,
      seriesType
    }));
    setNextFocusedLayerId(layerId);
  };
  const registerLibraryAnnotationGroupFunction = (0, _react.useCallback)(groupInfo => dispatchLens((0, _state_management.registerLibraryAnnotationGroup)(groupInfo)), [dispatchLens]);
  const hideAddLayerButton = query && (0, _esQuery.isOfAggregateQueryType)(query);
  return /*#__PURE__*/_react.default.createElement(_eui.EuiForm, {
    className: "lnsConfigPanel"
  }, layerIds.map((layerId, layerIndex) => {
    const {
      hidden,
      groups
    } = activeVisualization.getConfiguration({
      layerId,
      frame: props.framePublicAPI,
      state: visualization.state
    });
    return !hidden && /*#__PURE__*/_react.default.createElement(_layer_panel.LayerPanel, (0, _extends2.default)({}, props, {
      onDropToDimension: handleDimensionDrop,
      registerLibraryAnnotationGroup: registerLibraryAnnotationGroupFunction,
      dimensionGroups: groups,
      activeVisualization: activeVisualization,
      registerNewLayerRef: registerNewLayerRef,
      key: layerId,
      layerId: layerId,
      layerIndex: layerIndex,
      visualizationState: visualization.state,
      visualizationMap: props.visualizationMap,
      updateVisualization: setVisualizationState,
      updateDatasource: updateDatasource,
      updateDatasourceAsync: updateDatasourceAsync,
      displayLayerSettings: !props.hideLayerHeader,
      onlyAllowSwitchToSubtypes: props.onlyAllowSwitchToSubtypes,
      onChangeIndexPattern: args => {
        var _activeVisualization$, _activeVisualization$2;
        onChangeIndexPattern(args);
        const layersToRemove = (_activeVisualization$ = (_activeVisualization$2 = activeVisualization.getLayersToRemoveOnIndexPatternChange) === null || _activeVisualization$2 === void 0 ? void 0 : _activeVisualization$2.call(activeVisualization, visualization.state)) !== null && _activeVisualization$ !== void 0 ? _activeVisualization$ : [];
        layersToRemove.forEach(id => onRemoveLayer(id));
      },
      updateAll: updateAll,
      addLayer: addLayer,
      isOnlyLayer: (0, _utils.getRemoveOperation)(activeVisualization, visualization.state, layerId, layerIds.length) === 'clear',
      onEmptyDimensionAdd: (columnId, {
        groupId
      }) => {
        var _datasourceMap$active;
        // avoid state update if the datasource does not support initializeDimension
        if (activeDatasourceId != null && (_datasourceMap$active = datasourceMap[activeDatasourceId]) !== null && _datasourceMap$active !== void 0 && _datasourceMap$active.initializeDimension) {
          dispatchLens((0, _state_management.setLayerDefaultDimension)({
            layerId,
            columnId,
            groupId
          }));
        }
      },
      onCloneLayer: () => {
        dispatchLens((0, _state_management.cloneLayer)({
          layerId
        }));
      },
      onRemoveLayer: onRemoveLayer,
      onRemoveDimension: dimensionProps => {
        var _props$framePublicAPI2;
        const datasourcePublicAPI = (_props$framePublicAPI2 = props.framePublicAPI.datasourceLayers) === null || _props$framePublicAPI2 === void 0 ? void 0 : _props$framePublicAPI2[layerId];
        const datasourceId = datasourcePublicAPI === null || datasourcePublicAPI === void 0 ? void 0 : datasourcePublicAPI.datasourceId;
        dispatchLens((0, _lens_slice.removeDimension)({
          ...dimensionProps,
          datasourceId
        }));
      },
      toggleFullscreen: toggleFullscreen,
      indexPatternService: indexPatternService
    }));
  }), !hideAddLayerButton && (activeVisualization === null || activeVisualization === void 0 ? void 0 : (_activeVisualization$3 = activeVisualization.getAddLayerButtonComponent) === null || _activeVisualization$3 === void 0 ? void 0 : _activeVisualization$3.call(activeVisualization, {
    state: visualization.state,
    supportedLayers: activeVisualization.getSupportedLayers(visualization.state, props.framePublicAPI),
    addLayer,
    ensureIndexPattern: async specOrId => {
      let indexPatternId;
      if (typeof specOrId === 'string') {
        indexPatternId = specOrId;
      } else {
        const dataView = await props.dataViews.create(specOrId);
        if (!dataView.id) {
          return;
        }
        indexPatternId = dataView.id;
      }
      const newIndexPatterns = await (indexPatternService === null || indexPatternService === void 0 ? void 0 : indexPatternService.ensureIndexPattern({
        id: indexPatternId,
        cache: props.framePublicAPI.dataViews.indexPatterns
      }));
      if (newIndexPatterns) {
        dispatchLens((0, _lens_slice.changeIndexPattern)({
          dataViews: {
            indexPatterns: newIndexPatterns
          },
          datasourceIds: Object.keys(datasourceStates),
          visualizationIds: visualization.activeId ? [visualization.activeId] : [],
          indexPatternId
        }));
      }
    },
    registerLibraryAnnotationGroup: registerLibraryAnnotationGroupFunction,
    isInlineEditing: Boolean(props === null || props === void 0 ? void 0 : props.setIsInlineFlyoutVisible)
  })));
}