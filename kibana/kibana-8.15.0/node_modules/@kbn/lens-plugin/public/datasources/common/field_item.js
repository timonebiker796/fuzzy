"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FieldItem = void 0;
exports.InnerFieldItem = InnerFieldItem;
var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));
require("./field_item.scss");
var _react = _interopRequireWildcard(require("react"));
var _eui = require("@elastic/eui");
var _i18n = require("@kbn/i18n");
var _public = require("@kbn/kibana-react-plugin/public");
var _common = require("@kbn/data-views-plugin/common");
var _unifiedFieldList = require("@kbn/unified-field-list");
var _domDragDrop = require("@kbn/dom-drag-drop");
var _public2 = require("@kbn/data-plugin/public");
var _constants = require("../../../common/constants");
var _show_underlying_data = require("../../app_plugin/show_underlying_data");
var _get_field_item_actions = require("./get_field_item_actions");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0; you may not use this file except in compliance with the Elastic License
 * 2.0.
 */

function isTextBasedColumnField(field) {
  return !('type' in field) && Boolean(field === null || field === void 0 ? void 0 : field.meta.type);
}
function InnerFieldItem(props) {
  var _services$data, _services$data$query;
  const {
    field,
    indexPattern,
    highlight,
    exists,
    hideDetails,
    itemIndex,
    groupIndex,
    dropOntoWorkspace,
    hasSuggestionForField,
    editField,
    removeField,
    getCustomFieldType
  } = props;
  const dataViewField = (0, _react.useMemo)(() => {
    // DatatableColumn type
    if (isTextBasedColumnField(field)) {
      var _field$meta$type, _field$meta;
      return new _common.DataViewField({
        name: field.name,
        type: (_field$meta$type = (_field$meta = field.meta) === null || _field$meta === void 0 ? void 0 : _field$meta.type) !== null && _field$meta$type !== void 0 ? _field$meta$type : 'unknown',
        searchable: true,
        aggregatable: true
      });
    }
    // IndexPatternField type
    return new _common.DataViewField(field);
  }, [field]);
  const services = (0, _public.useKibana)().services;
  const filterManager = services === null || services === void 0 ? void 0 : (_services$data = services.data) === null || _services$data === void 0 ? void 0 : (_services$data$query = _services$data.query) === null || _services$data$query === void 0 ? void 0 : _services$data$query.filterManager;
  const [infoIsOpen, setOpen] = (0, _react.useState)(false);
  const togglePopover = (0, _react.useCallback)(() => {
    setOpen(value => !value);
  }, [setOpen]);
  const closePopover = (0, _react.useCallback)(() => {
    setOpen(false);
  }, [setOpen]);
  const addFilterAndClose = (0, _react.useMemo)(() => filterManager && indexPattern ? (clickedField, values, operation) => {
    closePopover();
    const newFilters = (0, _public2.generateFilters)(filterManager, clickedField, values, operation, indexPattern);
    filterManager.addFilters(newFilters);
  } : undefined, [indexPattern, filterManager, closePopover]);
  const editFieldAndClose = (0, _react.useMemo)(() => editField && dataViewField.name !== _constants.DOCUMENT_FIELD_NAME ? name => {
    closePopover();
    editField(name);
  } : undefined, [editField, closePopover, dataViewField.name]);
  const removeFieldAndClose = (0, _react.useMemo)(() => removeField ? name => {
    closePopover();
    removeField(name);
  } : undefined, [removeField, closePopover]);
  const indexPatternId = indexPattern === null || indexPattern === void 0 ? void 0 : indexPattern.id;
  const value = (0, _react.useMemo)(() => isTextBasedColumnField(field) ? {
    field: field.name,
    id: field.id,
    humanData: {
      label: field.name
    }
  } : {
    field,
    indexPatternId,
    id: field.name,
    humanData: {
      label: field.displayName,
      position: itemIndex + 1
    }
  }, [field, indexPatternId, itemIndex]);
  const order = (0, _react.useMemo)(() => [0, groupIndex, itemIndex], [groupIndex, itemIndex]);
  const {
    buttonAddFieldToWorkspaceProps,
    onAddFieldToWorkspace
  } = (0, _get_field_item_actions.getFieldItemActions)({
    value,
    hasSuggestionForField,
    dropOntoWorkspace,
    closeFieldPopover: closePopover
  });
  const commonFieldItemButtonProps = {
    isSelected: false,
    // multiple selections are allowed
    isEmpty: !exists,
    isActive: infoIsOpen,
    withDragIcon: true,
    fieldSearchHighlight: highlight,
    onClick: togglePopover,
    buttonAddFieldToWorkspaceProps,
    onAddFieldToWorkspace
  };
  return /*#__PURE__*/_react.default.createElement("li", null, /*#__PURE__*/_react.default.createElement(_unifiedFieldList.FieldPopover, {
    isOpen: infoIsOpen,
    closePopover: closePopover,
    panelClassName: "lnsFieldItem__fieldPanel",
    initialFocus: ".lnsFieldItem__fieldPanel",
    "data-test-subj": "lnsFieldListPanelField",
    panelProps: {
      'data-test-subj': 'lnsFieldListPanelFieldContent'
    },
    container: document.querySelector('.application') || undefined,
    button: /*#__PURE__*/_react.default.createElement(_domDragDrop.Draggable, {
      dragType: "copy",
      value: value,
      order: order,
      onDragStart: closePopover,
      dataTestSubj: `lnsFieldListPanelField-${field.name}`
    }, isTextBasedColumnField(field) ? /*#__PURE__*/_react.default.createElement(_unifiedFieldList.FieldItemButton, (0, _extends2.default)({
      field: field,
      getCustomFieldType: getCustomFieldType
    }, commonFieldItemButtonProps)) : /*#__PURE__*/_react.default.createElement(_unifiedFieldList.FieldItemButton, (0, _extends2.default)({
      field: field
    }, commonFieldItemButtonProps))),
    renderHeader: () => {
      return /*#__PURE__*/_react.default.createElement(_unifiedFieldList.FieldPopoverHeader, {
        field: dataViewField,
        closePopover: closePopover,
        buttonAddFieldToWorkspaceProps: buttonAddFieldToWorkspaceProps,
        onAddFieldToWorkspace: onAddFieldToWorkspace,
        onAddFilter: addFilterAndClose,
        onEditField: editFieldAndClose,
        onDeleteField: removeFieldAndClose
      });
    },
    renderContent: !hideDetails ? () => /*#__PURE__*/_react.default.createElement(FieldItemPopoverContents, (0, _extends2.default)({}, props, {
      dataViewField: dataViewField,
      onAddFilter: addFilterAndClose
    })) : undefined
  }));
}
const FieldItem = exports.FieldItem = /*#__PURE__*/_react.default.memo(InnerFieldItem);
function FieldItemPopoverContents(props) {
  const {
    query,
    filters,
    indexPattern,
    dataViewField,
    dateRange,
    onAddFilter
  } = props;
  const services = (0, _public.useKibana)().services;
  const exploreInDiscover = (0, _react.useMemo)(() => {
    var _services$share;
    if (!indexPattern) {
      return null;
    }
    const meta = {
      id: indexPattern.id,
      columns: [dataViewField.name],
      filters: {
        enabled: {
          lucene: [],
          kuery: []
        },
        disabled: {
          lucene: [],
          kuery: []
        }
      }
    };
    const {
      filters: newFilters,
      query: newQuery
    } = (0, _show_underlying_data.combineQueryAndFilters)(query, filters, meta, [indexPattern], (0, _public2.getEsQueryConfig)(services.uiSettings));
    const discoverLocator = (_services$share = services.share) === null || _services$share === void 0 ? void 0 : _services$share.url.locators.get('DISCOVER_APP_LOCATOR');
    if (!discoverLocator || !services.application.capabilities.discover.show) {
      return;
    }
    return discoverLocator.getRedirectUrl({
      dataViewSpec: indexPattern === null || indexPattern === void 0 ? void 0 : indexPattern.spec,
      timeRange: services.data.query.timefilter.timefilter.getTime(),
      filters: newFilters,
      query: newQuery,
      columns: meta.columns
    });
  }, [dataViewField.name, filters, indexPattern, query, services]);
  if (!indexPattern) {
    return null;
  }
  return /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, /*#__PURE__*/_react.default.createElement(_unifiedFieldList.FieldStats, {
    services: services,
    query: query,
    filters: filters,
    fromDate: dateRange.fromDate,
    toDate: dateRange.toDate,
    dataViewOrDataViewId: indexPattern.id // TODO: Refactor to pass a variable with DataView type instead of IndexPattern
    ,
    onAddFilter: onAddFilter,
    field: dataViewField,
    "data-test-subj": "lnsFieldListPanel",
    overrideMissingContent: params => {
      if (params.reason === 'no-data') {
        // TODO: should we replace this with a default message "Analysis is not available for this field?"
        return /*#__PURE__*/_react.default.createElement(_eui.EuiText, {
          size: "s",
          "data-test-subj": "lnsFieldListPanel-missingFieldStats"
        }, _i18n.i18n.translate('xpack.lens.indexPattern.fieldStatsNoData', {
          defaultMessage: 'Lens is unable to create visualizations with this field because it does not contain data. To create a visualization, drag and drop a different field.'
        }));
      }
      if (params.reason === 'unsupported') {
        return /*#__PURE__*/_react.default.createElement(_eui.EuiText, {
          "data-test-subj": "lnsFieldListPanel-missingFieldStats"
        }, params.element);
      }
      return params.element;
    }
  }), dataViewField.type === 'geo_point' || dataViewField.type === 'geo_shape' ? /*#__PURE__*/_react.default.createElement(_unifiedFieldList.FieldPopoverFooter, {
    field: dataViewField,
    dataView: {
      ...indexPattern,
      toSpec: () => indexPattern.spec
    },
    originatingApp: _constants.APP_ID,
    uiActions: services.uiActions,
    buttonProps: {
      'data-test-subj': `lensVisualize-GeoField-${dataViewField.name}`
    }
  }) : exploreInDiscover ? /*#__PURE__*/_react.default.createElement(_eui.EuiPopoverFooter, null, /*#__PURE__*/_react.default.createElement(_eui.EuiButton, {
    fullWidth: true,
    size: "s",
    href: exploreInDiscover,
    target: "_blank",
    "data-test-subj": `lnsFieldListPanel-exploreInDiscover-${dataViewField.name}`
  }, _i18n.i18n.translate('xpack.lens.indexPattern.fieldExploreInDiscover', {
    defaultMessage: 'Explore in Discover'
  }))) : null);
}