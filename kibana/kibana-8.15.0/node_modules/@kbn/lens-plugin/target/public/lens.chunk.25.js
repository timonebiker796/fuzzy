/*! Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one or more contributor license agreements.
 * Licensed under the Elastic License 2.0; you may not use this file except in compliance with the Elastic License 2.0. */
(window.lens_bundle_jsonpfunction=window.lens_bundle_jsonpfunction||[]).push([[25],{675:function(e,n,t){"use strict";t.r(n),t.d(n,"getTimeBounds",(function(){return r})),t.d(n,"timeScaleFn",(function(){return d}));var o=t(63),a=t.n(o),i=t(0),s=t(51),u=t(12);const l={s:1e3,m:6e4,h:36e5,d:864e5};function c(e){const n=a.a.tz.zone(e);n&&a.a.tz.setDefault(n.name)}function r(e,n,t){if(n){var o;const i=null===(o=a.a.defaultZone)||void 0===o?void 0:o.name;c(n);const s=Object(u.calculateBounds)(e,{forceNow:null==t?void 0:t()});return c(i),s}return Object(u.calculateBounds)(e,{forceNow:null==t?void 0:t()})}const d=(e,n,t)=>async(o,{dateColumnId:c,inputColumnId:d,outputColumnId:m,outputColumnName:f,targetUnit:g,reducedTimeRange:v},w)=>{let p;const O=await n(w);let C;if(c){const n=o.columns.find((e=>e.id===c));if(!n)throw new Error(i.i18n.translate("xpack.lens.functions.timeScale.dateColumnMissingMessage",{defaultMessage:"Specified dateColumnId {columnId} does not exist.",values:{columnId:c}}));const s=(await e(w)).getDateHistogramMeta(n,{timeZone:O}),l=(null==s?void 0:s.interval)&&Object(u.parseInterval)(s.interval);if(p=(null==s?void 0:s.timeRange)&&r(s.timeRange,null==s?void 0:s.timeZone,t),C=e=>{var n;const t=a.a.tz(e[c],null!==(n=null==s?void 0:s.timeZone)&&void 0!==n?n:O);return{startOfBucket:t,endOfBucket:t.clone().add(l)}},!s||!l)throw new Error(i.i18n.translate("xpack.lens.functions.timeScale.timeInfoMissingMessage",{defaultMessage:"Could not fetch date histogram information"}))}else{const e=w.getSearchContext().timeRange;if(p=r(e,O,t),!p.max||!p.min)throw new Error(i.i18n.translate("xpack.lens.functions.timeScale.timeBoundsMissingMessage",{defaultMessage:'Could not parse "Time Range"'}));const n=p.max;let o=p.min;if(v){const e=n.clone().subtract(Object(u.parseInterval)(v));e>o&&(o=e)}C=()=>({startOfBucket:o,endOfBucket:n})}const b=Object(s.buildResultColumns)(o,m,d,f,{allowColumnOverwrite:!0});return b?{...o,columns:b,rows:o.rows.map((e=>{const n={...e};let{startOfBucket:t,endOfBucket:o}=C(e);p&&p.min&&(t=a.a.max(t,p.min)),p&&p.max&&(o=a.a.min(o,p.max));const i=o.diff(t)/l[g],s=n[d];return null!=s&&(n[m]=Number(s)/i),n}))}:o}}}]);