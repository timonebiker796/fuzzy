"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ExpressionsService = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _executor = require("../executor");
var _expression_renderers = require("../expression_renderers");
var _expression_functions = require("../expression_functions");
var _expressions_fork = require("./expressions_fork");
var _ExpressionsService;
/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0 and the Server Side Public License, v 1; you may not use this file except
 * in compliance with, at your election, the Elastic License 2.0 or the Server
 * Side Public License, v 1.
 */
/**
 * The public contract that `ExpressionsService` provides to other plugins
 * in Kibana Platform in *setup* life-cycle.
 */

/**
 * The public contract that `ExpressionsService` provides to other plugins
 * in Kibana Platform in *start* life-cycle.
 */

/**
 * `ExpressionsService` class is used for multiple purposes:
 *
 * 1. It implements the same Expressions service that can be used on both:
 *    (1) server-side and (2) browser-side.
 * 2. It implements the same Expressions service that users can fork/clone,
 *    thus have their own instance of the Expressions plugin.
 * 3. `ExpressionsService` defines the public contracts of *setup* and *start*
 *    Kibana Platform life-cycles for ease-of-use on server-side and browser-side.
 * 4. `ExpressionsService` creates a bound version of all exported contract functions.
 * 5. Functions are bound the way there are:
 *
 *    ```ts
 *    registerFunction = (...args: Parameters<Executor['registerFunction']>
 *      ): ReturnType<Executor['registerFunction']> => this.executor.registerFunction(...args);
 *    ```
 *
 *    so that JSDoc appears in developers IDE when they use those `plugins.expressions.registerFunction(`.
 */
class ExpressionsService {
  constructor({
    logger,
    executor = _executor.Executor.createWithDefaults(logger),
    renderers = new _expression_renderers.ExpressionRendererRegistry()
  } = {}) {
    (0, _defineProperty2.default)(this, "executor", void 0);
    (0, _defineProperty2.default)(this, "renderers", void 0);
    (0, _defineProperty2.default)(this, "getFunction", (name, namespace) => this.executor.getFunction(name, namespace));
    (0, _defineProperty2.default)(this, "getFunctions", namespace => this.executor.getFunctions(namespace));
    (0, _defineProperty2.default)(this, "getRenderer", name => {
      this.assertStart();
      return this.renderers.get(name);
    });
    (0, _defineProperty2.default)(this, "getRenderers", () => {
      this.assertStart();
      return this.renderers.toJS();
    });
    (0, _defineProperty2.default)(this, "getType", name => {
      this.assertStart();
      return this.executor.getType(name);
    });
    (0, _defineProperty2.default)(this, "getTypes", () => this.executor.getTypes());
    (0, _defineProperty2.default)(this, "registerFunction", functionDefinition => this.executor.registerFunction(functionDefinition));
    (0, _defineProperty2.default)(this, "registerType", typeDefinition => this.executor.registerType(typeDefinition));
    (0, _defineProperty2.default)(this, "registerRenderer", definition => this.renderers.register(definition));
    (0, _defineProperty2.default)(this, "fork", name => {
      this.assertSetup();
      const fork = new _expressions_fork.ExpressionsServiceFork(name, this);
      return fork;
    });
    (0, _defineProperty2.default)(this, "execute", (ast, input, params) => {
      this.assertStart();
      const execution = this.executor.createExecution(ast, params);
      execution.start(input);
      return execution.contract;
    });
    (0, _defineProperty2.default)(this, "run", (ast, input, params) => {
      this.assertStart();
      return this.executor.run(ast, input, params);
    });
    /**
     * Extracts telemetry from expression AST
     * @param state expression AST to extract references from
     */
    (0, _defineProperty2.default)(this, "telemetry", (state, telemetryData = {}) => {
      return this.executor.telemetry(state, telemetryData);
    });
    /**
     * Extracts saved object references from expression AST
     * @param state expression AST to extract references from
     * @returns new expression AST with references removed and array of references
     */
    (0, _defineProperty2.default)(this, "extract", state => {
      return this.executor.extract(state);
    });
    /**
     * Injects saved object references into expression AST
     * @param state expression AST to update
     * @param references array of saved object references
     * @returns new expression AST with references injected
     */
    (0, _defineProperty2.default)(this, "inject", (state, references) => {
      return this.executor.inject(state, references);
    });
    /**
     * gets an object with semver mapped to a migration function
     */
    (0, _defineProperty2.default)(this, "getAllMigrations", () => {
      return this.executor.getAllMigrations();
    });
    /**
     * migrates an old expression to latest version
     * @param state
     */
    (0, _defineProperty2.default)(this, "migrateToLatest", state => {
      return this.executor.migrateToLatest(state);
    });
    this.executor = executor;
    this.renderers = renderers;
  }
  isStarted() {
    return ExpressionsService.started.has(this);
  }
  assertSetup() {
    if (this.isStarted()) {
      throw new Error('The expression service is already started and can no longer be configured.');
    }
  }
  assertStart() {
    if (!this.isStarted()) {
      throw new Error('The expressions service has not started yet.');
    }
  }
  /**
   * Returns Kibana Platform *setup* life-cycle contract. Useful to return the
   * same contract on server-side and browser-side.
   */
  setup(...args) {
    for (const fn of [_expression_functions.clog, _expression_functions.createTable, _expression_functions.font, _expression_functions.variableSet, _expression_functions.variable, _expression_functions.theme, _expression_functions.cumulativeSum, _expression_functions.derivative, _expression_functions.movingAverage, _expression_functions.overallMetric, _expression_functions.mapColumn, _expression_functions.math, _expression_functions.mathColumn]) {
      this.registerFunction(fn);
    }
    return this;
  }

  /**
   * Returns Kibana Platform *start* life-cycle contract. Useful to return the
   * same contract on server-side and browser-side.
   */
  start(...args) {
    ExpressionsService.started.add(this);
    return this;
  }
  stop() {
    ExpressionsService.started.delete(this);
  }
}
exports.ExpressionsService = ExpressionsService;
_ExpressionsService = ExpressionsService;
/**
 * @note Workaround since the expressions service is frozen.
 */
(0, _defineProperty2.default)(ExpressionsService, "started", new WeakSet());