"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ClusterClient = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _coreHttpRouterServerInternal = require("@kbn/core-http-router-server-internal");
var _configure_client = require("./configure_client");
var _scoped_cluster_client = require("./scoped_cluster_client");
var _headers = require("./headers");
var _retry_unauthorized = require("./retry_unauthorized");
var _create_transport = require("./create_transport");
/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0 and the Server Side Public License, v 1; you may not use this file except
 * in compliance with, at your election, the Elastic License 2.0 or the Server
 * Side Public License, v 1.
 */

const noop = () => undefined;

/** @internal **/
class ClusterClient {
  constructor({
    config,
    logger,
    type,
    authHeaders,
    getExecutionContext = noop,
    getUnauthorizedErrorHandler = noop,
    agentFactoryProvider,
    kibanaVersion
  }) {
    (0, _defineProperty2.default)(this, "config", void 0);
    (0, _defineProperty2.default)(this, "authHeaders", void 0);
    (0, _defineProperty2.default)(this, "rootScopedClient", void 0);
    (0, _defineProperty2.default)(this, "kibanaVersion", void 0);
    (0, _defineProperty2.default)(this, "getUnauthorizedErrorHandler", void 0);
    (0, _defineProperty2.default)(this, "getExecutionContext", void 0);
    (0, _defineProperty2.default)(this, "isClosed", false);
    (0, _defineProperty2.default)(this, "asInternalUser", void 0);
    (0, _defineProperty2.default)(this, "createInternalErrorHandlerAccessor", request => {
      if (!this.authHeaders) {
        return undefined;
      }
      return () => (0, _retry_unauthorized.createInternalErrorHandler)({
        request,
        getHandler: this.getUnauthorizedErrorHandler,
        setAuthHeaders: this.authHeaders.set
      });
    });
    this.config = config;
    this.authHeaders = authHeaders;
    this.kibanaVersion = kibanaVersion;
    this.getExecutionContext = getExecutionContext;
    this.getUnauthorizedErrorHandler = getUnauthorizedErrorHandler;
    this.asInternalUser = (0, _configure_client.configureClient)(config, {
      logger,
      type,
      getExecutionContext,
      agentFactoryProvider,
      kibanaVersion
    });
    this.rootScopedClient = (0, _configure_client.configureClient)(config, {
      scoped: true,
      logger,
      type,
      getExecutionContext,
      agentFactoryProvider,
      kibanaVersion
    });
  }
  asScoped(request) {
    const createScopedClient = () => {
      const scopedHeaders = this.getScopedHeaders(request);
      const transportClass = (0, _create_transport.createTransport)({
        getExecutionContext: this.getExecutionContext,
        getUnauthorizedErrorHandler: this.createInternalErrorHandlerAccessor(request)
      });
      return this.rootScopedClient.child({
        headers: scopedHeaders,
        Transport: transportClass
      });
    };
    const createSecondaryScopedClient = () => {
      const secondaryAuthHeaders = this.getSecondaryAuthHeaders(request);
      return this.asInternalUser.child({
        headers: secondaryAuthHeaders
      });
    };
    return new _scoped_cluster_client.ScopedClusterClient({
      asInternalUser: this.asInternalUser,
      asCurrentUserFactory: createScopedClient,
      asSecondaryAuthUserFactory: createSecondaryScopedClient
    });
  }
  async close() {
    if (this.isClosed) {
      return;
    }
    this.isClosed = true;
    await Promise.all([this.asInternalUser.close(), this.rootScopedClient.close()]);
  }
  getScopedHeaders(request) {
    let scopedHeaders;
    if ((0, _coreHttpRouterServerInternal.isRealRequest)(request)) {
      var _ensureRawRequest$hea, _this$authHeaders$get, _this$authHeaders;
      const requestHeaders = (_ensureRawRequest$hea = (0, _coreHttpRouterServerInternal.ensureRawRequest)(request).headers) !== null && _ensureRawRequest$hea !== void 0 ? _ensureRawRequest$hea : {};
      const requestIdHeaders = (0, _coreHttpRouterServerInternal.isKibanaRequest)(request) ? {
        'x-opaque-id': request.id
      } : {};
      const authHeaders = (_this$authHeaders$get = (_this$authHeaders = this.authHeaders) === null || _this$authHeaders === void 0 ? void 0 : _this$authHeaders.get(request)) !== null && _this$authHeaders$get !== void 0 ? _this$authHeaders$get : {};
      scopedHeaders = {
        ...(0, _coreHttpRouterServerInternal.filterHeaders)(requestHeaders, this.config.requestHeadersWhitelist),
        ...requestIdHeaders,
        ...authHeaders
      };
    } else {
      var _request$headers;
      scopedHeaders = (0, _coreHttpRouterServerInternal.filterHeaders)((_request$headers = request === null || request === void 0 ? void 0 : request.headers) !== null && _request$headers !== void 0 ? _request$headers : {}, this.config.requestHeadersWhitelist);
    }
    return {
      ...(0, _headers.getDefaultHeaders)(this.kibanaVersion),
      ...this.config.customHeaders,
      ...scopedHeaders
    };
  }
  getSecondaryAuthHeaders(request) {
    var _this$authHeaders$get2, _this$authHeaders2;
    const headerSource = (0, _coreHttpRouterServerInternal.isRealRequest)(request) ? (_this$authHeaders$get2 = (_this$authHeaders2 = this.authHeaders) === null || _this$authHeaders2 === void 0 ? void 0 : _this$authHeaders2.get(request)) !== null && _this$authHeaders$get2 !== void 0 ? _this$authHeaders$get2 : {} : request.headers;
    const authorizationHeader = Object.entries(headerSource).find(([key, value]) => {
      return key.toLowerCase() === _headers.AUTHORIZATION_HEADER && value !== undefined;
    });
    if (!authorizationHeader) {
      throw new Error(`asSecondaryAuthUser called from a client scoped to a request without 'authorization' header.`);
    }
    return {
      ...(0, _headers.getDefaultHeaders)(this.kibanaVersion),
      ...this.config.customHeaders,
      [_headers.ES_SECONDARY_AUTH_HEADER]: authorizationHeader[1]
    };
  }
}
exports.ClusterClient = ClusterClient;