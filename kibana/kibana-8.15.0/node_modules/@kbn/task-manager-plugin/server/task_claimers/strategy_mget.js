"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.claimAvailableTasksMget = claimAvailableTasksMget;
var _server = require("@kbn/core/server");
var _elasticApmNode = _interopRequireDefault(require("elastic-apm-node"));
var _rxjs = require("rxjs");
var _ = require(".");
var _task = require("../task");
var _task_running = require("../task_running");
var _task_claiming = require("../queries/task_claiming");
var _task_events = require("../task_events");
var _query_clauses = require("../queries/query_clauses");
var _mark_available_tasks_as_claimed = require("../queries/mark_available_tasks_as_claimed");
var _result_type = require("../lib/result_type");
/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0; you may not use this file except in compliance with the Elastic License
 * 2.0.
 */

// Basic operation of this task claimer:
// - search for candidate tasks to run, more than we actually can run
// - for each task found, do an mget to get the current seq_no and primary_term
// - if the mget result doesn't match the search result, the task is stale
// - from the non-stale search results, return as many as we can run

const SIZE_MULTIPLIER_FOR_TASK_FETCH = 4;
function claimAvailableTasksMget(opts) {
  const taskClaimOwnership$ = new _rxjs.Subject();
  claimAvailableTasksApm(opts).then(result => {
    taskClaimOwnership$.next(result);
  }).catch(err => {
    taskClaimOwnership$.error(err);
  }).finally(() => {
    taskClaimOwnership$.complete();
  });
  return taskClaimOwnership$;
}
async function claimAvailableTasksApm(opts) {
  const apmTrans = _elasticApmNode.default.startTransaction(_task_claiming.TASK_MANAGER_MARK_AS_CLAIMED, _task_running.TASK_MANAGER_TRANSACTION_TYPE);
  try {
    const result = await claimAvailableTasks(opts);
    apmTrans.end('success');
    return result;
  } catch (err) {
    apmTrans.end('failure');
    throw err;
  }
}
async function claimAvailableTasks(opts) {
  const {
    getCapacity,
    claimOwnershipUntil,
    batches,
    events$,
    taskStore
  } = opts;
  const {
    definitions,
    unusedTypes,
    excludedTaskTypes,
    taskMaxAttempts
  } = opts;
  const {
    logger
  } = opts;
  const loggerTag = claimAvailableTasksMget.name;
  const logMeta = {
    tags: [loggerTag]
  };
  const initialCapacity = getCapacity();
  const stopTaskTimer = (0, _task_events.startTaskTimer)();
  const removedTypes = new Set(unusedTypes); // REMOVED_TYPES
  const excludedTypes = new Set(excludedTaskTypes); // excluded via config

  // get a list of candidate tasks to claim, with their version info
  const {
    docs,
    versionMap
  } = await searchAvailableTasks({
    definitions,
    taskTypes: new Set(definitions.getAllTypes()),
    excludedTypes,
    removedTypes,
    taskStore,
    events$,
    claimOwnershipUntil,
    size: initialCapacity * SIZE_MULTIPLIER_FOR_TASK_FETCH,
    taskMaxAttempts
  });
  if (docs.length === 0) return {
    ...(0, _.getEmptyClaimOwnershipResult)(),
    timing: stopTaskTimer()
  };

  // use mget to get the latest version of each task
  const docLatestVersions = await taskStore.getDocVersions(docs.map(doc => `task:${doc.id}`));

  // filter out stale, missing and removed tasks
  const currentTasks = [];
  const staleTasks = [];
  const missingTasks = [];
  const removedTasks = [];
  for (const searchDoc of docs) {
    if (removedTypes.has(searchDoc.taskType)) {
      removedTasks.push(searchDoc);
      continue;
    }
    const searchVersion = versionMap.get(searchDoc.id);
    const latestVersion = docLatestVersions.get(`task:${searchDoc.id}`);
    if (!searchVersion || !latestVersion) {
      missingTasks.push(searchDoc);
      continue;
    }
    if (searchVersion.seqNo === latestVersion.seqNo && searchVersion.primaryTerm === latestVersion.primaryTerm) {
      currentTasks.push(searchDoc);
      continue;
    } else {
      staleTasks.push(searchDoc);
      continue;
    }
  }
  // apply limited concurrency limits (TODO: can currently starve other tasks)
  const candidateTasks = applyLimitedConcurrency(currentTasks, batches);

  // build the updated task objects we'll claim
  const taskUpdates = Array.from(candidateTasks).slice(0, initialCapacity).map(task => {
    if (task.retryAt != null && new Date(task.retryAt).getTime() < Date.now()) {
      task.scheduledAt = task.retryAt;
    } else {
      task.scheduledAt = task.runAt;
    }
    task.retryAt = claimOwnershipUntil;
    task.ownerId = taskStore.taskManagerId;
    task.status = _task.TaskStatus.Claiming;
    return task;
  });

  // perform the task object updates, deal with errors
  const finalResults = [];
  let conflicts = staleTasks.length;
  let bulkErrors = 0;
  try {
    const updateResults = await taskStore.bulkUpdate(taskUpdates, {
      validate: false
    });
    for (const updateResult of updateResults) {
      if ((0, _result_type.isOk)(updateResult)) {
        finalResults.push(updateResult.value);
      } else {
        const {
          id,
          type,
          error
        } = updateResult.error;

        // this check is needed so error will be typed correctly for isConflictError
        if (_server.SavedObjectsErrorHelpers.isSavedObjectsClientError(error)) {
          if (_server.SavedObjectsErrorHelpers.isConflictError(error)) {
            conflicts++;
          } else {
            logger.warn(`Saved Object error updating task ${id}:${type} during claim: ${error.error}`, logMeta);
            bulkErrors++;
          }
        } else {
          logger.warn(`Error updating task ${id}:${type} during claim: ${error.message}`, logMeta);
          bulkErrors++;
        }
      }
    }
  } catch (err) {
    logger.warn(`Error updating tasks during claim: ${err}`, logMeta);
  }

  // separate update for removed tasks; shouldn't happen often, so unlikely
  // a performance concern, and keeps the rest of the logic simpler
  let removedCount = 0;
  if (removedTasks.length > 0) {
    const tasksToRemove = Array.from(removedTasks);
    for (const task of tasksToRemove) {
      task.status = _task.TaskStatus.Unrecognized;
    }

    // don't worry too much about errors, we'll get them next time
    try {
      const removeResults = await taskStore.bulkUpdate(tasksToRemove, {
        validate: false
      });
      for (const removeResult of removeResults) {
        if ((0, _result_type.isOk)(removeResult)) {
          removedCount++;
        } else {
          const {
            id,
            type,
            error
          } = removeResult.error;
          logger.warn(`Error updating task ${id}:${type} to mark as unrecognized during claim: ${error.message}`, logMeta);
        }
      }
    } catch (err) {
      logger.warn(`Error updating tasks to mark as unrecognized during claim: ${err}`, logMeta);
    }
  }

  // TODO: need a better way to generate stats
  const message = `task claimer claimed: ${finalResults.length}; stale: ${staleTasks.length}; conflicts: ${conflicts}; missing: ${missingTasks.length}; updateErrors: ${bulkErrors}; removed: ${removedCount};`;
  logger.debug(message, logMeta);

  // build results
  const finalResult = {
    stats: {
      tasksUpdated: finalResults.length,
      tasksConflicted: conflicts,
      tasksClaimed: finalResults.length
    },
    docs: finalResults,
    timing: stopTaskTimer()
  };
  for (const doc of finalResults) {
    events$.next((0, _task_events.asTaskClaimEvent)(doc.id, (0, _result_type.asOk)(doc), finalResult.timing));
  }
  return finalResult;
}
async function searchAvailableTasks({
  definitions,
  taskTypes,
  removedTypes,
  excludedTypes,
  taskStore,
  size,
  taskMaxAttempts
}) {
  const searchedTypes = Array.from(taskTypes).concat(Array.from(removedTypes)).filter(type => !excludedTypes.has(type));
  const queryForScheduledTasks = (0, _query_clauses.mustBeAllOf)(
  // Task must be enabled
  _mark_available_tasks_as_claimed.EnabledTask,
  // a task type that's not excluded (may be removed or not)
  (0, _mark_available_tasks_as_claimed.OneOfTaskTypes)('task.taskType', searchedTypes),
  // Either a task with idle status and runAt <= now or
  // status running or claiming with a retryAt <= now.
  (0, _query_clauses.shouldBeOneOf)(_mark_available_tasks_as_claimed.IdleTaskWithExpiredRunAt, _mark_available_tasks_as_claimed.RunningOrClaimingTaskWithExpiredRetryAt),
  // must have a status that isn't 'unrecognized'
  _mark_available_tasks_as_claimed.RecognizedTask);
  const sort = (0, _mark_available_tasks_as_claimed.getClaimSort)(definitions);
  const query = (0, _query_clauses.matchesClauses)(queryForScheduledTasks, (0, _query_clauses.filterDownBy)(_mark_available_tasks_as_claimed.InactiveTasks));
  return await taskStore.fetch({
    query,
    sort,
    size,
    seq_no_primary_term: true
  });
}
function applyLimitedConcurrency(tasks, batches) {
  // create a map of task type - concurrency
  const limitedBatches = batches.filter(_task_claiming.isLimited);
  const limitedMap = new Map();
  for (const limitedBatch of limitedBatches) {
    const {
      tasksTypes,
      concurrency
    } = limitedBatch;
    limitedMap.set(tasksTypes, concurrency);
  }

  // apply the limited concurrency
  const result = [];
  for (const task of tasks) {
    const concurrency = limitedMap.get(task.taskType);
    if (concurrency == null) {
      result.push(task);
      continue;
    }
    if (concurrency > 0) {
      result.push(task);
      limitedMap.set(task.taskType, concurrency - 1);
    }
  }
  return result;
}