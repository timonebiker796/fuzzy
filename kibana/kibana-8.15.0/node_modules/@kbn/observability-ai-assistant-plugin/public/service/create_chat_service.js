"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createChatService = createChatService;
var _rxjs = require("rxjs");
var _common = require("../../common");
var _conversation_complete = require("../../common/conversation_complete");
var _filter_function_definitions = require("../../common/utils/filter_function_definitions");
var _throw_serialized_chat_completion_errors = require("../../common/utils/throw_serialized_chat_completion_errors");
var _until_aborted = require("../../common/utils/until_aborted");
var _analytics = require("../analytics");
var _readable_stream_reader_into_observable = require("../utils/readable_stream_reader_into_observable");
var _complete = require("./complete");
/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0; you may not use this file except in compliance with the Elastic License
 * 2.0.
 */

const MIN_DELAY = 10;
function toObservable(response) {
  var _response$response, _response$response$bo;
  const status = (_response$response = response.response) === null || _response$response === void 0 ? void 0 : _response$response.status;
  if (!status || status >= 400) {
    var _response$response2;
    throw new Error(((_response$response2 = response.response) === null || _response$response2 === void 0 ? void 0 : _response$response2.statusText) || 'Unexpected error');
  }
  const reader = (_response$response$bo = response.response.body) === null || _response$response$bo === void 0 ? void 0 : _response$response$bo.getReader();
  if (!reader) {
    throw new Error('Could not get reader from response');
  }
  return (0, _readable_stream_reader_into_observable.readableStreamReaderIntoObservable)(reader).pipe(
  // append a timestamp of when each value was emitted
  (0, _rxjs.timestamp)(),
  // use the previous timestamp to calculate a target
  // timestamp for emitting the next value
  (0, _rxjs.scan)((acc, value) => {
    const lastTimestamp = acc.timestamp || 0;
    const emitAt = Math.max(lastTimestamp + MIN_DELAY, value.timestamp);
    return {
      timestamp: emitAt,
      value: value.value
    };
  }),
  // add the delay based on the elapsed time
  // using concatMap(of(value).pipe(delay(50))
  // leads to browser issues because timers
  // are throttled when the tab is not active
  (0, _rxjs.concatMap)(value => {
    const now = Date.now();
    const delayFor = value.timestamp - now;
    if (delayFor <= 0) {
      return (0, _rxjs.of)(value.value);
    }
    return (0, _rxjs.of)(value.value).pipe((0, _rxjs.delay)(delayFor));
  }));
}
function serialize(signal) {
  return source$ => source$.pipe((0, _rxjs.catchError)(error => {
    if ('response' in error && 'json' in error.response && typeof error.response.json === 'function') {
      const responseBodyPromise = error.response.json();
      return (0, _rxjs.from)(responseBodyPromise.then(body => {
        if (body) {
          error.body = body;
          if (body.message) {
            error.message = body.message;
          }
        }
        throw error;
      }));
    }
    return (0, _rxjs.throwError)(() => error);
  }), (0, _rxjs.switchMap)(readable => toObservable(readable)), (0, _rxjs.map)(line => JSON.parse(line)), (0, _rxjs.filter)(line => line.type !== _conversation_complete.StreamingChatResponseEventType.BufferFlush), (0, _throw_serialized_chat_completion_errors.throwSerializedChatCompletionErrors)(), (0, _until_aborted.untilAborted)(signal), (0, _rxjs.shareReplay)());
}
async function createChatService({
  analytics,
  signal: setupAbortSignal,
  registrations,
  apiClient
}) {
  const functionRegistry = new Map();
  const renderFunctionRegistry = new Map();
  const [{
    functionDefinitions,
    systemMessage
  }] = await Promise.all([apiClient('GET /internal/observability_ai_assistant/functions', {
    signal: setupAbortSignal
  }), ...registrations.map(registration => {
    return registration({
      registerRenderFunction: (name, renderFn) => {
        renderFunctionRegistry.set(name, renderFn);
      }
    });
  })]);
  functionDefinitions.forEach(fn => {
    functionRegistry.set(fn.name, fn);
  });
  const getFunctions = options => {
    return (0, _filter_function_definitions.filterFunctionDefinitions)({
      ...options,
      definitions: functionDefinitions
    });
  };
  function callStreamingApi(endpoint, options) {
    return (0, _rxjs.from)(apiClient(endpoint, {
      ...options,
      asResponse: true,
      rawResponse: true
    })).pipe(serialize(options.signal));
  }
  const client = {
    chat(name, {
      connectorId,
      messages,
      functionCall,
      functions,
      signal
    }) {
      return callStreamingApi('POST /internal/observability_ai_assistant/chat', {
        params: {
          body: {
            name,
            messages,
            connectorId,
            functionCall,
            functions: functions !== null && functions !== void 0 ? functions : []
          }
        },
        signal
      }).pipe((0, _rxjs.filter)(line => line.type === _conversation_complete.StreamingChatResponseEventType.ChatCompletionChunk));
    },
    complete({
      getScreenContexts,
      connectorId,
      conversationId,
      messages,
      persist,
      disableFunctions,
      signal,
      responseLanguage,
      instructions
    }) {
      return (0, _complete.complete)({
        getScreenContexts,
        connectorId,
        conversationId,
        messages,
        persist,
        disableFunctions,
        signal,
        client,
        responseLanguage,
        instructions
      }, ({
        params
      }) => {
        return callStreamingApi('POST /internal/observability_ai_assistant/chat/complete', {
          params,
          signal
        });
      });
    }
  };
  return {
    sendAnalyticsEvent: event => {
      (0, _analytics.sendEvent)(analytics, event);
    },
    renderFunction: (name, args, response, onActionClick) => {
      var _response$content, _response$data;
      const fn = renderFunctionRegistry.get(name);
      if (!fn) {
        throw new Error(`Function ${name} not found`);
      }
      const parsedArguments = args ? JSON.parse(args) : {};
      const parsedResponse = {
        content: JSON.parse((_response$content = response.content) !== null && _response$content !== void 0 ? _response$content : '{}'),
        data: JSON.parse((_response$data = response.data) !== null && _response$data !== void 0 ? _response$data : '{}')
      };
      return fn === null || fn === void 0 ? void 0 : fn({
        response: parsedResponse,
        arguments: parsedArguments,
        onActionClick
      });
    },
    getFunctions,
    hasFunction: name => {
      return functionRegistry.has(name);
    },
    hasRenderFunction: name => {
      return renderFunctionRegistry.has(name);
    },
    getSystemMessage: () => {
      return {
        '@timestamp': new Date().toISOString(),
        message: {
          role: _common.MessageRole.System,
          content: systemMessage
        }
      };
    },
    ...client
  };
}