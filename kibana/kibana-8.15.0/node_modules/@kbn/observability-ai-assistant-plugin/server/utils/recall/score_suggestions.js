"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.scoreSuggestions = scoreSuggestions;
var t = _interopRequireWildcard(require("io-ts"));
var _lodash = require("lodash");
var _dedent = _interopRequireDefault(require("dedent"));
var _rxjs = require("rxjs");
var _ioTsUtils = require("@kbn/io-ts-utils");
var _common = require("../../../common");
var _parse_suggestion_scores = require("./parse_suggestion_scores");
var _short_id_table = require("../../../common/utils/short_id_table");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0; you may not use this file except in compliance with the Elastic License
 * 2.0.
 */

const scoreFunctionRequestRt = t.type({
  message: t.type({
    function_call: t.type({
      name: t.literal('score'),
      arguments: t.string
    })
  })
});
const scoreFunctionArgumentsRt = t.type({
  scores: t.string
});
async function scoreSuggestions({
  suggestions,
  messages,
  userPrompt,
  context,
  chat,
  signal,
  logger
}) {
  const shortIdTable = new _short_id_table.ShortIdTable();
  const suggestionsWithShortId = suggestions.map(suggestion => ({
    ...(0, _lodash.omit)(suggestion, 'score', 'id'),
    // To not bias the LLM
    originalId: suggestion.id,
    shortId: shortIdTable.take(suggestion.id)
  }));
  const newUserMessageContent = (0, _dedent.default)(`Given the following question, score the documents that are relevant to the question. on a scale from 0 to 7,
    0 being completely irrelevant, and 7 being extremely relevant. Information is relevant to the question if it helps in
    answering the question. Judge it according to the following criteria:

    - The document is relevant to the question, and the rest of the conversation
    - The document has information relevant to the question that is not mentioned,
      or more detailed than what is available in the conversation
    - The document has a high amount of information relevant to the question compared to other documents
    - The document contains new information not mentioned before in the conversation

    User prompt:
    ${userPrompt}

    Context:
    ${context}

    Documents:
    ${JSON.stringify(suggestionsWithShortId.map(suggestion => ({
    id: suggestion.shortId,
    content: suggestion.text
  })), null, 2)}`);
  const newUserMessage = {
    '@timestamp': new Date().toISOString(),
    message: {
      role: _common.MessageRole.User,
      content: newUserMessageContent
    }
  };
  const scoreFunction = {
    name: 'score',
    description: 'Use this function to score documents based on how relevant they are to the conversation.',
    parameters: {
      type: 'object',
      properties: {
        scores: {
          description: `The document IDs and their scores, as CSV. Example:
          
            my_id,7
            my_other_id,3
            my_third_id,4
          `,
          type: 'string'
        }
      },
      required: ['score']
    }
  };
  const response = await (0, _rxjs.lastValueFrom)(chat('score_suggestions', {
    messages: [...messages.slice(0, -2), newUserMessage],
    functions: [scoreFunction],
    functionCall: 'score',
    signal
  }).pipe((0, _common.concatenateChatCompletionChunks)()));
  const scoreFunctionRequest = (0, _ioTsUtils.decodeOrThrow)(scoreFunctionRequestRt)(response);
  const {
    scores: scoresAsString
  } = (0, _ioTsUtils.decodeOrThrow)(_ioTsUtils.jsonRt.pipe(scoreFunctionArgumentsRt))(scoreFunctionRequest.message.function_call.arguments);
  const scores = (0, _parse_suggestion_scores.parseSuggestionScores)(scoresAsString).map(({
    id,
    score
  }) => {
    const originalSuggestion = suggestionsWithShortId.find(suggestion => suggestion.shortId === id);
    return {
      originalId: originalSuggestion === null || originalSuggestion === void 0 ? void 0 : originalSuggestion.originalId,
      score
    };
  });
  if (scores.length === 0) {
    // seemingly invalid or no scores, return all
    return {
      relevantDocuments: suggestions,
      scores: []
    };
  }
  const suggestionIds = suggestions.map(document => document.id);
  const relevantDocumentIds = scores.filter(document => {
    var _document$originalId;
    return suggestionIds.includes((_document$originalId = document.originalId) !== null && _document$originalId !== void 0 ? _document$originalId : '');
  }) // Remove hallucinated documents
  .filter(document => document.score > 4).sort((a, b) => b.score - a.score).slice(0, 5).map(document => document.originalId);
  const relevantDocuments = suggestions.filter(suggestion => relevantDocumentIds.includes(suggestion.id));
  logger.debug(`Relevant documents: ${JSON.stringify(relevantDocuments, null, 2)}`);
  return {
    relevantDocuments,
    scores: scores.map(score => ({
      id: score.originalId,
      score: score.score
    }))
  };
}