"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.chatCompleteRoute = exports.SYSTEM_PROMPT_CONTEXT_NON_I18N = void 0;
var _securitysolutionEsUtils = require("@kbn/securitysolution-es-utils");
var _elasticAssistantCommon = require("@kbn/elastic-assistant-common");
var _common = require("@kbn/elastic-assistant-common/impl/schemas/common");
var _server = require("@kbn/data-plugin/server");
var _event_based_telemetry = require("../../lib/telemetry/event_based_telemetry");
var _build_response = require("../../lib/build_response");
var _helpers = require("../helpers");
var _helpers2 = require("../../ai_assistant_data_clients/anonymization_fields/helpers");
/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0; you may not use this file except in compliance with the Elastic License
 * 2.0.
 */

const SYSTEM_PROMPT_CONTEXT_NON_I18N = context => {
  return `CONTEXT:\n"""\n${context}\n"""`;
};
exports.SYSTEM_PROMPT_CONTEXT_NON_I18N = SYSTEM_PROMPT_CONTEXT_NON_I18N;
const chatCompleteRoute = (router, getElser) => {
  router.versioned.post({
    access: 'public',
    path: _elasticAssistantCommon.ELASTIC_AI_ASSISTANT_CHAT_COMPLETE_URL,
    options: {
      tags: ['access:elasticAssistant']
    }
  }).addVersion({
    version: _elasticAssistantCommon.API_VERSIONS.public.v1,
    validate: {
      request: {
        body: (0, _common.buildRouteValidationWithZod)(_elasticAssistantCommon.ChatCompleteProps)
      }
    }
  }, async (context, request, response) => {
    const abortSignal = (0, _server.getRequestAbortedSignal)(request.events.aborted$);
    const assistantResponse = (0, _build_response.buildResponse)(response);
    let telemetry;
    let actionTypeId;
    try {
      var _request$body$isStrea, _newConversation4, _messages;
      const ctx = await context.resolve(['core', 'elasticAssistant', 'licensing']);
      const logger = ctx.elasticAssistant.logger;
      telemetry = ctx.elasticAssistant.telemetry;

      // Perform license and authenticated user checks
      const checkResponse = (0, _helpers.performChecks)({
        authenticatedUser: true,
        context: ctx,
        license: true,
        request,
        response
      });
      if (checkResponse) {
        return checkResponse;
      }
      const conversationsDataClient = await ctx.elasticAssistant.getAIAssistantConversationsDataClient();
      const anonymizationFieldsDataClient = await ctx.elasticAssistant.getAIAssistantAnonymizationFieldsDataClient();
      let messages;
      const conversationId = request.body.conversationId;
      const connectorId = request.body.connectorId;
      let latestReplacements = {};
      const onNewReplacements = newReplacements => {
        latestReplacements = {
          ...latestReplacements,
          ...newReplacements
        };
      };

      // get the actions plugin start contract from the request context:
      const actions = ctx.elasticAssistant.actions;
      const actionsClient = await actions.getActionsClientWithRequest(request);
      const connectors = await actionsClient.getBulk({
        ids: [connectorId]
      });
      actionTypeId = connectors.length > 0 ? connectors[0].actionTypeId : '.gen-ai';

      // replacements
      const anonymizationFieldsRes = await (anonymizationFieldsDataClient === null || anonymizationFieldsDataClient === void 0 ? void 0 : anonymizationFieldsDataClient.findDocuments({
        perPage: 1000,
        page: 1
      }));
      let anonymizationFields = anonymizationFieldsRes ? (0, _helpers2.transformESSearchToAnonymizationFields)(anonymizationFieldsRes.data) : undefined;

      // anonymize messages before sending to LLM
      messages = request.body.messages.map(m => {
        var _m$content;
        let content = (_m$content = m.content) !== null && _m$content !== void 0 ? _m$content : '';
        if (m.data) {
          // includes/anonymize fields from the messages data
          if (m.fields_to_anonymize && m.fields_to_anonymize.length > 0) {
            var _anonymizationFields;
            anonymizationFields = (_anonymizationFields = anonymizationFields) === null || _anonymizationFields === void 0 ? void 0 : _anonymizationFields.map(a => {
              var _m$fields_to_anonymiz;
              if ((_m$fields_to_anonymiz = m.fields_to_anonymize) !== null && _m$fields_to_anonymiz !== void 0 && _m$fields_to_anonymiz.includes(a.field)) {
                return {
                  ...a,
                  allowed: true,
                  anonymized: true
                };
              }
              return a;
            });
          }
          const anonymizedData = (0, _elasticAssistantCommon.transformRawData)({
            anonymizationFields,
            currentReplacements: latestReplacements,
            getAnonymizedValue: _elasticAssistantCommon.getAnonymizedValue,
            onNewReplacements,
            rawData: Object.keys(m.data).reduce((obj, key) => ({
              ...obj,
              [key]: [m.data ? m.data[key] : '']
            }), {})
          });
          const wr = `${SYSTEM_PROMPT_CONTEXT_NON_I18N(anonymizedData)}\n`;
          content = `${wr}\n${m.content}`;
        }
        const transformedMessage = {
          role: m.role,
          content
        };
        return transformedMessage;
      });
      let newConversation;
      if (conversationsDataClient && !conversationId && request.body.persist) {
        var _newConversation, _newConversation$mess;
        newConversation = await (0, _helpers.createConversationWithUserInput)({
          actionTypeId,
          connectorId,
          conversationId,
          conversationsDataClient,
          promptId: request.body.promptId,
          replacements: latestReplacements,
          newMessages: messages,
          model: request.body.model
        });

        // messages are anonymized by conversationsDataClient
        messages = (_newConversation = newConversation) === null || _newConversation === void 0 ? void 0 : (_newConversation$mess = _newConversation.messages) === null || _newConversation$mess === void 0 ? void 0 : _newConversation$mess.map(c => ({
          role: c.role,
          content: c.content
        }));
      }
      const onLlmResponse = async (content, traceData = {}, isError = false) => {
        var _newConversation2;
        if ((_newConversation2 = newConversation) !== null && _newConversation2 !== void 0 && _newConversation2.id && conversationsDataClient) {
          var _newConversation3;
          await (0, _helpers.appendAssistantMessageToConversation)({
            conversationId: (_newConversation3 = newConversation) === null || _newConversation3 === void 0 ? void 0 : _newConversation3.id,
            conversationsDataClient,
            messageContent: content,
            replacements: latestReplacements,
            isError,
            traceData
          });
        }
      };
      return await (0, _helpers.langChainExecute)({
        abortSignal,
        isStream: (_request$body$isStrea = request.body.isStream) !== null && _request$body$isStrea !== void 0 ? _request$body$isStrea : false,
        actionsClient,
        actionTypeId,
        connectorId,
        conversationId: conversationId !== null && conversationId !== void 0 ? conversationId : (_newConversation4 = newConversation) === null || _newConversation4 === void 0 ? void 0 : _newConversation4.id,
        context: ctx,
        getElser,
        logger,
        messages: (_messages = messages) !== null && _messages !== void 0 ? _messages : [],
        onLlmResponse,
        onNewReplacements,
        replacements: latestReplacements,
        request: {
          ...request,
          // TODO: clean up after empty tools will be available to use
          body: {
            ...request.body,
            replacements: {},
            size: 10,
            alertsIndexPattern: '.alerts-security.alerts-default'
          }
        },
        response,
        telemetry,
        responseLanguage: request.body.responseLanguage
      });
    } catch (err) {
      var _telemetry, _actionTypeId, _request$body$isStrea2;
      const error = (0, _securitysolutionEsUtils.transformError)(err);
      (_telemetry = telemetry) === null || _telemetry === void 0 ? void 0 : _telemetry.reportEvent(_event_based_telemetry.INVOKE_ASSISTANT_ERROR_EVENT.eventType, {
        actionTypeId: (_actionTypeId = actionTypeId) !== null && _actionTypeId !== void 0 ? _actionTypeId : '',
        model: request.body.model,
        errorMessage: error.message,
        // TODO rm actionTypeId check when llmClass for bedrock streaming is implemented
        // tracked here: https://github.com/elastic/security-team/issues/7363
        assistantStreamingEnabled: (_request$body$isStrea2 = request.body.isStream) !== null && _request$body$isStrea2 !== void 0 ? _request$body$isStrea2 : false
      });
      return assistantResponse.error({
        body: error.message,
        statusCode: error.statusCode
      });
    }
  });
};
exports.chatCompleteRoute = chatCompleteRoute;