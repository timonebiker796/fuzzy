"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MapsPlugin = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _react = _interopRequireDefault(require("react"));
var _public = require("@kbn/core/public");
var _public2 = require("@kbn/ui-actions-plugin/public");
var _public3 = require("@kbn/embeddable-plugin/public");
var _legacy_visualizations = require("./legacy_visualizations");
var _locator_definition = require("./locators/map_locator/locator_definition");
var _locator_definition2 = require("./locators/tile_map_locator/locator_definition");
var _locator_definition3 = require("./locators/region_map_locator/locator_definition");
var _licensed_features = require("./licensed_features");
var _source_registry = require("./classes/sources/source_registry");
var _layer_wizard_registry = require("./classes/layers/wizards/layer_wizard_registry");
var _api = require("./api");
var _action = require("./trigger_actions/filter_by_map_extent/action");
var _action2 = require("./trigger_actions/synchronize_movement/action");
var _visualize_geo_field_action = require("./trigger_actions/visualize_geo_field_action");
var _constants = require("../common/constants");
var _maps_vis_type_alias = require("./maps_vis_type_alias");
var _feature_catalogue_entry = require("./feature_catalogue_entry");
var _kibana_services = require("./kibana_services");
var _map_inspector_view = require("./inspector/map_adapter/map_inspector_view");
var _vector_tile_inspector_view = require("./inspector/vector_tile_adapter/vector_tile_inspector_view");
var _lens = require("./lens");
var _content_management = require("../common/content_management");
var _setup_map_embeddable = require("./react_embeddable/setup_map_embeddable");
var _map_renderer_lazy = require("./react_embeddable/map_renderer_lazy");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; } /*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0; you may not use this file except in compliance with the Elastic License
 * 2.0.
 */
/**
 * These are the interfaces with your public contracts. You should export these
 * for other plugins to use in _their_ `SetupDeps`/`StartDeps` interfaces.
 * @public
 */

/** @internal */
class MapsPlugin {
  constructor(initializerContext) {
    (0, _defineProperty2.default)(this, "_initializerContext", void 0);
    this._initializerContext = initializerContext;
  }
  setup(core, plugins) {
    var _plugins$screenshotMo, _plugins$cloud;
    (0, _licensed_features.registerLicensedFeatures)(plugins.licensing);
    const config = this._initializerContext.config.get();
    (0, _kibana_services.setMapAppConfig)({
      ...config,
      // Override this when we know we are taking a screenshot (i.e. no user interaction)
      // to avoid a blank-canvas issue when rendering maps on a PDF
      preserveDrawingBuffer: (_plugins$screenshotMo = plugins.screenshotMode) !== null && _plugins$screenshotMo !== void 0 && _plugins$screenshotMo.isScreenshotMode() ? true : config.preserveDrawingBuffer
    });
    const locator = plugins.share.url.locators.create(new _locator_definition.MapsAppLocatorDefinition({
      useHash: core.uiSettings.get('state:storeInSessionStorage')
    }));
    plugins.share.url.locators.create(new _locator_definition2.MapsAppTileMapLocatorDefinition({
      locator
    }));
    plugins.share.url.locators.create(new _locator_definition3.MapsAppRegionMapLocatorDefinition({
      locator
    }));
    plugins.inspector.registerView(_vector_tile_inspector_view.VectorTileInspectorView);
    plugins.inspector.registerView(_map_inspector_view.MapInspectorView);
    if (plugins.home) {
      plugins.home.featureCatalogue.register(_feature_catalogue_entry.featureCatalogueEntry);
    }
    plugins.visualizations.registerAlias((0, _maps_vis_type_alias.getMapsVisTypeAlias)());
    core.application.register({
      id: _constants.APP_ID,
      title: _constants.APP_NAME,
      order: 4000,
      icon: `plugins/${_constants.APP_ID}/icon.svg`,
      euiIconType: _constants.APP_ICON_SOLUTION,
      category: _public.DEFAULT_APP_CATEGORIES.kibana,
      async mount(params) {
        var _plugins$usageCollect, _plugins$usageCollect2;
        const [, startServices, {
          renderApp
        }] = await Promise.all([(0, _kibana_services.untilPluginStartServicesReady)(), core.getStartServices(), Promise.resolve().then(() => _interopRequireWildcard(require('./render_app')))]);
        const [coreStart, {
          savedObjectsTagging,
          spaces
        }] = startServices;
        const UsageTracker = (_plugins$usageCollect = (_plugins$usageCollect2 = plugins.usageCollection) === null || _plugins$usageCollect2 === void 0 ? void 0 : _plugins$usageCollect2.components.ApplicationUsageTrackingProvider) !== null && _plugins$usageCollect !== void 0 ? _plugins$usageCollect : _react.default.Fragment;
        const activeSpace = await (spaces === null || spaces === void 0 ? void 0 : spaces.getActiveSpace());
        if (activeSpace) {
          (0, _kibana_services.setSpaceId)(activeSpace.id);
        }
        return renderApp(params, {
          coreStart,
          AppUsageTracker: UsageTracker,
          savedObjectsTagging
        });
      }
    });
    plugins.contentManagement.registry.register({
      id: _content_management.CONTENT_ID,
      version: {
        latest: _content_management.LATEST_VERSION
      },
      name: _constants.APP_NAME
    });
    (0, _setup_map_embeddable.setupMapEmbeddable)(plugins.embeddable);
    (0, _lens.setupLensChoroplethChart)(core, plugins.expressions, plugins.lens);

    // register wrapper around legacy tile_map and region_map visualizations
    plugins.data.search.aggs.types.registerLegacy(_legacy_visualizations.GEOHASH_GRID, _legacy_visualizations.getGeoHashBucketAgg);
    plugins.expressions.registerFunction(_legacy_visualizations.createRegionMapFn);
    plugins.expressions.registerRenderer(_legacy_visualizations.regionMapRenderer);
    plugins.visualizations.createBaseVisualization(_legacy_visualizations.regionMapVisType);
    plugins.expressions.registerFunction(_legacy_visualizations.createTileMapFn);
    plugins.expressions.registerRenderer(_legacy_visualizations.tileMapRenderer);
    plugins.visualizations.createBaseVisualization(_legacy_visualizations.tileMapVisType);
    (0, _kibana_services.setIsCloudEnabled)(!!((_plugins$cloud = plugins.cloud) !== null && _plugins$cloud !== void 0 && _plugins$cloud.isCloudEnabled));
    return {
      registerLayerWizard: _layer_wizard_registry.registerLayerWizardExternal,
      registerSource: _source_registry.registerSource
    };
  }
  start(core, plugins) {
    (0, _licensed_features.setLicensingPluginStart)(plugins.licensing);
    (0, _kibana_services.setStartServices)(core, plugins);
    if (core.application.capabilities.maps.show) {
      plugins.uiActions.addTriggerAction(_public2.VISUALIZE_GEO_FIELD_TRIGGER, _visualize_geo_field_action.visualizeGeoFieldAction);
    }
    plugins.uiActions.addTriggerAction(_public3.CONTEXT_MENU_TRIGGER, _action.filterByMapExtentAction);
    plugins.uiActions.addTriggerAction(_public3.CONTEXT_MENU_TRIGGER, _action2.synchronizeMovementAction);
    if (!core.application.capabilities.maps.save) {
      plugins.visualizations.unRegisterAlias(_constants.APP_ID);
    }
    return {
      createLayerDescriptors: _api.createLayerDescriptors,
      suggestEMSTermJoinConfig: _api.suggestEMSTermJoinConfig,
      Map: _map_renderer_lazy.MapRendererLazy,
      PassiveMap: _lens.PassiveMapLazy
    };
  }
}
exports.MapsPlugin = MapsPlugin;