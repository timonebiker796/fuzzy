"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.sourceTitle = exports.ESQLSource = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _react = _interopRequireDefault(require("react"));
var _i18n = require("@kbn/i18n");
var _rxjs = require("rxjs");
var _uuid = require("uuid");
var _esqlUtils = require("@kbn/esql-utils");
var _esQuery = require("@kbn/es-query");
var _es_query = require("@kbn/data-service/src/es_query");
var _public = require("@kbn/data-plugin/public");
var _constants = require("../../../../common/constants");
var _elasticsearch_util = require("../../../../common/elasticsearch_util");
var _valid_string_config = require("../../util/valid_string_config");
var _vector_source = require("../vector_source");
var _inline_field = require("../../fields/inline_field");
var _kibana_services = require("../../../kibana_services");
var _convert_to_geojson = require("./convert_to_geojson");
var _esql_utils = require("./esql_utils");
var _update_source_editor = require("./update_source_editor");
/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0; you may not use this file except in compliance with the Elastic License
 * 2.0.
 */

const sourceTitle = exports.sourceTitle = _i18n.i18n.translate('xpack.maps.source.esqlSearchTitle', {
  defaultMessage: 'ES|QL'
});
class ESQLSource extends _vector_source.AbstractVectorSource {
  static createDescriptor(descriptor) {
    if (!(0, _valid_string_config.isValidStringConfig)(descriptor.esql)) {
      throw new Error('Cannot create ESQLSourceDescriptor when esql is not provided');
    }
    if (!(0, _valid_string_config.isValidStringConfig)(descriptor.dataViewId)) {
      throw new Error('Cannot create ESQLSourceDescriptor when dataViewId is not provided');
    }
    return {
      ...descriptor,
      id: (0, _valid_string_config.isValidStringConfig)(descriptor.id) ? descriptor.id : (0, _uuid.v4)(),
      type: _constants.SOURCE_TYPES.ESQL,
      esql: descriptor.esql,
      columns: descriptor.columns ? descriptor.columns : [],
      dataViewId: descriptor.dataViewId,
      narrowByGlobalSearch: typeof descriptor.narrowByGlobalSearch !== 'undefined' ? descriptor.narrowByGlobalSearch : true,
      narrowByGlobalTime: typeof descriptor.narrowByGlobalTime !== 'undefined' ? descriptor.narrowByGlobalTime : descriptor.dateField !== 'undefined',
      narrowByMapBounds: typeof descriptor.narrowByMapBounds !== 'undefined' ? descriptor.narrowByMapBounds : descriptor.geoField !== 'undefined',
      applyForceRefresh: typeof descriptor.applyForceRefresh !== 'undefined' ? descriptor.applyForceRefresh : true
    };
  }
  constructor(partialDescriptor) {
    const descriptor = ESQLSource.createDescriptor(partialDescriptor);
    super(descriptor);
    (0, _defineProperty2.default)(this, "_descriptor", void 0);
    this._descriptor = descriptor;
  }
  _getRequestId() {
    return this._descriptor.id;
  }
  async getDisplayName() {
    const pattern = (0, _esqlUtils.getIndexPatternFromESQLQuery)(this._descriptor.esql);
    return pattern ? pattern : 'ES|QL';
  }
  async supportsFitToBounds() {
    return false;
  }
  getInspectorRequestIds() {
    return [this._getRequestId()];
  }
  isQueryAware() {
    return true;
  }
  getApplyGlobalQuery() {
    return this._descriptor.narrowByGlobalSearch;
  }
  async isTimeAware() {
    return this._descriptor.narrowByGlobalTime;
  }
  getApplyGlobalTime() {
    return this._descriptor.narrowByGlobalTime;
  }
  getApplyForceRefresh() {
    return this._descriptor.applyForceRefresh;
  }
  isFilterByMapBounds() {
    return this._descriptor.narrowByMapBounds;
  }
  async getSupportedShapeTypes() {
    const index = this._descriptor.columns.findIndex(_esql_utils.isGeometryColumn);
    return index !== -1 && this._descriptor.columns[index].type === _esql_utils.ESQL_GEO_SHAPE_TYPE ? [_constants.VECTOR_SHAPE_TYPE.POINT, _constants.VECTOR_SHAPE_TYPE.LINE, _constants.VECTOR_SHAPE_TYPE.POLYGON] : [_constants.VECTOR_SHAPE_TYPE.POINT];
  }
  supportsJoins() {
    return false; // Joins will be part of ESQL statement and not client side join
  }
  async getGeoJsonWithMeta(layerName, requestMeta, registerCancelCallback, isRequestStillActive, inspectorAdapters) {
    const limit = (0, _esqlUtils.getLimitFromESQLQuery)(this._descriptor.esql);
    const params = {
      query: this._descriptor.esql,
      dropNullColumns: true
    };
    const query = [];
    const filters = [];
    if (this._descriptor.narrowByGlobalSearch) {
      var _requestMeta$embeddab;
      if (requestMeta.query) {
        query.push(requestMeta.query);
      }
      if ((_requestMeta$embeddab = requestMeta.embeddableSearchContext) !== null && _requestMeta$embeddab !== void 0 && _requestMeta$embeddab.query) {
        query.push(requestMeta.embeddableSearchContext.query);
      }
      filters.push(...requestMeta.filters);
      if (requestMeta.embeddableSearchContext) {
        filters.push(...requestMeta.embeddableSearchContext.filters);
      }
    }
    if (this._descriptor.narrowByMapBounds && requestMeta.buffer) {
      if (!this._descriptor.geoField) {
        throw new Error(_i18n.i18n.translate('xpack.maps.source.esql.noGeoFieldError', {
          defaultMessage: 'Unable to narrow ES|QL statement by visible map area, geospatial field is not provided'
        }));
      }
      const extentFilter = (0, _elasticsearch_util.createExtentFilter)(requestMeta.buffer, [this._descriptor.geoField]);
      filters.push(extentFilter);
    }
    if (requestMeta.applyGlobalTime) {
      if (!this._descriptor.dateField) {
        throw new Error(_i18n.i18n.translate('xpack.maps.source.esql.noDateFieldError', {
          defaultMessage: 'Unable to narrow ES|QL statement by global time, date field is not provided'
        }));
      }
      const timeRange = requestMeta.timeslice ? {
        from: new Date(requestMeta.timeslice.from).toISOString(),
        to: new Date(requestMeta.timeslice.to).toISOString(),
        mode: 'absolute'
      } : requestMeta.timeFilters;
      const timeFilter = (0, _public.getTime)(undefined, timeRange, {
        fieldName: this._descriptor.dateField
      });
      if (timeFilter) {
        filters.push(timeFilter);
      }
    }
    params.filter = (0, _esQuery.buildEsQuery)(undefined, query, filters, (0, _es_query.getEsQueryConfig)((0, _kibana_services.getUiSettings)()));
    const requestResponder = inspectorAdapters.requests.start((0, _vector_source.getLayerFeaturesRequestName)(layerName), {
      id: this._getRequestId()
    });
    requestResponder.json(params);
    const {
      rawResponse,
      requestParams
    } = await (0, _rxjs.lastValueFrom)((0, _kibana_services.getData)().search.search({
      params
    }, {
      strategy: 'esql'
    }).pipe((0, _rxjs.tap)({
      error(error) {
        requestResponder.error({
          json: 'attributes' in error ? error.attributes : {
            message: error.message
          }
        });
      }
    })));
    requestResponder.ok({
      json: rawResponse,
      requestParams
    });
    const esqlSearchResponse = rawResponse;
    const resultsCount = esqlSearchResponse.values.length;
    return {
      data: (0, _convert_to_geojson.convertToGeoJson)(esqlSearchResponse),
      meta: {
        resultsCount,
        areResultsTrimmed: resultsCount >= limit
      }
    };
  }
  getSourceStatus(sourceDataRequest) {
    var _meta$resultsCount2;
    const meta = sourceDataRequest ? sourceDataRequest.getMeta() : null;
    if (!meta) {
      // no tooltip content needed when there is no feature collection or meta
      return {
        tooltipContent: null,
        areResultsTrimmed: false
      };
    }
    if (meta.areResultsTrimmed) {
      var _meta$resultsCount;
      return {
        tooltipContent: _i18n.i18n.translate('xpack.maps.esqlSearch.resultsTrimmedMsg', {
          defaultMessage: `Results limited to first {count} rows.`,
          values: {
            count: (_meta$resultsCount = meta.resultsCount) === null || _meta$resultsCount === void 0 ? void 0 : _meta$resultsCount.toLocaleString()
          }
        }),
        areResultsTrimmed: true
      };
    }
    return {
      tooltipContent: _i18n.i18n.translate('xpack.maps.esqlSearch.rowCountMsg', {
        defaultMessage: `Found {count} rows.`,
        values: {
          count: (_meta$resultsCount2 = meta.resultsCount) === null || _meta$resultsCount2 === void 0 ? void 0 : _meta$resultsCount2.toLocaleString()
        }
      }),
      areResultsTrimmed: false
    };
  }
  getFieldByName(fieldName) {
    const column = this._descriptor.columns.find(({
      name
    }) => {
      return name === fieldName;
    });
    const fieldType = column ? (0, _esql_utils.getFieldType)(column) : undefined;
    return column && fieldType ? new _inline_field.InlineField({
      fieldName: column.name,
      source: this,
      origin: _constants.FIELD_ORIGIN.SOURCE,
      dataType: fieldType
    }) : null;
  }
  async getFields() {
    const fields = [];
    this._descriptor.columns.forEach(column => {
      const fieldType = (0, _esql_utils.getFieldType)(column);
      if (fieldType) {
        fields.push(new _inline_field.InlineField({
          fieldName: column.name,
          source: this,
          origin: _constants.FIELD_ORIGIN.SOURCE,
          dataType: fieldType
        }));
      }
    });
    return fields;
  }
  renderSourceSettingsEditor({
    onChange
  }) {
    return /*#__PURE__*/_react.default.createElement(_update_source_editor.UpdateSourceEditor, {
      onChange: onChange,
      sourceDescriptor: this._descriptor
    });
  }
  getSyncMeta() {
    return {
      columns: this._descriptor.columns,
      dateField: this._descriptor.dateField,
      esql: this._descriptor.esql,
      geoField: this._descriptor.geoField,
      narrowByMapBounds: this._descriptor.narrowByMapBounds,
      narrowByGlobalTime: this._descriptor.narrowByGlobalTime
    };
  }
  getIndexPatternId() {
    return this._descriptor.dataViewId;
  }
  getGeoFieldName() {
    return this._descriptor.geoField;
  }
}
exports.ESQLSource = ESQLSource;