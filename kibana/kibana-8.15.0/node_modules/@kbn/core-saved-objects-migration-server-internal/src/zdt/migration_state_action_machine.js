"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.migrationStateActionMachine = migrationStateActionMachine;
var _elasticsearch = require("@elastic/elasticsearch");
var _coreElasticsearchClientServerInternal = require("@kbn/core-elasticsearch-client-server-internal");
var _utils = require("../common/utils");
var _state_action_machine = require("../state_action_machine");
var _migrations_state_machine_cleanup = require("../migrations_state_machine_cleanup");
var _redact_state = require("../common/redact_state");
/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0 and the Server Side Public License, v 1; you may not use this file except
 * in compliance with, at your election, the Elastic License 2.0 or the Server
 * Side Public License, v 1.
 */

/**
 * A specialized migrations-specific state-action machine that:
 *  - logs messages in state.logs
 *  - logs state transitions
 *  - logs action responses
 *  - resolves if the final state is DONE
 *  - rejects if the final state is FATAL
 *  - catches and logs exceptions and then rejects with a migrations specific error
 */
async function migrationStateActionMachine({
  initialState,
  context,
  next,
  model,
  logger
}) {
  const startTime = Date.now();
  // Since saved object index names usually start with a `.` and can be
  // configured by users to include several `.`'s we can't use a logger tag to
  // indicate which messages come from which index upgrade.
  const logMessagePrefix = `[${context.indexPrefix}] `;
  let prevTimestamp = startTime;
  let lastState;
  try {
    const finalState = await (0, _state_action_machine.stateActionMachine)(initialState, state => next(state), (state, res) => {
      var _outdatedDocuments, _bulkOperationBatches;
      lastState = state;
      (0, _utils.logActionResponse)(logger, logMessagePrefix, state, res);
      const newState = model(state, res, context);
      // Redact the state to reduce the memory consumption and so that we
      // don't log sensitive information inside documents by only keeping
      // the _id's of documents
      const redactedNewState = {
        ...newState,
        outdatedDocuments: ((_outdatedDocuments = newState.outdatedDocuments) !== null && _outdatedDocuments !== void 0 ? _outdatedDocuments : []).map(doc => ({
          _id: doc._id
        })),
        bulkOperationBatches: (0, _redact_state.redactBulkOperationBatches)((_bulkOperationBatches = newState.bulkOperationBatches) !== null && _bulkOperationBatches !== void 0 ? _bulkOperationBatches : [[]])
      };
      const now = Date.now();
      (0, _utils.logStateTransition)(logger, logMessagePrefix, state, redactedNewState, now - prevTimestamp);
      prevTimestamp = now;
      return newState;
    });
    const elapsedMs = Date.now() - startTime;
    if (finalState.controlState === 'DONE') {
      logger.info(logMessagePrefix + `Migration completed after ${Math.round(elapsedMs)}ms`);
      return {
        status: 'patched',
        destIndex: context.indexPrefix,
        elapsedMs
      };
    } else if (finalState.controlState === 'FATAL') {
      try {
        await (0, _migrations_state_machine_cleanup.cleanup)(context.elasticsearchClient, finalState);
      } catch (e) {
        logger.warn('Failed to cleanup after migrations:', e.message);
      }
      return Promise.reject(new Error(`Unable to complete saved object migrations for the [${context.indexPrefix}] index: ` + finalState.reason));
    } else {
      throw new Error('Invalid terminating control state');
    }
  } catch (e) {
    try {
      await (0, _migrations_state_machine_cleanup.cleanup)(context.elasticsearchClient, lastState);
    } catch (err) {
      logger.warn('Failed to cleanup after migrations:', err.message);
    }
    if (e instanceof _elasticsearch.errors.ResponseError) {
      // Log the failed request. This is very similar to the
      // elasticsearch-service's debug logs, but we log everything in single
      // line until we have sub-ms resolution in our cloud logs. Because this
      // is error level logs, we're also more careful and don't log the request
      // body since this can very likely have sensitive saved objects.
      const req = (0, _coreElasticsearchClientServerInternal.getRequestDebugMeta)(e.meta);
      const failedRequestMessage = `Unexpected Elasticsearch ResponseError: statusCode: ${req.statusCode}, method: ${req.method}, url: ${req.url} error: ${(0, _coreElasticsearchClientServerInternal.getErrorMessage)(e)},`;
      logger.error(logMessagePrefix + failedRequestMessage);
      throw new Error(`Unable to complete saved object migrations for the [${context.indexPrefix}] index. Please check the health of your Elasticsearch cluster and try again. ${failedRequestMessage}`);
    } else {
      logger.error(e);
      const newError = new Error(`Unable to complete saved object migrations for the [${context.indexPrefix}] index. ${e}`);

      // restore error stack to point to a source of the problem.
      newError.stack = `[${e.stack}]`;
      throw newError;
    }
  }
}