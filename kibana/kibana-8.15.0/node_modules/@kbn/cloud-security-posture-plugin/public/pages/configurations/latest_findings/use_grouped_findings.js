"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useGroupedFindings = exports.getGroupedFindingsQuery = void 0;
var _reactQuery = require("@tanstack/react-query");
var _rxjs = require("rxjs");
var _constants = require("../../../../common/constants");
var _use_kibana = require("../../../common/hooks/use_kibana");
var _show_error_toast = require("../../../common/utils/show_error_toast");
/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0; you may not use this file except in compliance with the Elastic License
 * 2.0.
 */

// Elasticsearch returns `null` when a sub-aggregation cannot be computed

const getGroupedFindingsQuery = query => ({
  ...query,
  index: _constants.CSP_LATEST_FINDINGS_DATA_VIEW,
  size: 0
});
exports.getGroupedFindingsQuery = getGroupedFindingsQuery;
const useGroupedFindings = ({
  query,
  enabled = true
}) => {
  const {
    data,
    notifications: {
      toasts
    }
  } = (0, _use_kibana.useKibana)().services;
  return (0, _reactQuery.useQuery)(['csp_grouped_findings', {
    query
  }], async () => {
    const {
      rawResponse: {
        aggregations
      }
    } = await (0, _rxjs.lastValueFrom)(data.search.search({
      params: getGroupedFindingsQuery(query)
    }));
    if (!aggregations) throw new Error('Failed to aggregate by, missing resource id');
    return aggregations;
  }, {
    onError: err => (0, _show_error_toast.showErrorToast)(toasts, err),
    enabled,
    // This allows the UI to keep the previous data while the new data is being fetched
    keepPreviousData: true
  });
};
exports.useGroupedFindings = useGroupedFindings;