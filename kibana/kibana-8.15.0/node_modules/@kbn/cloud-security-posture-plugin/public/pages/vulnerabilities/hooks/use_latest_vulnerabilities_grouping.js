"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useLatestVulnerabilitiesGrouping = exports.isVulnerabilitiesRootGroupingAggregation = void 0;
var _grouping = require("@kbn/grouping");
var _src = require("@kbn/grouping/src");
var _react = require("react");
var _esQuery = require("@kbn/es-query");
var _constants = require("../../../common/constants");
var _data_view_context = require("../../../common/contexts/data_view_context");
var _constants2 = require("../../../../common/constants");
var _use_grouped_vulnerabilities = require("./use_grouped_vulnerabilities");
var _constants3 = require("../constants");
var _cloud_security_grouping = require("../../../components/cloud_security_grouping");
var _translations = require("../translations");
/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0; you may not use this file except in compliance with the Elastic License
 * 2.0.
 */

const getTermAggregation = (key, field) => ({
  [key]: {
    terms: {
      field,
      size: 1
    }
  }
});
const getAggregationsByGroupField = field => {
  if ((0, _src.isNoneGroup)([field])) {
    return [];
  }
  const aggMetrics = [{
    groupByField: {
      cardinality: {
        field
      }
    },
    critical: {
      filter: {
        term: {
          'vulnerability.severity': {
            value: _constants2.VULNERABILITIES_SEVERITY.CRITICAL
          }
        }
      }
    },
    high: {
      filter: {
        term: {
          'vulnerability.severity': {
            value: _constants2.VULNERABILITIES_SEVERITY.HIGH
          }
        }
      }
    },
    medium: {
      filter: {
        term: {
          'vulnerability.severity': {
            value: _constants2.VULNERABILITIES_SEVERITY.MEDIUM
          }
        }
      }
    },
    low: {
      filter: {
        term: {
          'vulnerability.severity': {
            value: _constants2.VULNERABILITIES_SEVERITY.LOW
          }
        }
      }
    }
  }];
  switch (field) {
    case _constants.VULNERABILITY_GROUPING_OPTIONS.RESOURCE_NAME:
      return [...aggMetrics, getTermAggregation('resourceId', _constants.VULNERABILITY_FIELDS.RESOURCE_ID)];
    case _constants.VULNERABILITY_GROUPING_OPTIONS.CLOUD_ACCOUNT_NAME:
      return [...aggMetrics, getTermAggregation('cloudProvider', _constants.VULNERABILITY_FIELDS.CLOUD_PROVIDER)];
    case _constants.VULNERABILITY_GROUPING_OPTIONS.CVE:
      return [...aggMetrics, getTermAggregation('description', _constants.VULNERABILITY_FIELDS.DESCRIPTION)];
  }
  return aggMetrics;
};

/**
 * Type Guard for checking if the given source is a VulnerabilitiesRootGroupingAggregation
 */
const isVulnerabilitiesRootGroupingAggregation = groupData => {
  var _groupData$unitsCount;
  return (groupData === null || groupData === void 0 ? void 0 : (_groupData$unitsCount = groupData.unitsCount) === null || _groupData$unitsCount === void 0 ? void 0 : _groupData$unitsCount.value) !== undefined;
};

/**
 * Utility hook to get the latest vulnerabilities grouping data
 * for the vulnerabilities page
 */
exports.isVulnerabilitiesRootGroupingAggregation = isVulnerabilitiesRootGroupingAggregation;
const useLatestVulnerabilitiesGrouping = ({
  groupPanelRenderer,
  groupStatsRenderer,
  groupingLevel = 0,
  groupFilters = [],
  selectedGroup
}) => {
  var _groupData$unitsCount2;
  const {
    dataView
  } = (0, _data_view_context.useDataViewContext)();
  const {
    activePageIndex,
    grouping,
    pageSize,
    query,
    onChangeGroupsItemsPerPage,
    onChangeGroupsPage,
    urlQuery,
    setUrlQuery,
    uniqueValue,
    isNoneSelected,
    onResetFilters,
    error,
    filters,
    setActivePageIndex
  } = (0, _cloud_security_grouping.useCloudSecurityGrouping)({
    dataView,
    groupingTitle: _translations.groupingTitle,
    defaultGroupingOptions: _constants3.defaultGroupingOptions,
    getDefaultQuery: _constants3.getDefaultQuery,
    unit: _translations.VULNERABILITIES_UNIT,
    groupPanelRenderer,
    groupStatsRenderer,
    groupingLocalStorageKey: _constants.LOCAL_STORAGE_VULNERABILITIES_GROUPING_KEY,
    groupingLevel,
    groupsUnit: _translations.VULNERABILITIES_GROUPS_UNIT
  });
  const additionalFilters = (0, _esQuery.buildEsQuery)(dataView, [], groupFilters);
  const currentSelectedGroup = selectedGroup || grouping.selectedGroups[0];
  const groupingQuery = (0, _grouping.getGroupingQuery)({
    additionalFilters: query ? [query, additionalFilters] : [additionalFilters],
    groupByField: currentSelectedGroup,
    uniqueValue,
    from: `now-${_constants2.LATEST_VULNERABILITIES_RETENTION_POLICY}`,
    to: 'now',
    pageNumber: activePageIndex * pageSize,
    size: pageSize,
    sort: [{
      groupByField: {
        order: 'desc'
      }
    }],
    statsAggregations: getAggregationsByGroupField(currentSelectedGroup)
  });
  const {
    data,
    isFetching
  } = (0, _use_grouped_vulnerabilities.useGroupedVulnerabilities)({
    query: groupingQuery,
    enabled: !isNoneSelected
  });
  const groupData = (0, _react.useMemo)(() => (0, _src.parseGroupingQuery)(currentSelectedGroup, uniqueValue, data), [data, currentSelectedGroup, uniqueValue]);
  const isEmptyResults = !isFetching && isVulnerabilitiesRootGroupingAggregation(groupData) && ((_groupData$unitsCount2 = groupData.unitsCount) === null || _groupData$unitsCount2 === void 0 ? void 0 : _groupData$unitsCount2.value) === 0;
  return {
    groupData,
    grouping,
    isFetching,
    activePageIndex,
    setActivePageIndex,
    pageSize,
    selectedGroup,
    onChangeGroupsItemsPerPage,
    onChangeGroupsPage,
    urlQuery,
    setUrlQuery,
    isGroupSelected: !isNoneSelected,
    isGroupLoading: !data,
    onResetFilters,
    filters,
    error,
    isEmptyResults
  };
};
exports.useLatestVulnerabilitiesGrouping = useLatestVulnerabilitiesGrouping;