"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Tabs = void 0;
var _lodash = require("lodash");
var _react = _interopRequireWildcard(require("react"));
var _eui = require("@elastic/eui");
var _i18n = require("@kbn/i18n");
var _public = require("@kbn/kibana-utils-plugin/public");
var _public2 = require("@kbn/data-views-plugin/public");
var _public3 = require("@kbn/kibana-react-plugin/public");
var _edit_index_pattern_state_container = require("../edit_index_pattern_state_container");
var _constants = require("../constants");
var _source_filters_table = require("../source_filters_table");
var _indexed_fields_table = require("../indexed_fields_table");
var _scripted_fields_table = require("../scripted_fields_table");
var _relationships_table = require("../relationships_table");
var _utils = require("./utils");
var _utils2 = require("../../utils");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0 and the Server Side Public License, v 1; you may not use this file except
 * in compliance with, at your election, the Elastic License 2.0 or the Server
 * Side Public License, v 1.
 */

const searchAriaLabel = _i18n.i18n.translate('indexPatternManagement.editIndexPattern.fields.searchAria', {
  defaultMessage: 'Search fields'
});
const filterLabel = _i18n.i18n.translate('indexPatternManagement.editIndexPattern.fields.filter', {
  defaultMessage: 'Field type'
});
const filterAriaLabel = _i18n.i18n.translate('indexPatternManagement.editIndexPattern.fields.filterAria', {
  defaultMessage: 'Filter field types'
});
const schemaFilterLabel = _i18n.i18n.translate('indexPatternManagement.editIndexPattern.fields.schema', {
  defaultMessage: 'Schema type'
});
const schemaAriaLabel = _i18n.i18n.translate('indexPatternManagement.editIndexPattern.fields.schemaAria', {
  defaultMessage: 'Filter schema types'
});
const scriptedFieldFilterLabel = _i18n.i18n.translate('indexPatternManagement.editIndexPattern.fields.scriptedFieldFilter', {
  defaultMessage: 'All languages'
});
const scriptedFieldAriaLabel = _i18n.i18n.translate('indexPatternManagement.editIndexPattern.fields.scriptedFieldFilterAria', {
  defaultMessage: 'Filter scripted field languages'
});
const schemaOptionRuntime = _i18n.i18n.translate('indexPatternManagement.editIndexPattern.fields.runtime', {
  defaultMessage: 'Runtime'
});
const schemaOptionIndexed = _i18n.i18n.translate('indexPatternManagement.editIndexPattern.fields.indexed', {
  defaultMessage: 'Indexed'
});
const filterPlaceholder = _i18n.i18n.translate('indexPatternManagement.editIndexPattern.fields.filterPlaceholder', {
  defaultMessage: 'Search'
});
const addFieldButtonLabel = _i18n.i18n.translate('indexPatternManagement.editIndexPattern.fields.addFieldButtonLabel', {
  defaultMessage: 'Add field'
});
const refreshAriaLabel = _i18n.i18n.translate('indexPatternManagement.editDataView.refreshAria', {
  defaultMessage: 'Refresh'
});
const refreshTooltip = _i18n.i18n.translate('indexPatternManagement.editDataView.refreshTooltip', {
  defaultMessage: 'Refresh local copy of data view field list'
});
const SCHEMA_ITEMS = [{
  value: 'runtime',
  name: schemaOptionRuntime
}, {
  value: 'indexed',
  name: schemaOptionIndexed
}];
const Tabs = ({
  indexPattern,
  saveIndexPattern,
  fields,
  history,
  refreshFields,
  relationships,
  allowedTypes,
  compositeRuntimeFields,
  refreshIndexPatternClick,
  isRefreshing
}) => {
  const {
    uiSettings,
    docLinks,
    dataViewFieldEditor,
    overlays,
    dataViews,
    http,
    application,
    savedObjectsManagement,
    ...startServices
  } = (0, _public3.useKibana)().services;
  const [fieldFilter, setFieldFilter] = (0, _react.useState)('');
  const [syncingStateFunc, setSyncingStateFunc] = (0, _react.useState)({});
  const [scriptedFieldLanguageFilter, setScriptedFieldLanguageFilter] = (0, _react.useState)([]);
  const [isScriptedFieldFilterOpen, setIsScriptedFieldFilterOpen] = (0, _react.useState)(false);
  const [scriptedFieldLanguages, setScriptedFieldLanguages] = (0, _react.useState)([]);
  const [indexedFieldTypeFilter, setIndexedFieldTypeFilter] = (0, _react.useState)([]);
  const [isIndexedFilterOpen, setIsIndexedFilterOpen] = (0, _react.useState)(false);
  const [indexedFieldTypes, setIndexedFieldTypes] = (0, _react.useState)([]);
  const [schemaFieldTypeFilter, setSchemaFieldTypeFilter] = (0, _react.useState)([]);
  const [isSchemaFilterOpen, setIsSchemaFilterOpen] = (0, _react.useState)(false);
  const closeEditorHandler = (0, _react.useRef)();
  const {
    DeleteRuntimeFieldProvider
  } = dataViewFieldEditor;
  const filteredIndexedFieldTypeFilter = (0, _react.useMemo)(() => {
    return (0, _lodash.uniq)(indexedFieldTypeFilter.filter(fieldType => indexedFieldTypes.some(item => item.value === fieldType)));
  }, [indexedFieldTypeFilter, indexedFieldTypes]);
  const filteredSchemaFieldTypeFilter = (0, _react.useMemo)(() => {
    return (0, _lodash.uniq)(schemaFieldTypeFilter.filter(schemaFieldType => SCHEMA_ITEMS.some(item => item.value === schemaFieldType)));
  }, [schemaFieldTypeFilter]);
  const updateTab = (0, _react.useCallback)(tab => {
    var _syncingStateFunc$set;
    (_syncingStateFunc$set = syncingStateFunc.setCurrentTab) === null || _syncingStateFunc$set === void 0 ? void 0 : _syncingStateFunc$set.call(syncingStateFunc, tab.id);
  }, [syncingStateFunc]);
  const updateFieldTypeFilter = (0, _react.useCallback)(newIndexedFieldTypeFilter => {
    var _syncingStateFunc$set2;
    syncingStateFunc === null || syncingStateFunc === void 0 ? void 0 : (_syncingStateFunc$set2 = syncingStateFunc.setCurrentFieldTypes) === null || _syncingStateFunc$set2 === void 0 ? void 0 : _syncingStateFunc$set2.call(syncingStateFunc, newIndexedFieldTypeFilter);
  }, [syncingStateFunc]);
  const updateSchemaFieldTypeFilter = (0, _react.useCallback)(newSchemaFieldTypeFilter => {
    var _syncingStateFunc$set3;
    syncingStateFunc === null || syncingStateFunc === void 0 ? void 0 : (_syncingStateFunc$set3 = syncingStateFunc.setCurrentSchemaFieldTypes) === null || _syncingStateFunc$set3 === void 0 ? void 0 : _syncingStateFunc$set3.call(syncingStateFunc, newSchemaFieldTypeFilter);
  }, [syncingStateFunc]);
  const updateFieldFilter = (0, _react.useCallback)(newFieldFilter => {
    var _syncingStateFunc$set4;
    syncingStateFunc === null || syncingStateFunc === void 0 ? void 0 : (_syncingStateFunc$set4 = syncingStateFunc.setCurrentFieldFilter) === null || _syncingStateFunc$set4 === void 0 ? void 0 : _syncingStateFunc$set4.call(syncingStateFunc, newFieldFilter || undefined);
  }, [syncingStateFunc]);
  const updateFilterItem = (items, index, updater) => {
    if (!items[index]) {
      return;
    }
    const newItems = [...items];
    switch (newItems[index].checked) {
      case 'on':
        newItems[index].checked = undefined;
        break;
      default:
        newItems[index].checked = 'on';
    }
    updater(newItems);
  };
  const refreshFilters = (0, _react.useCallback)(() => {
    const tempIndexedFieldTypes = [];
    const tempScriptedFieldLanguages = [];
    indexPattern.fields.getAll().forEach(field => {
      if (field.scripted) {
        if (field.lang) {
          tempScriptedFieldLanguages.push(field.lang);
        }
      } else {
        // for conflicted fields, add conflict as a type
        if (field.type === 'conflict') {
          tempIndexedFieldTypes.push('conflict');
        }
        if (field.esTypes) {
          // add all types, may be multiple
          field.esTypes.forEach(item => tempIndexedFieldTypes.push(item));
        }
      }
    });
    setIndexedFieldTypes((0, _utils.convertToEuiFilterOptions)(tempIndexedFieldTypes));
    setScriptedFieldLanguages((0, _utils.convertToEuiFilterOptions)(tempScriptedFieldLanguages));
    // need to reset based on changes to fields but indexPattern is the same
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [indexPattern, fields]);
  const closeFieldEditor = (0, _react.useCallback)(() => {
    if (closeEditorHandler.current) {
      closeEditorHandler.current();
    }
  }, []);
  const openFieldEditor = (0, _react.useCallback)(async fieldName => {
    closeEditorHandler.current = await dataViewFieldEditor.openEditor({
      ctx: {
        dataView: indexPattern
      },
      onSave: refreshFields,
      fieldName
    });
  }, [dataViewFieldEditor, indexPattern, refreshFields]);
  (0, _react.useEffect)(() => {
    refreshFilters();
  }, [indexPattern, indexPattern.fields, refreshFilters]);
  (0, _react.useEffect)(() => {
    return () => {
      // When the component unmounts, make sure to close the field editor
      closeFieldEditor();
    };
  }, [closeFieldEditor]);
  const fieldWildcardMatcherDecorated = (0, _react.useCallback)(filters => (0, _public.fieldWildcardMatcher)(filters, uiSettings.get(_public2.META_FIELDS)), [uiSettings]);
  const refreshRef = (0, _react.useRef)(null);
  const userEditPermission = dataViews.getCanSaveSync();
  const getFilterSection = (0, _react.useCallback)(type => {
    return /*#__PURE__*/_react.default.createElement(_eui.EuiFlexGroup, {
      gutterSize: "m"
    }, /*#__PURE__*/_react.default.createElement(_eui.EuiFlexItem, {
      grow: true
    }, /*#__PURE__*/_react.default.createElement(_eui.EuiFieldSearch, {
      fullWidth: true,
      placeholder: filterPlaceholder,
      value: fieldFilter,
      onChange: e => updateFieldFilter(e.target.value),
      "data-test-subj": "indexPatternFieldFilter",
      "aria-label": searchAriaLabel
    })), type === _constants.TAB_INDEXED_FIELDS && indexedFieldTypes.length > 0 && /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, /*#__PURE__*/_react.default.createElement(_eui.EuiFlexItem, {
      grow: false
    }, /*#__PURE__*/_react.default.createElement(_eui.EuiFilterGroup, null, /*#__PURE__*/_react.default.createElement(_eui.EuiPopover, {
      anchorPosition: "downCenter",
      "data-test-subj": "indexedFieldTypeFilterDropdown-popover",
      button: /*#__PURE__*/_react.default.createElement(_eui.EuiFilterButton, {
        "aria-label": filterAriaLabel,
        "data-test-subj": "indexedFieldTypeFilterDropdown",
        iconType: "arrowDown",
        onClick: () => setIsIndexedFilterOpen(!isIndexedFilterOpen),
        isSelected: isIndexedFilterOpen,
        numFilters: indexedFieldTypes.length,
        hasActiveFilters: filteredIndexedFieldTypeFilter.length > 0,
        numActiveFilters: filteredIndexedFieldTypeFilter.length
      }, filterLabel),
      isOpen: isIndexedFilterOpen,
      closePopover: () => setIsIndexedFilterOpen(false)
    }, indexedFieldTypes.map(item => {
      const isSelected = filteredIndexedFieldTypeFilter.includes(item.value);
      return /*#__PURE__*/_react.default.createElement(_eui.EuiFilterSelectItem, {
        checked: isSelected ? 'on' : undefined,
        key: item.value,
        onClick: () => {
          updateFieldTypeFilter(isSelected ? filteredIndexedFieldTypeFilter.filter(f => f !== item.value) : [...filteredIndexedFieldTypeFilter, item.value]);
        },
        "data-test-subj": `indexedFieldTypeFilterDropdown-option-${item.value}${isSelected ? '-checked' : ''}`
      }, item.name);
    })), /*#__PURE__*/_react.default.createElement(_eui.EuiPopover, {
      anchorPosition: "downCenter",
      "data-test-subj": "schemaFieldTypeFilterDropdown-popover",
      button: /*#__PURE__*/_react.default.createElement(_eui.EuiFilterButton, {
        "aria-label": schemaAriaLabel,
        "data-test-subj": "schemaFieldTypeFilterDropdown",
        iconType: "arrowDown",
        onClick: () => setIsSchemaFilterOpen(!isSchemaFilterOpen),
        isSelected: isSchemaFilterOpen,
        numFilters: SCHEMA_ITEMS.length,
        hasActiveFilters: filteredSchemaFieldTypeFilter.length > 0,
        numActiveFilters: filteredSchemaFieldTypeFilter.length
      }, schemaFilterLabel),
      isOpen: isSchemaFilterOpen,
      closePopover: () => setIsSchemaFilterOpen(false)
    }, SCHEMA_ITEMS.map(item => {
      const isSelected = filteredSchemaFieldTypeFilter.includes(item.value);
      return /*#__PURE__*/_react.default.createElement(_eui.EuiFilterSelectItem, {
        checked: isSelected ? 'on' : undefined,
        key: item.value,
        onClick: () => {
          updateSchemaFieldTypeFilter(isSelected ? filteredSchemaFieldTypeFilter.filter(f => f !== item.value) : [...filteredSchemaFieldTypeFilter, item.value]);
        },
        "data-test-subj": `schemaFieldTypeFilterDropdown-option-${item.value}${isSelected ? '-checked' : ''}`
      }, item.name);
    })))), /*#__PURE__*/_react.default.createElement(_eui.EuiFlexItem, {
      grow: false
    }, /*#__PURE__*/_react.default.createElement(_eui.EuiToolTip, {
      content: /*#__PURE__*/_react.default.createElement("p", null, refreshTooltip)
    }, /*#__PURE__*/_react.default.createElement(_eui.EuiButton, {
      buttonRef: refreshRef,
      onClick: () => {
        refreshIndexPatternClick();
        // clear tooltip focus
        if (refreshRef.current) {
          refreshRef.current.blur();
        }
      },
      iconType: "refresh",
      "aria-label": refreshAriaLabel,
      "data-test-subj": "refreshDataViewButton",
      isLoading: isRefreshing,
      isDisabled: isRefreshing,
      size: "m",
      color: "success",
      className: "eui-fullWidth"
    }, refreshAriaLabel))), userEditPermission && /*#__PURE__*/_react.default.createElement(_eui.EuiFlexItem, {
      grow: false
    }, /*#__PURE__*/_react.default.createElement(_eui.EuiButton, {
      size: "m",
      onClick: () => openFieldEditor(),
      "data-test-subj": "addField",
      iconType: "plusInCircle",
      "aria-label": addFieldButtonLabel,
      color: "primary",
      fill: true
    }, addFieldButtonLabel))), type === _constants.TAB_SCRIPTED_FIELDS && scriptedFieldLanguages.length > 0 && /*#__PURE__*/_react.default.createElement(_eui.EuiFlexItem, {
      grow: false
    }, /*#__PURE__*/_react.default.createElement(_eui.EuiFilterGroup, null, /*#__PURE__*/_react.default.createElement(_eui.EuiPopover, {
      anchorPosition: "downCenter",
      "data-test-subj": "scriptedFieldLanguageFilterDropdown-popover",
      button: /*#__PURE__*/_react.default.createElement(_eui.EuiFilterButton, {
        "aria-label": scriptedFieldAriaLabel,
        "data-test-subj": "scriptedFieldLanguageFilterDropdown",
        iconType: "arrowDown",
        onClick: () => setIsScriptedFieldFilterOpen(!isScriptedFieldFilterOpen),
        isSelected: isScriptedFieldFilterOpen,
        numFilters: scriptedFieldLanguages.length,
        hasActiveFilters: !!scriptedFieldLanguages.find(item => item.checked === 'on'),
        numActiveFilters: scriptedFieldLanguages.filter(item => item.checked === 'on').length
      }, scriptedFieldFilterLabel),
      isOpen: isScriptedFieldFilterOpen,
      closePopover: () => setIsScriptedFieldFilterOpen(false)
    }, scriptedFieldLanguages.map((item, index) => /*#__PURE__*/_react.default.createElement(_eui.EuiFilterSelectItem, {
      checked: item.checked,
      key: item.value,
      onClick: () => {
        setScriptedFieldLanguageFilter(item.checked ? scriptedFieldLanguageFilter.filter(f => f !== item.value) : [...scriptedFieldLanguageFilter, item.value]);
        updateFilterItem(scriptedFieldLanguages, index, setScriptedFieldLanguages);
      },
      "data-test-subj": `scriptedFieldLanguageFilterDropdown-option-${item.value}${item.checked ? '-checked' : ''}`
    }, item.name))))));
  }, [fieldFilter, filteredSchemaFieldTypeFilter, filteredIndexedFieldTypeFilter, indexedFieldTypes, isIndexedFilterOpen, scriptedFieldLanguageFilter, scriptedFieldLanguages, isScriptedFieldFilterOpen, isSchemaFilterOpen, openFieldEditor, userEditPermission, updateFieldFilter, updateFieldTypeFilter, updateSchemaFieldTypeFilter, isRefreshing, refreshIndexPatternClick]);
  const getContent = (0, _react.useCallback)(type => {
    switch (type) {
      case _constants.TAB_INDEXED_FIELDS:
        return /*#__PURE__*/_react.default.createElement(_react.Fragment, null, /*#__PURE__*/_react.default.createElement(_eui.EuiSpacer, {
          size: "m"
        }), getFilterSection(type), /*#__PURE__*/_react.default.createElement(_eui.EuiSpacer, {
          size: "m"
        }), /*#__PURE__*/_react.default.createElement(DeleteRuntimeFieldProvider, {
          dataView: indexPattern,
          onDelete: refreshFields
        }, deleteField => /*#__PURE__*/_react.default.createElement(_indexed_fields_table.IndexedFieldsTable, {
          fields: fields,
          compositeRuntimeFields: compositeRuntimeFields,
          indexPattern: indexPattern,
          fieldFilter: fieldFilter,
          fieldWildcardMatcher: fieldWildcardMatcherDecorated,
          indexedFieldTypeFilter: filteredIndexedFieldTypeFilter,
          schemaFieldTypeFilter: filteredSchemaFieldTypeFilter,
          helpers: {
            editField: openFieldEditor,
            deleteField,
            getFieldInfo: _utils2.getFieldInfo
          },
          openModal: overlays.openModal,
          userEditPermission: dataViews.getCanSaveSync(),
          startServices: startServices
        })));
      case _constants.TAB_SCRIPTED_FIELDS:
        return /*#__PURE__*/_react.default.createElement(_react.Fragment, null, /*#__PURE__*/_react.default.createElement(_eui.EuiSpacer, {
          size: "m"
        }), getFilterSection(type), /*#__PURE__*/_react.default.createElement(_eui.EuiSpacer, {
          size: "m"
        }), /*#__PURE__*/_react.default.createElement(_scripted_fields_table.ScriptedFieldsTable, {
          indexPattern: indexPattern,
          saveIndexPattern: saveIndexPattern,
          fieldFilter: fieldFilter,
          scriptedFieldLanguageFilter: scriptedFieldLanguageFilter,
          helpers: {
            redirectToRoute: field => {
              history.push((0, _utils.getPath)(field, indexPattern));
            }
          },
          onRemoveField: refreshFilters,
          painlessDocLink: docLinks.links.scriptedFields.painless,
          userEditPermission: dataViews.getCanSaveSync()
        }));
      case _constants.TAB_SOURCE_FILTERS:
        return /*#__PURE__*/_react.default.createElement(_react.Fragment, null, /*#__PURE__*/_react.default.createElement(_eui.EuiSpacer, {
          size: "m"
        }), getFilterSection(type), /*#__PURE__*/_react.default.createElement(_eui.EuiSpacer, {
          size: "m"
        }), /*#__PURE__*/_react.default.createElement(_source_filters_table.SourceFiltersTable, {
          saveIndexPattern: saveIndexPattern,
          indexPattern: indexPattern,
          filterFilter: fieldFilter,
          fieldWildcardMatcher: fieldWildcardMatcherDecorated,
          onAddOrRemoveFilter: refreshFilters
        }));
      case _constants.TAB_RELATIONSHIPS:
        return /*#__PURE__*/_react.default.createElement(_react.Fragment, null, /*#__PURE__*/_react.default.createElement(_eui.EuiSpacer, {
          size: "m"
        }), /*#__PURE__*/_react.default.createElement(_relationships_table.RelationshipsTable, {
          basePath: http.basePath,
          id: indexPattern.id,
          capabilities: application.capabilities,
          relationships: relationships,
          allowedTypes: allowedTypes,
          navigateToUrl: application.navigateToUrl,
          getDefaultTitle: savedObjectsManagement.getDefaultTitle,
          getSavedObjectLabel: savedObjectsManagement.getSavedObjectLabel
        }));
    }
  }, [docLinks.links.scriptedFields.painless, fieldFilter, fieldWildcardMatcherDecorated, fields, getFilterSection, history, indexPattern, filteredIndexedFieldTypeFilter, filteredSchemaFieldTypeFilter, refreshFilters, scriptedFieldLanguageFilter, saveIndexPattern, openFieldEditor, DeleteRuntimeFieldProvider, refreshFields, overlays, startServices, dataViews, compositeRuntimeFields, http, application, savedObjectsManagement, allowedTypes, relationships]);
  const euiTabs = (0, _react.useMemo)(() => (0, _utils.getTabs)(indexPattern, fieldFilter, relationships.length, dataViews.scriptedFieldsEnabled).map(tab => {
    return {
      ...tab,
      content: getContent(tab.id)
    };
  }), [fieldFilter, getContent, indexPattern, relationships, dataViews.scriptedFieldsEnabled]);
  const [selectedTabId, setSelectedTabId] = (0, _react.useState)(euiTabs[0].id);
  (0, _react.useEffect)(() => {
    const {
      startSyncingState,
      stopSyncingState,
      setCurrentTab,
      setCurrentFieldTypes,
      setCurrentFieldFilter,
      setCurrentSchemaFieldTypes,
      stateContainer
    } = (0, _edit_index_pattern_state_container.createEditIndexPatternPageStateContainer)({
      useHashedUrl: uiSettings.get('state:storeInSessionStorage'),
      defaultTab: _constants.TAB_INDEXED_FIELDS
    });
    startSyncingState();
    setSyncingStateFunc({
      setCurrentTab,
      setCurrentFieldTypes,
      setCurrentFieldFilter,
      setCurrentSchemaFieldTypes
    });
    setSelectedTabId(stateContainer.selectors.tab());
    setIndexedFieldTypeFilter(currentValue => {
      var _stateContainer$selec;
      return (_stateContainer$selec = stateContainer.selectors.fieldTypes()) !== null && _stateContainer$selec !== void 0 ? _stateContainer$selec : [];
    });
    setSchemaFieldTypeFilter(currentValue => {
      var _stateContainer$selec2;
      return (_stateContainer$selec2 = stateContainer.selectors.schemaFieldTypes()) !== null && _stateContainer$selec2 !== void 0 ? _stateContainer$selec2 : [];
    });
    setFieldFilter(currentValue => {
      var _stateContainer$selec3;
      return (_stateContainer$selec3 = stateContainer.selectors.fieldFilter()) !== null && _stateContainer$selec3 !== void 0 ? _stateContainer$selec3 : '';
    });
    const stateSubscription = stateContainer.state$.subscribe(() => {
      setSelectedTabId(stateContainer.selectors.tab());
      setIndexedFieldTypeFilter(currentValue => {
        var _stateContainer$selec4;
        return (_stateContainer$selec4 = stateContainer.selectors.fieldTypes()) !== null && _stateContainer$selec4 !== void 0 ? _stateContainer$selec4 : [];
      });
      setSchemaFieldTypeFilter(currentValue => {
        var _stateContainer$selec5;
        return (_stateContainer$selec5 = stateContainer.selectors.schemaFieldTypes()) !== null && _stateContainer$selec5 !== void 0 ? _stateContainer$selec5 : [];
      });
      setFieldFilter(currentValue => {
        var _stateContainer$selec6;
        return (_stateContainer$selec6 = stateContainer.selectors.fieldFilter()) !== null && _stateContainer$selec6 !== void 0 ? _stateContainer$selec6 : '';
      });
    });
    return () => {
      stateSubscription.unsubscribe();
      stopSyncingState();
    };
  }, [uiSettings]);
  return /*#__PURE__*/_react.default.createElement(_eui.EuiTabbedContent, {
    tabs: euiTabs,
    selectedTab: euiTabs.find(tab => tab.id === selectedTabId),
    onTabClick: updateTab
  });
};
exports.Tabs = Tabs;