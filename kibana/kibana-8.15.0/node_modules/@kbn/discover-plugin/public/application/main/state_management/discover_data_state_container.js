"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getDataStateContainer = getDataStateContainer;
var _rxjs = require("rxjs");
var _common = require("@kbn/inspector-plugin/common");
var _esQuery = require("@kbn/es-query");
var _ebtTools = require("@kbn/ebt-tools");
var _discoverUtils = require("@kbn/discover-utils");
var _get_esql_data_view = require("./utils/get_esql_data_view");
var _types = require("../../types");
var _validate_time_range = require("./utils/validate_time_range");
var _fetch_all = require("../data_fetching/fetch_all");
var _use_saved_search_messages = require("../hooks/use_saved_search_messages");
var _get_fetch_observable = require("../data_fetching/get_fetch_observable");
/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0 and the Server Side Public License, v 1; you may not use this file except
 * in compliance with, at your election, the Elastic License 2.0 or the Server
 * Side Public License, v 1.
 */

/**
 * Container responsible for fetching of data in Discover Main
 * Either by triggering requests to Elasticsearch directly, or by
 * orchestrating unified plugins / components like the histogram
 */
function getDataStateContainer({
  services,
  searchSessionManager,
  getAppState,
  getInternalState,
  getSavedSearch,
  setDataView
}) {
  const {
    data,
    uiSettings,
    toastNotifications,
    profilesManager
  } = services;
  const {
    timefilter
  } = data.query.timefilter;
  const inspectorAdapters = {
    requests: new _common.RequestAdapter()
  };

  /**
   * The observable to trigger data fetching in UI
   * By refetch$.next('reset') rows and fieldcounts are reset to allow e.g. editing of runtime fields
   * to be processed correctly
   */
  const refetch$ = new _rxjs.Subject();
  const getInitialFetchStatus = () => {
    const shouldSearchOnPageLoad = uiSettings.get(_discoverUtils.SEARCH_ON_PAGE_LOAD_SETTING) || getSavedSearch().id !== undefined || !timefilter.getRefreshInterval().pause || searchSessionManager.hasSearchSessionIdInURL();
    return shouldSearchOnPageLoad ? _types.FetchStatus.LOADING : _types.FetchStatus.UNINITIALIZED;
  };

  /**
   * The observables the UI (aka React component) subscribes to get notified about
   * the changes in the data fetching process (high level: fetching started, data was received)
   */
  const initialState = {
    fetchStatus: getInitialFetchStatus()
  };
  const dataSubjects = {
    main$: new _rxjs.BehaviorSubject(initialState),
    documents$: new _rxjs.BehaviorSubject(initialState),
    totalHits$: new _rxjs.BehaviorSubject(initialState),
    availableFields$: new _rxjs.BehaviorSubject(initialState)
  };
  let autoRefreshDone;
  /**
   * handler emitted by `timefilter.getAutoRefreshFetch$()`
   * to notify when data completed loading and to start a new autorefresh loop
   */
  const setAutoRefreshDone = fn => {
    autoRefreshDone = fn;
  };
  const fetch$ = (0, _get_fetch_observable.getFetch$)({
    setAutoRefreshDone,
    data,
    main$: dataSubjects.main$,
    refetch$,
    searchSource: getSavedSearch().searchSource,
    searchSessionManager
  }).pipe((0, _rxjs.filter)(() => (0, _validate_time_range.validateTimeRange)(timefilter.getTime(), toastNotifications)), (0, _rxjs.tap)(() => inspectorAdapters.requests.reset()), (0, _rxjs.map)(val => ({
    options: {
      reset: val === 'reset',
      fetchMore: val === 'fetch_more'
    },
    searchSessionId: val === 'fetch_more' && searchSessionManager.getCurrentSearchSessionId() || searchSessionManager.getNextSearchSessionId()
  })), (0, _rxjs.share)());
  let abortController;
  let abortControllerFetchMore;
  function subscribe() {
    const subscription = fetch$.pipe((0, _rxjs.mergeMap)(async ({
      options,
      searchSessionId
    }) => {
      var _abortController, _abortControllerFetch;
      const commonFetchDeps = {
        initialFetchStatus: getInitialFetchStatus(),
        inspectorAdapters,
        searchSessionId,
        services,
        getAppState,
        getInternalState,
        savedSearch: getSavedSearch(),
        useNewFieldsApi: !uiSettings.get(_discoverUtils.SEARCH_FIELDS_FROM_SOURCE)
      };
      (_abortController = abortController) === null || _abortController === void 0 ? void 0 : _abortController.abort();
      (_abortControllerFetch = abortControllerFetchMore) === null || _abortControllerFetch === void 0 ? void 0 : _abortControllerFetch.abort();
      if (options.fetchMore) {
        abortControllerFetchMore = new AbortController();
        const fetchMoreStartTime = window.performance.now();
        await (0, _fetch_all.fetchMoreDocuments)(dataSubjects, {
          abortController: abortControllerFetchMore,
          ...commonFetchDeps
        });
        const fetchMoreDuration = window.performance.now() - fetchMoreStartTime;
        (0, _ebtTools.reportPerformanceMetricEvent)(services.analytics, {
          eventName: 'discoverFetchMore',
          duration: fetchMoreDuration
        });
        return;
      }
      await profilesManager.resolveDataSourceProfile({
        dataSource: getAppState().dataSource,
        dataView: getSavedSearch().searchSource.getField('index'),
        query: getAppState().query
      });
      abortController = new AbortController();
      const prevAutoRefreshDone = autoRefreshDone;
      const fetchAllStartTime = window.performance.now();
      await (0, _fetch_all.fetchAll)(dataSubjects, options.reset, {
        abortController,
        ...commonFetchDeps
      });
      const fetchAllDuration = window.performance.now() - fetchAllStartTime;
      (0, _ebtTools.reportPerformanceMetricEvent)(services.analytics, {
        eventName: 'discoverFetchAll',
        duration: fetchAllDuration
      });

      // If the autoRefreshCallback is still the same as when we started i.e. there was no newer call
      // replacing this current one, call it to make sure we tell that the auto refresh is done
      // and a new one can be scheduled.
      if (autoRefreshDone === prevAutoRefreshDone) {
        var _autoRefreshDone;
        // if this function was set and is executed, another refresh fetch can be triggered
        (_autoRefreshDone = autoRefreshDone) === null || _autoRefreshDone === void 0 ? void 0 : _autoRefreshDone();
        autoRefreshDone = undefined;
      }
    })).subscribe();
    return () => {
      var _abortController2, _abortControllerFetch2;
      (_abortController2 = abortController) === null || _abortController2 === void 0 ? void 0 : _abortController2.abort();
      (_abortControllerFetch2 = abortControllerFetchMore) === null || _abortControllerFetch2 === void 0 ? void 0 : _abortControllerFetch2.abort();
      subscription.unsubscribe();
    };
  }
  const fetchQuery = async resetQuery => {
    const query = getAppState().query;
    const currentDataView = getSavedSearch().searchSource.getField('index');
    if ((0, _esQuery.isOfAggregateQueryType)(query)) {
      const nextDataView = await (0, _get_esql_data_view.getEsqlDataView)(query, currentDataView, services);
      if (nextDataView !== currentDataView) {
        setDataView(nextDataView);
      }
    }
    if (resetQuery) {
      refetch$.next('reset');
    } else {
      refetch$.next(undefined);
    }
    return refetch$;
  };
  const fetchMore = () => {
    refetch$.next('fetch_more');
    return refetch$;
  };
  const reset = () => {
    (0, _use_saved_search_messages.sendResetMsg)(dataSubjects, getInitialFetchStatus());
  };
  const cancel = () => {
    var _abortController3, _abortControllerFetch3;
    (_abortController3 = abortController) === null || _abortController3 === void 0 ? void 0 : _abortController3.abort();
    (_abortControllerFetch3 = abortControllerFetchMore) === null || _abortControllerFetch3 === void 0 ? void 0 : _abortControllerFetch3.abort();
  };
  const getAbortController = () => {
    return abortController;
  };
  return {
    fetch: fetchQuery,
    fetchMore,
    fetch$,
    data$: dataSubjects,
    refetch$,
    subscribe,
    reset,
    inspectorAdapters,
    getInitialFetchStatus,
    cancel,
    getAbortController
  };
}