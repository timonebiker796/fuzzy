"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createAgentPolicy = createAgentPolicy;
exports.createAgentPolicyIfNeeded = void 0;
exports.useOnSubmit = useOnSubmit;
var _react = require("react");
var _i18n = require("@kbn/i18n");
var _jsYaml = require("js-yaml");
var _lodash = require("lodash");
var _hooks = require("../../../../../hooks");
var _services = require("../../../../../services");
var _common = require("../../../../../../../../common");
var _services2 = require("../../../../../../../../common/services");
var _hooks2 = require("../../../../../../integrations/hooks");
var _services3 = require("../../services");
var _components = require("../../components");
var _hooks3 = require("../../hooks");
var _prepare_input_pkg_policy_dataset = require("../../services/prepare_input_pkg_policy_dataset");
var _services4 = require("../../../../../../../components/cloud_security_posture/services");
var _setup_technology = require("./setup_technology");
/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0; you may not use this file except in compliance with the Elastic License
 * 2.0.
 */

async function createAgentPolicy({
  packagePolicy,
  newAgentPolicy,
  withSysMonitoring
}) {
  var _packagePolicy$packag;
  // do not create agent policy with system integration if package policy already is for system package
  const packagePolicyIsSystem = (packagePolicy === null || packagePolicy === void 0 ? void 0 : (_packagePolicy$packag = packagePolicy.package) === null || _packagePolicy$packag === void 0 ? void 0 : _packagePolicy$packag.name) === _common.FLEET_SYSTEM_PACKAGE;
  const resp = await (0, _hooks.sendCreateAgentPolicy)(newAgentPolicy, {
    withSysMonitoring: withSysMonitoring && !packagePolicyIsSystem
  });
  if (resp.error) {
    throw resp.error;
  }
  if (!resp.data) {
    throw new Error('Invalid agent policy creation no data');
  }
  return resp.data.item;
}
const createAgentPolicyIfNeeded = async ({
  selectedPolicyTab,
  withSysMonitoring,
  newAgentPolicy,
  packagePolicy,
  packageInfo
}) => {
  if (selectedPolicyTab === _components.SelectedPolicyTab.NEW) {
    var _ref, _newAgentPolicy$monit;
    if ((_ref = withSysMonitoring || ((_newAgentPolicy$monit = newAgentPolicy.monitoring_enabled) === null || _newAgentPolicy$monit === void 0 ? void 0 : _newAgentPolicy$monit.length)) !== null && _ref !== void 0 ? _ref : 0 > 0) {
      var _newAgentPolicy$monit2, _newAgentPolicy$monit3;
      const packagesToPreinstall = [];
      // skip preinstall of input package, to be able to rollback when package policy creation fails
      if (packageInfo && packageInfo.type !== 'input') {
        packagesToPreinstall.push({
          name: packageInfo.name,
          version: packageInfo.version
        });
      }
      if (withSysMonitoring) {
        packagesToPreinstall.push(_common.FLEET_SYSTEM_PACKAGE);
      }
      if ((_newAgentPolicy$monit2 = (_newAgentPolicy$monit3 = newAgentPolicy.monitoring_enabled) === null || _newAgentPolicy$monit3 === void 0 ? void 0 : _newAgentPolicy$monit3.length) !== null && _newAgentPolicy$monit2 !== void 0 ? _newAgentPolicy$monit2 : 0 > 0) {
        packagesToPreinstall.push(_common.FLEET_ELASTIC_AGENT_PACKAGE);
      }
      if (packagesToPreinstall.length > 0) {
        await (0, _hooks.sendBulkInstallPackages)([...new Set(packagesToPreinstall)]);
      }
    }
    return await createAgentPolicy({
      newAgentPolicy,
      packagePolicy,
      withSysMonitoring
    });
  }
};
exports.createAgentPolicyIfNeeded = createAgentPolicyIfNeeded;
async function savePackagePolicy(pkgPolicy) {
  const {
    policy,
    forceCreateNeeded
  } = await (0, _prepare_input_pkg_policy_dataset.prepareInputPackagePolicyDataset)(pkgPolicy);
  const result = await (0, _hooks.sendCreatePackagePolicy)({
    ...policy,
    ...(forceCreateNeeded && {
      force: true
    })
  });
  return result;
}
const DEFAULT_PACKAGE_POLICY = {
  name: '',
  description: '',
  namespace: '',
  policy_id: '',
  policy_ids: [''],
  enabled: true,
  inputs: []
};
function useOnSubmit({
  agentCount,
  selectedPolicyTab,
  newAgentPolicy,
  withSysMonitoring,
  queryParamsPolicyId,
  packageInfo,
  integrationToEnable,
  hasFleetAddAgentsPrivileges
}) {
  const {
    notifications
  } = (0, _hooks.useStartServices)();
  const confirmForceInstall = (0, _hooks2.useConfirmForceInstall)();
  // only used to store the resulting package policy once saved
  const [savedPackagePolicy, setSavedPackagePolicy] = (0, _react.useState)();
  // Form state
  const [formState, setFormState] = (0, _react.useState)('VALID');

  // Used to render extension components only when package policy is initialized
  const [isInitialized, setIsInitialized] = (0, _react.useState)(false);
  // Used to initialize the package policy once
  const isInitializedRef = (0, _react.useRef)(false);
  const [agentPolicies, setAgentPolicies] = (0, _react.useState)([]);
  // New package policy state
  const [packagePolicy, setPackagePolicy] = (0, _react.useState)({
    ...DEFAULT_PACKAGE_POLICY
  });

  // Validation state
  const [validationResults, setValidationResults] = (0, _react.useState)();
  const [hasAgentPolicyError, setHasAgentPolicyError] = (0, _react.useState)(false);
  const hasErrors = validationResults ? (0, _services3.validationHasErrors)(validationResults) : false;
  const {
    isAgentlessIntegration,
    isAgentlessAgentPolicy,
    isAgentlessPackagePolicy
  } = (0, _setup_technology.useAgentless)();

  // Update agent policy method
  const updateAgentPolicies = (0, _react.useCallback)(updatedAgentPolicies => {
    if ((0, _lodash.isEqual)(updatedAgentPolicies, agentPolicies)) {
      return;
    }
    if (updatedAgentPolicies.length > 0) {
      setAgentPolicies(updatedAgentPolicies);
      if (packageInfo) {
        setHasAgentPolicyError(false);
      }
    } else {
      setHasAgentPolicyError(true);
      setAgentPolicies([]);
    }

    // eslint-disable-next-line no-console
    console.debug('Agent policy updated', updatedAgentPolicies);
  }, [packageInfo, agentPolicies]);
  // Update package policy validation
  const updatePackagePolicyValidation = (0, _react.useCallback)(newPackagePolicy => {
    if (packageInfo) {
      const newValidationResult = (0, _services3.validatePackagePolicy)(newPackagePolicy || packagePolicy, packageInfo, _jsYaml.safeLoad);
      setValidationResults(newValidationResult);
      // eslint-disable-next-line no-console
      console.debug('Package policy validation results', newValidationResult);
      return newValidationResult;
    }
  }, [packagePolicy, packageInfo]);
  // Update package policy method
  const updatePackagePolicy = (0, _react.useCallback)(updatedFields => {
    const newPackagePolicy = {
      ...packagePolicy,
      ...updatedFields
    };
    setPackagePolicy(newPackagePolicy);

    // eslint-disable-next-line no-console
    console.debug('Package policy updated', newPackagePolicy);
    const newValidationResults = updatePackagePolicyValidation(newPackagePolicy);
    const hasPackage = newPackagePolicy.package;
    const hasValidationErrors = newValidationResults ? (0, _services3.validationHasErrors)(newValidationResults) : false;
    const hasAgentPolicy = newPackagePolicy.policy_ids.length > 0 && newPackagePolicy.policy_ids[0] !== '';
    if (hasPackage && (hasAgentPolicy || selectedPolicyTab === _components.SelectedPolicyTab.NEW) && !hasValidationErrors) {
      setFormState('VALID');
    } else {
      setFormState('INVALID');
    }
  }, [packagePolicy, setFormState, updatePackagePolicyValidation, selectedPolicyTab]);

  // Initial loading of package info
  (0, _react.useEffect)(() => {
    async function init() {
      if (isInitializedRef.current || !packageInfo) {
        return;
      }

      // Fetch all packagePolicies having the package name
      const {
        data: packagePolicyData
      } = await (0, _hooks.sendGetPackagePolicies)({
        perPage: _common.SO_SEARCH_LIMIT,
        page: 1,
        kuery: `${_common.PACKAGE_POLICY_SAVED_OBJECT_TYPE}.package.name:${packageInfo.name}`
      });
      const incrementedName = (0, _services2.getMaxPackageName)(packageInfo.name, packagePolicyData === null || packagePolicyData === void 0 ? void 0 : packagePolicyData.items);
      isInitializedRef.current = true;
      updatePackagePolicy((0, _services.packageToPackagePolicy)(packageInfo, agentPolicies.map(policy => policy.id), '', DEFAULT_PACKAGE_POLICY.name || incrementedName, DEFAULT_PACKAGE_POLICY.description, integrationToEnable));
      setIsInitialized(true);
    }
    init();
  }, [packageInfo, agentPolicies, updatePackagePolicy, integrationToEnable, isInitialized]);
  (0, _react.useEffect)(() => {
    if (agentPolicies.length > 0 && !(0, _lodash.isEqual)(agentPolicies.map(policy => policy.id), packagePolicy.policy_ids)) {
      updatePackagePolicy({
        policy_ids: agentPolicies.map(policy => policy.id)
      });
    }
  }, [packagePolicy, agentPolicies, updatePackagePolicy]);
  const onSaveNavigate = (0, _hooks3.useOnSaveNavigate)({
    packagePolicy,
    queryParamsPolicyId
  });
  const navigateAddAgent = policy => onSaveNavigate(policy, ['openEnrollmentFlyout']);
  const navigateAddAgentHelp = policy => onSaveNavigate(policy, ['showAddAgentHelp']);
  const onSubmit = (0, _react.useCallback)(async ({
    force,
    overrideCreatedAgentPolicy
  } = {}) => {
    var _createdPolicy, _createdPolicy2;
    if (formState === 'VALID' && hasErrors) {
      setFormState('INVALID');
      return;
    }
    if (agentCount !== 0 && !(isAgentlessIntegration(packageInfo) || isAgentlessPackagePolicy(packagePolicy)) && formState !== 'CONFIRM') {
      setFormState('CONFIRM');
      return;
    }
    let createdPolicy = overrideCreatedAgentPolicy;
    if (!overrideCreatedAgentPolicy) {
      try {
        setFormState('LOADING');
        const newPolicy = await createAgentPolicyIfNeeded({
          newAgentPolicy,
          packagePolicy,
          withSysMonitoring,
          packageInfo,
          selectedPolicyTab
        });
        if (newPolicy) {
          createdPolicy = newPolicy;
          setAgentPolicies([createdPolicy]);
          updatePackagePolicy({
            policy_ids: [createdPolicy.id]
          });
        }
      } catch (e) {
        setFormState('VALID');
        notifications.toasts.addError(e, {
          title: _i18n.i18n.translate('xpack.fleet.createAgentPolicy.errorNotificationTitle', {
            defaultMessage: 'Unable to create agent policy'
          })
        });
        return;
      }
    }
    const agentPolicyIdToSave = (_createdPolicy = createdPolicy) !== null && _createdPolicy !== void 0 && _createdPolicy.id ? [(_createdPolicy2 = createdPolicy) === null || _createdPolicy2 === void 0 ? void 0 : _createdPolicy2.id] : packagePolicy.policy_ids;
    const shouldForceInstallOnAgentless = isAgentlessAgentPolicy(createdPolicy) || isAgentlessIntegration(packageInfo) || isAgentlessPackagePolicy(packagePolicy);
    const forceInstall = force || shouldForceInstallOnAgentless;
    setFormState('LOADING');
    // passing pkgPolicy with policy_id here as setPackagePolicy doesn't propagate immediately
    const {
      error,
      data
    } = await savePackagePolicy({
      ...packagePolicy,
      policy_ids: agentPolicyIdToSave,
      force: forceInstall
    });
    const hasAzureArmTemplate = data !== null && data !== void 0 && data.item ? (0, _services4.getAzureArmPropsFromPackagePolicy)(data.item).templateUrl : false;
    const hasCloudFormation = data !== null && data !== void 0 && data.item ? (0, _services4.getCloudFormationPropsFromPackagePolicy)(data.item).templateUrl : false;
    const hasGoogleCloudShell = data !== null && data !== void 0 && data.item ? (0, _services4.getCloudShellUrlFromPackagePolicy)(data.item) : false;
    if (hasFleetAddAgentsPrivileges) {
      if (hasAzureArmTemplate) {
        setFormState(agentCount ? 'SUBMITTED' : 'SUBMITTED_AZURE_ARM_TEMPLATE');
      } else {
        setFormState(agentCount ? 'SUBMITTED' : 'SUBMITTED_NO_AGENTS');
      }
      if (hasCloudFormation) {
        setFormState(agentCount ? 'SUBMITTED' : 'SUBMITTED_CLOUD_FORMATION');
      } else {
        setFormState(agentCount ? 'SUBMITTED' : 'SUBMITTED_NO_AGENTS');
      }
      if (hasGoogleCloudShell) {
        setFormState(agentCount ? 'SUBMITTED' : 'SUBMITTED_GOOGLE_CLOUD_SHELL');
      } else {
        setFormState(agentCount ? 'SUBMITTED' : 'SUBMITTED_NO_AGENTS');
      }
    } else {
      setFormState('SUBMITTED');
    }
    if (!error) {
      setSavedPackagePolicy(data.item);
      const promptForAgentEnrollment = !(agentCount && agentPolicies.length > 0) && hasFleetAddAgentsPrivileges;
      if (promptForAgentEnrollment && hasAzureArmTemplate) {
        setFormState('SUBMITTED_AZURE_ARM_TEMPLATE');
        return;
      }
      if (promptForAgentEnrollment && hasCloudFormation) {
        setFormState('SUBMITTED_CLOUD_FORMATION');
        return;
      }
      if (promptForAgentEnrollment && hasGoogleCloudShell) {
        setFormState('SUBMITTED_GOOGLE_CLOUD_SHELL');
        return;
      }
      if (promptForAgentEnrollment) {
        setFormState('SUBMITTED_NO_AGENTS');
        return;
      }
      onSaveNavigate(data.item);
      notifications.toasts.addSuccess({
        title: _i18n.i18n.translate('xpack.fleet.createPackagePolicy.addedNotificationTitle', {
          defaultMessage: `''{packagePolicyName}'' integration added.`,
          values: {
            packagePolicyName: packagePolicy.name
          }
        }),
        text: promptForAgentEnrollment ? _i18n.i18n.translate('xpack.fleet.createPackagePolicy.addedNotificationMessage', {
          defaultMessage: `Fleet will deploy updates to all agents that use the ''{agentPolicyNames}'' policies.`,
          values: {
            agentPolicyNames: agentPolicies.map(policy => policy.name).join(', ')
          }
        }) : undefined,
        'data-test-subj': 'packagePolicyCreateSuccessToast'
      });
    } else {
      if ((0, _services.isVerificationError)(error)) {
        setFormState('VALID'); // don't show the add agent modal
        const forceInstallUnverifiedIntegration = await confirmForceInstall(packagePolicy.package);
        if (forceInstallUnverifiedIntegration) {
          // skip creating the agent policy because it will have already been successfully created
          onSubmit({
            overrideCreatedAgentPolicy: createdPolicy,
            force: true
          });
        }
        return;
      }
      notifications.toasts.addError(error, {
        title: 'Error'
      });
      setFormState('VALID');
    }
  }, [formState, hasErrors, agentCount, isAgentlessIntegration, packageInfo, selectedPolicyTab, packagePolicy, isAgentlessAgentPolicy, isAgentlessPackagePolicy, hasFleetAddAgentsPrivileges, withSysMonitoring, newAgentPolicy, updatePackagePolicy, notifications.toasts, agentPolicies, onSaveNavigate, confirmForceInstall]);
  return {
    agentPolicies,
    updateAgentPolicies,
    packagePolicy,
    updatePackagePolicy,
    savedPackagePolicy,
    onSubmit,
    formState,
    setFormState,
    hasErrors,
    validationResults,
    setValidationResults,
    hasAgentPolicyError,
    setHasAgentPolicyError,
    isInitialized,
    // TODO check
    navigateAddAgent,
    navigateAddAgentHelp
  };
}