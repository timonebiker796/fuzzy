"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.prepareRoutes = exports.getVersionedHeaderParam = exports.getVersionedContentTypeString = exports.getPathParameters = exports.extractValidationSchemaFromRoute = exports.extractTags = exports.extractContentType = exports.buildGlobalTags = exports.assignToPaths = void 0;
var _openapiTypes = require("openapi-types");
var _coreHttpServer = require("@kbn/core-http-server");
/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0 and the Server Side Public License, v 1; you may not use this file except
 * in compliance with, at your election, the Elastic License 2.0 or the Server
 * Side Public License, v 1.
 */

// eslint-disable-next-line import/no-extraneous-dependencies

const tagPrefix = 'oas-tag:';
const extractTag = tag => {
  if (tag.startsWith(tagPrefix)) {
    return tag.slice(tagPrefix.length);
  }
};
/**
 * Given an array of tags ([oas-tag:beep, oas-tag:boop]) will return a new array
 * with the tag prefix removed.
 */
const extractTags = tags => {
  if (!tags) return [];
  return tags.flatMap(tag => {
    const value = extractTag(tag);
    if (value) {
      return value;
    }
    return [];
  });
};

/**
 * Build the top-level tags entry based on the paths we extracted. We could
 * handle this while we are iterating over the routes, but this approach allows
 * us to keep this as a global document concern at the expense of some extra
 * processing.
 */
exports.extractTags = extractTags;
const buildGlobalTags = (paths, additionalTags = []) => {
  const tags = new Set(additionalTags);
  for (const path of Object.values(paths)) {
    for (const method of Object.values(_openapiTypes.OpenAPIV3.HttpMethods)) {
      var _path$method;
      if (path !== null && path !== void 0 && (_path$method = path[method]) !== null && _path$method !== void 0 && _path$method.tags) {
        path[method].tags.forEach(tag => tags.add(tag));
      }
    }
  }
  return Array.from(tags).sort((a, b) => a.localeCompare(b)).map(name => ({
    name
  }));
};
exports.buildGlobalTags = buildGlobalTags;
const getPathParameters = path => {
  return Array.from(path.matchAll(/\{(.+?)\}/g)).reduce((acc, [_, key]) => {
    const optional = key.endsWith('?');
    acc[optional ? key.slice(0, key.length - 1) : key] = {
      optional
    };
    return acc;
  }, {});
};
exports.getPathParameters = getPathParameters;
const extractContentType = body => {
  if (body !== null && body !== void 0 && body.accepts) {
    return Array.isArray(body.accepts) ? body.accepts : [body.accepts];
  }
  return ['application/json'];
};
exports.extractContentType = extractContentType;
const getVersionedContentTypeString = (version, acceptedContentTypes) => {
  return `${acceptedContentTypes.join('; ')}; Elastic-Api-Version=${version}`;
};
exports.getVersionedContentTypeString = getVersionedContentTypeString;
const extractValidationSchemaFromRoute = route => {
  if (!route.validationSchemas) return undefined;
  return (0, _coreHttpServer.getRequestValidation)(route.validationSchemas);
};
exports.extractValidationSchemaFromRoute = extractValidationSchemaFromRoute;
const getVersionedHeaderParam = (defaultVersion, versions) => ({
  in: 'header',
  name: 'elastic-api-version',
  description: 'The version of the API to use',
  schema: {
    type: 'string',
    enum: versions,
    default: defaultVersion
  }
});
exports.getVersionedHeaderParam = getVersionedHeaderParam;
const prepareRoutes = (routes, filters = {}) => {
  if (Object.getOwnPropertyNames(filters).length === 0) return routes;
  return routes.filter(route => {
    if (filters.excludePathsMatching && filters.excludePathsMatching.some(ex => route.path.startsWith(ex))) {
      return false;
    }
    if (filters.pathStartsWith && !filters.pathStartsWith.some(p => route.path.startsWith(p))) {
      return false;
    }
    if (filters.access && route.options.access !== filters.access) return false;
    return true;
  });
};
exports.prepareRoutes = prepareRoutes;
const assignToPaths = (paths, path, pathObject) => {
  const pathName = path.replace('?', '');
  paths[pathName] = {
    ...paths[pathName],
    ...pathObject
  };
};
exports.assignToPaths = assignToPaths;