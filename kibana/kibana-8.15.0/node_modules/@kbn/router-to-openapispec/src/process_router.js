"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.processRouter = exports.extractResponses = void 0;
var _coreHttpServer = require("@kbn/core-http-server");
var _coreHttpRouterServerInternal = require("@kbn/core-http-router-server-internal");
var _util = require("./util");
/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0 and the Server Side Public License, v 1; you may not use this file except
 * in compliance with, at your election, the Elastic License 2.0 or the Server
 * Side Public License, v 1.
 */

const processRouter = (appRouter, converter, getOpId, filters) => {
  const paths = {};
  if (filters !== null && filters !== void 0 && filters.version && filters.version !== _coreHttpRouterServerInternal.ALLOWED_PUBLIC_VERSION) return {
    paths
  };
  const routes = (0, _util.prepareRoutes)(appRouter.getRoutes({
    excludeVersionedRoutes: true
  }), filters);
  for (const route of routes) {
    try {
      var _route$options, _route$options$summar;
      const pathParams = (0, _util.getPathParameters)(route.path);
      const validationSchemas = (0, _util.extractValidationSchemaFromRoute)(route);
      const contentType = (0, _util.extractContentType)((_route$options = route.options) === null || _route$options === void 0 ? void 0 : _route$options.body);
      let parameters = [];
      if (validationSchemas) {
        let pathObjects = [];
        let queryObjects = [];
        const reqParams = validationSchemas.params;
        if (reqParams) {
          pathObjects = converter.convertPathParameters(reqParams, pathParams);
        }
        const reqQuery = validationSchemas.query;
        if (reqQuery) {
          queryObjects = converter.convertQuery(reqQuery);
        }
        parameters = [(0, _util.getVersionedHeaderParam)(_coreHttpRouterServerInternal.ALLOWED_PUBLIC_VERSION, [_coreHttpRouterServerInternal.ALLOWED_PUBLIC_VERSION]), ...pathObjects, ...queryObjects];
      }
      const operation = {
        summary: (_route$options$summar = route.options.summary) !== null && _route$options$summar !== void 0 ? _route$options$summar : '',
        tags: route.options.tags ? (0, _util.extractTags)(route.options.tags) : [],
        ...(route.options.description ? {
          description: route.options.description
        } : {}),
        ...(route.options.deprecated ? {
          deprecated: route.options.deprecated
        } : {}),
        requestBody: !!(validationSchemas !== null && validationSchemas !== void 0 && validationSchemas.body) ? {
          content: {
            [(0, _util.getVersionedContentTypeString)(_coreHttpRouterServerInternal.ALLOWED_PUBLIC_VERSION, contentType)]: {
              schema: converter.convert(validationSchemas.body)
            }
          }
        } : undefined,
        responses: extractResponses(route, converter),
        parameters,
        operationId: getOpId(route.path)
      };
      const path = {
        [route.method]: operation
      };
      (0, _util.assignToPaths)(paths, route.path, path);
    } catch (e) {
      // Enrich the error message with a bit more context
      e.message = `Error generating OpenAPI for route '${route.path}': ${e.message}`;
      throw e;
    }
  }
  return {
    paths
  };
};
exports.processRouter = processRouter;
const extractResponses = (route, converter) => {
  const responses = {};
  if (!route.validationSchemas) return responses;
  const fullConfig = (0, _coreHttpServer.getResponseValidation)(route.validationSchemas);
  if (fullConfig) {
    var _route$options2;
    const {
      unsafe,
      ...validationSchemas
    } = fullConfig;
    const contentType = (0, _util.extractContentType)((_route$options2 = route.options) === null || _route$options2 === void 0 ? void 0 : _route$options2.body);
    return Object.entries(validationSchemas).reduce((acc, [statusCode, schema]) => {
      var _acc$statusCode;
      const oasSchema = converter.convert(schema.body());
      acc[statusCode] = {
        ...acc[statusCode],
        content: {
          ...((_acc$statusCode = acc[statusCode]) !== null && _acc$statusCode !== void 0 ? _acc$statusCode : {}).content,
          [(0, _util.getVersionedContentTypeString)(_coreHttpRouterServerInternal.ALLOWED_PUBLIC_VERSION, schema.bodyContentType ? [schema.bodyContentType] : contentType)]: {
            schema: oasSchema
          }
        }
      };
      return acc;
    }, responses);
  }
  return responses;
};
exports.extractResponses = extractResponses;