"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createLiveQueryRoute = void 0;
var _unified = _interopRequireDefault(require("unified"));
var _remarkParseNoTrim = _interopRequireDefault(require("remark-parse-no-trim"));
var _lodash = require("lodash");
var _fastDeepEqual = _interopRequireDefault(require("fast-deep-equal"));
var _api = require("../../../common/api");
var _constants = require("../../../common/constants");
var _errors = require("../../../common/translations/errors");
var _replace_params_query = require("../../../common/utils/replace_params_query");
var _route_validation = require("../../utils/build_validation/route_validation");
var _handlers = require("../../handlers");
var _osquery_parser = require("./osquery_parser");
/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0; you may not use this file except in compliance with the Elastic License
 * 2.0.
 */

const createLiveQueryRoute = (router, osqueryContext) => {
  router.versioned.post({
    access: 'public',
    path: '/api/osquery/live_queries'
  }).addVersion({
    version: _constants.API_VERSIONS.public.v1,
    validate: {
      request: {
        body: (0, _route_validation.buildRouteValidation)(_api.createLiveQueryRequestBodySchema)
      }
    }
  }, async (context, request, response) => {
    var _osqueryContext$servi, _request$body$alert_i;
    const [coreStartServices] = await osqueryContext.getStartServices();
    const coreContext = await context.core;
    const soClient = coreContext.savedObjects.client;
    const {
      osquery: {
        writeLiveQueries,
        runSavedQueries
      }
    } = await coreStartServices.capabilities.resolveCapabilities(request, {
      capabilityPath: 'osquery.*'
    });
    const isInvalid = !(writeLiveQueries || runSavedQueries && (request.body.saved_query_id || request.body.pack_id));
    const client = await ((_osqueryContext$servi = osqueryContext.service.getRuleRegistryService()) === null || _osqueryContext$servi === void 0 ? void 0 : _osqueryContext$servi.getRacClientWithRequest(request));
    const alertData = (_request$body$alert_i = request.body.alert_ids) !== null && _request$body$alert_i !== void 0 && _request$body$alert_i.length ? await (client === null || client === void 0 ? void 0 : client.get({
      id: request.body.alert_ids[0]
    })) : undefined;
    if (isInvalid) {
      var _request$body$alert_i2;
      if ((_request$body$alert_i2 = request.body.alert_ids) !== null && _request$body$alert_i2 !== void 0 && _request$body$alert_i2.length) {
        try {
          if (alertData !== null && alertData !== void 0 && alertData['kibana.alert.rule.note']) {
            const parsedAlertInvestigationGuide = (0, _unified.default)().use([[_remarkParseNoTrim.default, {}], _osquery_parser.parser]).parse(alertData === null || alertData === void 0 ? void 0 : alertData['kibana.alert.rule.note']);
            const osqueryQueries = (0, _lodash.filter)(parsedAlertInvestigationGuide === null || parsedAlertInvestigationGuide === void 0 ? void 0 : parsedAlertInvestigationGuide.children, ['type', 'osquery']);
            const requestQueryExistsInTheInvestigationGuide = (0, _lodash.some)(osqueryQueries, payload => {
              const {
                result: replacedConfigurationQuery
              } = (0, _replace_params_query.replaceParamsQuery)(payload.configuration.query, alertData);
              return replacedConfigurationQuery === request.body.query && (0, _fastDeepEqual.default)(payload.configuration.ecs_mapping, request.body.ecs_mapping);
            });
            if (!requestQueryExistsInTheInvestigationGuide) throw new Error();
          }
        } catch (error) {
          return response.forbidden();
        }
      } else {
        return response.forbidden();
      }
    }
    try {
      var _coreContext$security;
      const currentUser = (_coreContext$security = coreContext.security.authc.getCurrentUser()) === null || _coreContext$security === void 0 ? void 0 : _coreContext$security.username;
      const {
        response: osqueryAction,
        fleetActionsCount
      } = await (0, _handlers.createActionHandler)(osqueryContext, request.body, {
        soClient,
        metadata: {
          currentUser
        },
        alertData
      });
      if (!fleetActionsCount) {
        return response.badRequest({
          body: _errors.PARAMETER_NOT_FOUND
        });
      }
      return response.ok({
        body: {
          data: osqueryAction
        }
      });
    } catch (error) {
      if (error.statusCode === 400) {
        return response.badRequest({
          body: error
        });
      }
      return response.customError({
        statusCode: 500,
        body: new Error(`Error occurred while processing ${error}`)
      });
    }
  });
};
exports.createLiveQueryRoute = createLiveQueryRoute;