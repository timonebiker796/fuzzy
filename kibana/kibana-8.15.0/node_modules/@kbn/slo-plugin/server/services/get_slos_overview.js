"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GetSLOsOverview = void 0;
var _moment = _interopRequireDefault(require("moment"));
var _common = require("@kbn/observability-plugin/common");
var _queries = require("../utils/queries");
var _transform_generators = require("./transform_generators");
var _slo_settings = require("./slo_settings");
/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0; you may not use this file except in compliance with the Elastic License
 * 2.0.
 */

class GetSLOsOverview {
  constructor(soClient, esClient, spaceId, logger, rulesClient, racClient) {
    this.soClient = soClient;
    this.esClient = esClient;
    this.spaceId = spaceId;
    this.logger = logger;
    this.rulesClient = rulesClient;
    this.racClient = racClient;
  }
  async execute(params = {}) {
    var _params$kqlQuery, _params$filters, _parsedFilters$filter, _parsedFilters$must_n, _aggs$violated$doc_co, _aggs$degrading$doc_c, _aggs$healthy$doc_cou, _aggs$noData$doc_coun, _aggs$stale$doc_count;
    const settings = await (0, _slo_settings.getSloSettings)(this.soClient);
    const {
      indices
    } = await (0, _slo_settings.getListOfSummaryIndices)(this.esClient, settings);
    const kqlQuery = (_params$kqlQuery = params.kqlQuery) !== null && _params$kqlQuery !== void 0 ? _params$kqlQuery : '';
    const filters = (_params$filters = params.filters) !== null && _params$filters !== void 0 ? _params$filters : '';
    const parsedFilters = (0, _transform_generators.parseStringFilters)(filters, this.logger);
    const response = await (0, _queries.typedSearch)(this.esClient, {
      index: indices,
      size: 0,
      query: {
        bool: {
          filter: [{
            term: {
              spaceId: this.spaceId
            }
          }, (0, _transform_generators.getElasticsearchQueryOrThrow)(kqlQuery), ...((_parsedFilters$filter = parsedFilters.filter) !== null && _parsedFilters$filter !== void 0 ? _parsedFilters$filter : [])],
          must_not: [...((_parsedFilters$must_n = parsedFilters.must_not) !== null && _parsedFilters$must_n !== void 0 ? _parsedFilters$must_n : [])]
        }
      },
      body: {
        aggs: {
          worst: {
            top_hits: {
              sort: {
                errorBudgetRemaining: {
                  order: 'asc'
                }
              },
              _source: {
                includes: ['sliValue', 'status', 'slo.id', 'slo.instanceId', 'slo.name']
              },
              size: 1
            }
          },
          stale: {
            filter: {
              range: {
                summaryUpdatedAt: {
                  lt: `now-${settings.staleThresholdInHours}h`
                }
              }
            }
          },
          violated: {
            filter: {
              term: {
                status: 'VIOLATED'
              }
            }
          },
          healthy: {
            filter: {
              term: {
                status: 'HEALTHY'
              }
            }
          },
          degrading: {
            filter: {
              term: {
                status: 'DEGRADING'
              }
            }
          },
          noData: {
            filter: {
              term: {
                status: 'NO_DATA'
              }
            }
          }
        }
      }
    });
    const [rules, alerts] = await Promise.all([this.rulesClient.find({
      options: {
        search: 'alert.attributes.alertTypeId:("slo.rules.burnRate")'
      }
    }), this.racClient.getAlertSummary({
      featureIds: _common.observabilityAlertFeatureIds,
      gte: (0, _moment.default)().subtract(24, 'hours').toISOString(),
      lte: (0, _moment.default)().toISOString(),
      filter: [{
        term: {
          'kibana.alert.rule.rule_type_id': 'slo.rules.burnRate'
        }
      }]
    })]);
    const aggs = response.aggregations;
    return {
      violated: (_aggs$violated$doc_co = aggs === null || aggs === void 0 ? void 0 : aggs.violated.doc_count) !== null && _aggs$violated$doc_co !== void 0 ? _aggs$violated$doc_co : 0,
      degrading: (_aggs$degrading$doc_c = aggs === null || aggs === void 0 ? void 0 : aggs.degrading.doc_count) !== null && _aggs$degrading$doc_c !== void 0 ? _aggs$degrading$doc_c : 0,
      healthy: (_aggs$healthy$doc_cou = aggs === null || aggs === void 0 ? void 0 : aggs.healthy.doc_count) !== null && _aggs$healthy$doc_cou !== void 0 ? _aggs$healthy$doc_cou : 0,
      noData: (_aggs$noData$doc_coun = aggs === null || aggs === void 0 ? void 0 : aggs.noData.doc_count) !== null && _aggs$noData$doc_coun !== void 0 ? _aggs$noData$doc_coun : 0,
      stale: (_aggs$stale$doc_count = aggs === null || aggs === void 0 ? void 0 : aggs.stale.doc_count) !== null && _aggs$stale$doc_count !== void 0 ? _aggs$stale$doc_count : 0,
      worst: {
        value: 0,
        id: 'id'
      },
      burnRateRules: rules.total,
      burnRateActiveAlerts: alerts.activeAlertCount,
      burnRateRecoveredAlerts: alerts.recoveredAlertCount
    };
  }
}
exports.GetSLOsOverview = GetSLOsOverview;